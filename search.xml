<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>2020台灣資訊奧林匹亞研習營初選</title>
    <url>/2020%E5%8F%B0%E7%81%A3%E8%B3%87%E8%A8%8A%E5%A5%A7%E6%9E%97%E5%8C%B9%E4%BA%9E%E7%A0%94%E7%BF%92%E7%87%9F%E5%88%9D%E9%81%B8/</url>
    <content><![CDATA[<p>第一次的成果驗收</p>
<span id="more"></span>
<h1 id="賽前"><a href="#賽前" class="headerlink" title="賽前"></a>賽前</h1><h2 id="入坑競程"><a href="#入坑競程" class="headerlink" title="入坑競程"></a>入坑競程</h2><p>大概在八月底的時候(?<br>當時打了三個月的<a href="https://osu.ppy.sh/home">osu!</a> 然後覺得打到無聊就想說要找個事情來做XD<br>於是就想說我也愛寫程式就來競程了</p>
<h2 id="心態"><a href="#心態" class="headerlink" title="心態"></a>心態</h2><p>大概練習了半年 我對自己實力也不是很了解<br>其實我也有點想進選訓營看看啦<br>高一進選訓代表至少到高二前我都能安心打code<br>所以就來看看了(?</p>
<h2 id="報到"><a href="#報到" class="headerlink" title="報到"></a>報到</h2><p>遇到好多電神 也第一次見到傳說中的<a href="https://omeletwithoutegg.github.io/">蛋餅</a> (# orz<br>原本要複習一下模板但是想說算了 好懶</p>
<h1 id="賽中"><a href="#賽中" class="headerlink" title="賽中"></a>賽中</h1><p>開場先把全部題目看完<br>確認好每題子測資是否可做<br>然後pA水題 於是我把它變綠了<br>之後做pB 53分可做 我就153了<br>然後pC題目好長 看完後發現是模數 慘 我遇到模數一般都會炸掉 跳過<br>pD的56分可做 我就開刻了<br>. . .<br>然後一個小時過去了 我還是0分 不知道bug在哪<br>於是就去看pE<br>發現pE好難 但是37分好甜 就拿了<br>此時190 我手已經在發抖了 剩不到一個小時<br>pC題目真的很長 給很多算式<br>那些算式都是可用的 但不用全用<br>我卻專注在最難用的那個上 一直在想怎麼模數取平方根<br>後來半個小時我回去de pD 也是沒de到<br>190/500 Rank:71</p>
<h1 id="賽後"><a href="#賽後" class="headerlink" title="賽後"></a>賽後</h1><p>出來後冷靜一下<br>問了其他人pD的測資 發現是特判<br>我也有特判 我也在特判那邊用一樣的方法<br>為何會WA 我真的不懂<br>且才發現pCpD都是水題 我太執著於拿部分分了<br>結果就完全沒往正解想<br>但這場賽中的心態有穩住 至少不會崩潰放棄</p>
<hr>
<p>原本想去打mai 發現自己完全沒那個心情<br>就直接回家了<br>還是很無法接受個結果<br>到底出了什麼問題 還是純粹我就真的實力不夠?<br>我之後想要再多練習QQ 很不甘心實力就這樣<br><em><strong>我就爛 但我想要變強</strong></em></p>
]]></content>
      <tags>
        <tag>Competitive Programming</tag>
        <tag>TOI</tag>
        <tag>experience</tag>
      </tags>
  </entry>
  <entry>
    <title>CFRound#617(Div3)</title>
    <url>/CFRound-617-Div3/</url>
    <content><![CDATA[<p><a href="https://codeforces.com/contest/1296">競賽連結</a></p>
<span id="more"></span>
<h1 id="A-Array-with-Odd-Sum"><a href="#A-Array-with-Odd-Sum" class="headerlink" title="A. Array with Odd Sum"></a><a href="https://codeforces.com/contest/1296/problem/A">A. Array with Odd Sum</a></h1><ul>
<li>操作:可以把一個數列的兩個數$a_i$指定給$a_j(i\neq j)$</li>
</ul>
<p>給你原數列 問能不能用上面的方法將數列的總和變成奇數</p>
<hr>
<p>很顯然的 滿足以下條件就可</p>
<ul>
<li>數列至少要有一個奇數</li>
<li>如果數列長度是偶數 則至少還要有一個偶數</li>
</ul>
<p>不滿足以上條件就無解<br>複雜度$O(n)$</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">--------------              |   /</span></span><br><span class="line"><span class="comment">      |                     |  /</span></span><br><span class="line"><span class="comment">      |                     | /</span></span><br><span class="line"><span class="comment">      |             *       |/          |    |         ------            *</span></span><br><span class="line"><span class="comment">      |                     |           |    |        /      \</span></span><br><span class="line"><span class="comment">      |             |       |\          |    |       |       |\          |</span></span><br><span class="line"><span class="comment">   \  |             |       | \         |    |       |       | \         |</span></span><br><span class="line"><span class="comment">    \ |             |       |  \        |    |        \     /   \        |</span></span><br><span class="line"><span class="comment">     V              |       |   \        \__/|         -----     \       |</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EmiliaMyWife ios::sync_with_stdio(0); cin.tie(NULL);</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> endl <span class="meta-string">&#x27;\n&#x27;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mem(i,j) memset(i,j,sizeof i);</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> F first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> S second</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mp make_pair</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> all(a) a.begin(), a.end()</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> bit(s,i) (((s)&gt;&gt;(i))&amp;1LL)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lowbit(x) (x&amp;-x)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> siz(v) (long long)v.size()</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int64_t</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">uint64_t</span> ull;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; pii;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;ll, ll&gt; pll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> EPS  = <span class="number">1e-8</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF     = <span class="number">0x3F3F3F3F</span>;</span><br><span class="line"><span class="keyword">const</span> ll LINF     = <span class="number">4611686018427387903</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MOD     = <span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN    = <span class="number">2e5</span>+<span class="number">9</span>;</span><br><span class="line"><span class="comment">/*-----------------------------------------------------------------------------------------------------*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    EmiliaMyWife</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> t;</span><br><span class="line">    cin &gt;&gt; t;</span><br><span class="line">    <span class="keyword">while</span>(t--) &#123;</span><br><span class="line">        <span class="keyword">int</span> n;</span><br><span class="line">        cin &gt;&gt; n;</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">arr</span><span class="params">(n)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) cin &gt;&gt; arr[i];</span><br><span class="line">        <span class="keyword">bool</span> ok[<span class="number">2</span>]=&#123;<span class="literal">false</span>, <span class="literal">false</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            ok[arr[i]&amp;<span class="number">1</span>]=<span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(n&amp;<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(ok[<span class="number">1</span>]) cout &lt;&lt; <span class="string">&quot;YES&quot;</span>;</span><br><span class="line">            <span class="keyword">else</span> cout &lt;&lt; <span class="string">&quot;NO&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(ok[<span class="number">1</span>] &amp;&amp; ok[<span class="number">0</span>]) cout &lt;&lt; <span class="string">&quot;YES&quot;</span>;</span><br><span class="line">            <span class="keyword">else</span> cout &lt;&lt; <span class="string">&quot;NO&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="B-Food-Buying"><a href="#B-Food-Buying" class="headerlink" title="B. Food Buying"></a><a href="https://codeforces.com/contest/1296/problem/B">B. Food Buying</a></h1><p>有$s$元<br/><br>可以花費$x(1\le x)$元 拿回$\lfloor\frac{x}{10}\rfloor$元(也就是無條件捨去後的$\frac{x}{10}$)<br/><br>問最多可以花費幾元</p>
<hr>
<p>因為當$x&gt;10$的話個位數會被捨去 所以最好的辦法就是每次都支出$10$的倍數<br/><br>只要不斷花到沒錢就好 記得剩個位數時還能再花光(拿回$0$元)<br/><br>複雜度$O(T\log_{10}{s})$</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">--------------              |   /</span></span><br><span class="line"><span class="comment">      |                     |  /</span></span><br><span class="line"><span class="comment">      |                     | /</span></span><br><span class="line"><span class="comment">      |             *       |/          |    |         ------            *</span></span><br><span class="line"><span class="comment">      |                     |           |    |        /      \</span></span><br><span class="line"><span class="comment">      |             |       |\          |    |       |       |\          |</span></span><br><span class="line"><span class="comment">   \  |             |       | \         |    |       |       | \         |</span></span><br><span class="line"><span class="comment">    \ |             |       |  \        |    |        \     /   \        |</span></span><br><span class="line"><span class="comment">     V              |       |   \        \__/|         -----     \       |</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EmiliaMyWife ios::sync_with_stdio(0); cin.tie(NULL);</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> endl <span class="meta-string">&#x27;\n&#x27;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mem(i,j) memset(i,j,sizeof i);</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> F first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> S second</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mp make_pair</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> all(a) a.begin(), a.end()</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> bit(s,i) (((s)&gt;&gt;(i))&amp;1LL)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lowbit(x) (x&amp;-x)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> siz(v) (long long)v.size()</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int64_t</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">uint64_t</span> ull;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; pii;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;ll, ll&gt; pll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> EPS  = <span class="number">1e-8</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF     = <span class="number">0x3F3F3F3F</span>;</span><br><span class="line"><span class="keyword">const</span> ll LINF     = <span class="number">4611686018427387903</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MOD     = <span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN    = <span class="number">2e5</span>+<span class="number">9</span>;</span><br><span class="line"><span class="comment">/*-----------------------------------------------------------------------------------------------------*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    EmiliaMyWife</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> t;</span><br><span class="line">    cin &gt;&gt; t;</span><br><span class="line">    <span class="keyword">while</span>(t--) &#123;</span><br><span class="line">        ll a, b=<span class="number">0</span>, ans=<span class="number">0</span>;</span><br><span class="line">        cin &gt;&gt; a;</span><br><span class="line">        b=a%<span class="number">10</span>; a-=b;</span><br><span class="line">        <span class="keyword">while</span>(a) &#123;</span><br><span class="line">            ans+=a;</span><br><span class="line">            a/=<span class="number">10</span>;</span><br><span class="line">            b+=a;</span><br><span class="line">            a=b/<span class="number">10</span>*<span class="number">10</span>; b%=<span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ans+=b;</span><br><span class="line">        cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="C-Yet-Another-Walking-Robot"><a href="#C-Yet-Another-Walking-Robot" class="headerlink" title="C. Yet Another Walking Robot"></a><a href="https://codeforces.com/contest/1296/problem/C">C. Yet Another Walking Robot</a></h1><p>給定字串$s$<br/><br>$UDLR$代表上下左右<br/><br>求一最大區間使得區間內的$L$的數量=$R$的數量且$U$的數量=$D$的數量</p>
<hr>
<p>雷死 這題我想超久 甚至還FST 我是智障==<br>反正就是先預處理把前綴的數量都先弄出來<br>然後再爬行一次 用map存”這個數量 最後一次出現的位置”<br>然後取最大長度<br>複雜度$O(|s|log|s|)$</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">--------------              |   /</span></span><br><span class="line"><span class="comment">      |                     |  /</span></span><br><span class="line"><span class="comment">      |                     | /</span></span><br><span class="line"><span class="comment">      |             *       |/          |    |         ------            *</span></span><br><span class="line"><span class="comment">      |                     |           |    |        /      \</span></span><br><span class="line"><span class="comment">      |             |       |\          |    |       |       |\          |</span></span><br><span class="line"><span class="comment">   \  |             |       | \         |    |       |       | \         |</span></span><br><span class="line"><span class="comment">    \ |             |       |  \        |    |        \     /   \        |</span></span><br><span class="line"><span class="comment">     V              |       |   \        \__/|         -----     \       |</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EmiliaMyWife ios::sync_with_stdio(0); cin.tie(NULL);</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> endl <span class="meta-string">&#x27;\n&#x27;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mem(i,j) memset(i,j,sizeof i);</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> F first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> S second</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mp make_pair</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> all(a) a.begin(), a.end()</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> bit(s,i) (((s)&gt;&gt;(i))&amp;1LL)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lowbit(x) (x&amp;-x)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> siz(v) (long long)v.size()</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int64_t</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">uint64_t</span> ull;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; pii;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;ll, ll&gt; pll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> EPS  = <span class="number">1e-8</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF     = <span class="number">0x3F3F3F3F</span>;</span><br><span class="line"><span class="keyword">const</span> ll LINF     = <span class="number">4611686018427387903</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MOD     = <span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN    = <span class="number">2e5</span>+<span class="number">9</span>;</span><br><span class="line"><span class="comment">/*-----------------------------------------------------------------------------------------------------*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    EmiliaMyWife</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> t;</span><br><span class="line">    cin &gt;&gt; t;</span><br><span class="line">    <span class="keyword">while</span>(t--) &#123;</span><br><span class="line">        <span class="keyword">int</span> n;</span><br><span class="line">        string s;</span><br><span class="line">        map&lt;pii, <span class="keyword">int</span>&gt; pos;</span><br><span class="line">        cin &gt;&gt; n &gt;&gt; s;</span><br><span class="line">        <span class="function">vector&lt;pii&gt; <span class="title">arr</span><span class="params">(n)</span></span>;</span><br><span class="line">        pos.<span class="built_in">clear</span>();</span><br><span class="line">        <span class="keyword">int</span> a=<span class="number">0</span>, b=<span class="number">0</span>, l=<span class="number">1</span>, r=INF;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i]==<span class="string">&#x27;L&#x27;</span>) a++;</span><br><span class="line">            <span class="keyword">if</span>(s[i]==<span class="string">&#x27;R&#x27;</span>) a--;</span><br><span class="line">            <span class="keyword">if</span>(s[i]==<span class="string">&#x27;U&#x27;</span>) b++;</span><br><span class="line">            <span class="keyword">if</span>(s[i]==<span class="string">&#x27;D&#x27;</span>) b--;</span><br><span class="line">            arr[i]=<span class="built_in">mp</span>(a, b);</span><br><span class="line">            <span class="keyword">if</span>(a==<span class="number">0</span> &amp;&amp; b==<span class="number">0</span>) r=<span class="built_in">min</span>(r, i+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            a=arr[i].F, b=arr[i].S;</span><br><span class="line">            <span class="keyword">if</span>(pos[<span class="built_in">mp</span>(a, b)]) &#123;</span><br><span class="line">                <span class="keyword">if</span>(r-l &gt; i+<span class="number">1</span>-pos[<span class="built_in">mp</span>(a, b)]) &#123;</span><br><span class="line">                    l=pos[<span class="built_in">mp</span>(a, b)];</span><br><span class="line">                    r=i+<span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            pos[<span class="built_in">mp</span>(a, b)]=i+<span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(r==INF) cout &lt;&lt; <span class="number">-1</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">else</span> cout &lt;&lt; l &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; r &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="D-Fight-with-Monsters"><a href="#D-Fight-with-Monsters" class="headerlink" title="D. Fight with Monsters"></a><a href="https://codeforces.com/contest/1296/problem/D">D. Fight with Monsters</a></h1><p>有$n$隻怪物 你和對手共同奮戰(?<br/><br>你的攻擊力是$a$ 對手的攻擊力是$b$<br/><br>第$i$隻怪物的血量是$h_i$<br/><br>每回合的發展如下:</p>
<ol>
<li>你總是先攻 打完後換對手</li>
<li>要是某個人的攻擊使怪物的血量變為$0$以下 他就拿一分</li>
<li>你可以用小手段使對手略過他那次攻擊(也就是你打兩次)</li>
</ol>
<p>小手段最多只能用$k$次</p>
<hr>
<p>模擬就好<br>先計算$a+b$ 只要 $0&lt;$怪物血量$mod(a+b) \le a$ 那你就拿一分<br/><br>如果$=0$ or $&gt;a$ 那你就用$\lceil \frac{a}{b}\rceil$次小手段 還是拿一分<br/><br>如果小手段數量不足 對手拿分<br>複雜度$O(n)$</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">--------------              |   /</span></span><br><span class="line"><span class="comment">      |                     |  /</span></span><br><span class="line"><span class="comment">      |                     | /</span></span><br><span class="line"><span class="comment">      |             *       |/          |    |         ------            *</span></span><br><span class="line"><span class="comment">      |                     |           |    |        /      \</span></span><br><span class="line"><span class="comment">      |             |       |\          |    |       |       |\          |</span></span><br><span class="line"><span class="comment">   \  |             |       | \         |    |       |       | \         |</span></span><br><span class="line"><span class="comment">    \ |             |       |  \        |    |        \     /   \        |</span></span><br><span class="line"><span class="comment">     V              |       |   \        \__/|         -----     \       |</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EmiliaMyWife ios::sync_with_stdio(0); cin.tie(NULL);</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> endl <span class="meta-string">&#x27;\n&#x27;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mem(i,j) memset(i,j,sizeof i);</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> F first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> S second</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mp make_pair</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> all(a) a.begin(), a.end()</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> bit(s,i) (((s)&gt;&gt;(i))&amp;1LL)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lowbit(x) (x&amp;-x)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> siz(v) (long long)v.size()</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int64_t</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">uint64_t</span> ull;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; pii;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;ll, ll&gt; pll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> EPS  = <span class="number">1e-8</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF     = <span class="number">0x3F3F3F3F</span>;</span><br><span class="line"><span class="keyword">const</span> ll LINF     = <span class="number">4611686018427387903</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MOD     = <span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN    = <span class="number">2e5</span>+<span class="number">9</span>;</span><br><span class="line"><span class="comment">/*-----------------------------------------------------------------------------------------------------*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    EmiliaMyWife</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> n, a, b, k;</span><br><span class="line">    ll ans=<span class="number">0</span>;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; a &gt;&gt; b &gt;&gt; k;</span><br><span class="line">    multiset&lt;<span class="keyword">int</span>&gt; nd;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>, s; i &lt; n; i++) &#123;</span><br><span class="line">        cin &gt;&gt; s;</span><br><span class="line">        s%=(a+b);</span><br><span class="line">        <span class="keyword">if</span>(s&lt;=a &amp;&amp; s) &#123;</span><br><span class="line">            ans++;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(s==<span class="number">0</span>) s+=(a+b);</span><br><span class="line">        s-=a;</span><br><span class="line">        nd.<span class="built_in">insert</span>(<span class="built_in">ceil</span>((<span class="keyword">double</span>)s/a));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> a: nd) &#123;</span><br><span class="line">        <span class="keyword">if</span>(a&gt;k) <span class="keyword">break</span>;</span><br><span class="line">        k-=a;</span><br><span class="line">        ans++;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="E-String-Coloring"><a href="#E-String-Coloring" class="headerlink" title="E. String Coloring"></a><a href="https://codeforces.com/contest/1296/problem/E1">E. String Coloring</a></h1><p>將各個字元塗色<br>使得不一樣顏色的字元就能交換<br>並且bubble sort<br>問<br>EV:能否用兩個顏色就滿足條件<br>HV:用最小的顏色數量滿足條件</p>
<hr>
<p>這題我賽中沒寫出來 可撥<br>只要$a_i\le a_j$且$i&lt;j$就不用交換他們<br/><br>所以只要維護$x$個非嚴格遞增數列就好<br/><br>這部分由於字元最多只有26種 也就是$x\le 26$ 直接跑一遍就可<br/><br>然後就塗色<br>EV的話只要看$x$是否大於2<br/><br>複雜度$O(n\times (26))$<br/><br>由於ans陣列會是遞減的 所以其實可以二分搜 複雜度是$O(n\log(26))$ 不過我不是很懂這樣能幹嘛</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">--------------              |   /</span></span><br><span class="line"><span class="comment">      |                     |  /</span></span><br><span class="line"><span class="comment">      |                     | /</span></span><br><span class="line"><span class="comment">      |             *       |/          |    |         ------            *</span></span><br><span class="line"><span class="comment">      |                     |           |    |        /      \</span></span><br><span class="line"><span class="comment">      |             |       |\          |    |       |       |\          |</span></span><br><span class="line"><span class="comment">   \  |             |       | \         |    |       |       | \         |</span></span><br><span class="line"><span class="comment">    \ |             |       |  \        |    |        \     /   \        |</span></span><br><span class="line"><span class="comment">     V              |       |   \        \__/|         -----     \       |</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EmiliaMyWife ios::sync_with_stdio(0); cin.tie(NULL);</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> endl <span class="meta-string">&#x27;\n&#x27;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mem(i,j) memset(i,j,sizeof i);</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> F first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> S second</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mp make_pair</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> all(a) a.begin(), a.end()</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> bit(s,i) (((s)&gt;&gt;(i))&amp;1LL)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lowbit(x) (x&amp;-x)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> siz(v) (long long)v.size()</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; pii;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ull;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;ll, ll&gt; pll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> EPS  = <span class="number">1e-8</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF     = <span class="number">0x3F3F3F3F</span>;</span><br><span class="line"><span class="keyword">const</span> ll LINF     = <span class="number">4611686018427387903</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MOD     = <span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN    = <span class="number">2e5</span>+<span class="number">9</span>;</span><br><span class="line"><span class="comment">/*-----------------------------------------------------------------------------------------------------*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    EmiliaMyWife</span><br><span class="line"></span><br><span class="line">    string s; <span class="keyword">int</span> n;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; s;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; ans, <span class="built_in">color</span>(n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(ans.<span class="built_in">empty</span>()) ans.<span class="built_in">pb</span>(s[i]), color[i]=ans.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">bool</span> ok = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; ans.<span class="built_in">size</span>(); j++) &#123;</span><br><span class="line">                <span class="keyword">if</span>(ans[j]&lt;=s[i]) &#123;</span><br><span class="line">                    ans[j]=s[i];</span><br><span class="line">                    color[i]=j;</span><br><span class="line">                    ok=<span class="literal">false</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(ok) &#123;</span><br><span class="line">                ans.<span class="built_in">pb</span>(s[i]);</span><br><span class="line">                color[i]=ans.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; ans.<span class="built_in">size</span>() &lt;&lt;endl;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> a: color) cout &lt;&lt; a+<span class="number">1</span> &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="F-Berland-Beauty"><a href="#F-Berland-Beauty" class="headerlink" title="F. Berland Beauty"></a><a href="https://codeforces.com/contest/1296/problem/F">F. Berland Beauty</a></h1><p>給一棵樹 每個邊有權重<br>並且會給定$m$筆<br/><br>每筆會給出$a_j$到$b_j$中經過的邊的權重最小值&lt;<br>求根據題目給定順序輸出滿足的邊權重<br>可能無解</p>
<hr>
<p>這題我覺得比pE水QQ<br>只要離線處理<br>先從最大的最小值開始填<br>只要這個邊沒被填過或者是個邊要被填的數字跟他已經被填過的數字一樣 就填上去<br>如果發現已經沒有邊可以填了 就無解<br>要根據題目給定順序輸出 所以每個邊要編號<br>複雜度$O(n^2)$</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">--------------              |   /</span></span><br><span class="line"><span class="comment">      |                     |  /</span></span><br><span class="line"><span class="comment">      |                     | /</span></span><br><span class="line"><span class="comment">      |             *       |/          |    |         ------            *</span></span><br><span class="line"><span class="comment">      |                     |           |    |        /      \</span></span><br><span class="line"><span class="comment">      |             |       |\          |    |       |       |\          |</span></span><br><span class="line"><span class="comment">   \  |             |       | \         |    |       |       | \         |</span></span><br><span class="line"><span class="comment">    \ |             |       |  \        |    |        \     /   \        |</span></span><br><span class="line"><span class="comment">     V              |       |   \        \__/|         -----     \       |</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EmiliaMyWife ios::sync_with_stdio(0); cin.tie(NULL);</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> endl <span class="meta-string">&#x27;\n&#x27;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mem(i,j) memset(i,j,sizeof i);</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> F first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> S second</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mp make_pair</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> all(a) a.begin(), a.end()</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> bit(s,i) (((s)&gt;&gt;(i))&amp;1LL)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lowbit(x) (x&amp;-x)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> siz(v) (long long)v.size()</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; pii;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ull;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;ll, ll&gt; pll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> EPS  = <span class="number">1e-8</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF     = <span class="number">0x3F3F3F3F</span>;</span><br><span class="line"><span class="keyword">const</span> ll LINF     = <span class="number">4611686018427387903</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MOD     = <span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN    = <span class="number">2e5</span>+<span class="number">9</span>;</span><br><span class="line"><span class="comment">/*-----------------------------------------------------------------------------------------------------*/</span></span><br><span class="line"></span><br><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">ans</span><span class="params">(<span class="number">6000</span>, <span class="number">1e7</span>)</span></span>;</span><br><span class="line">vector&lt;vector&lt;pii&gt;&gt; <span class="built_in">edge</span>(<span class="number">6000</span>);</span><br><span class="line">bitset&lt;6000&gt; visited;</span><br><span class="line"><span class="keyword">bool</span> valid;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> now, <span class="keyword">int</span> end, <span class="keyword">int</span> cur)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(visited[now]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    visited[now]=<span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span>(now==end) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> ok = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span>(pii a: edge[now]) &#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">dfs</span>(a.F, end, cur)) &#123;</span><br><span class="line">            <span class="keyword">if</span>(ans[a.S] &gt; <span class="number">1e6</span> || ans[a.S]==cur) ans[a.S]=cur, valid=<span class="literal">true</span>;</span><br><span class="line">            ok=<span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ok;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    EmiliaMyWife</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> n, m;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="function">vector&lt;pii&gt; <span class="title">out</span><span class="params">(n<span class="number">-1</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>, a, b; i &lt;n<span class="number">-1</span>; i++) &#123;</span><br><span class="line">        cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line">        edge[a].<span class="built_in">pb</span>(<span class="built_in">mp</span>(b, i));</span><br><span class="line">        edge[b].<span class="built_in">pb</span>(<span class="built_in">mp</span>(a, i));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cin &gt;&gt;m;</span><br><span class="line">    vector&lt;pair&lt;<span class="keyword">int</span>, pii&gt;&gt; <span class="built_in">arr</span>(m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">        cin &gt;&gt; arr[i].S.F &gt;&gt; arr[i].S.S &gt;&gt; arr[i].F;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(<span class="built_in">all</span>(arr)); <span class="built_in">reverse</span>(<span class="built_in">all</span>(arr));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> valids = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">        valid=<span class="literal">false</span>;</span><br><span class="line">        visited.<span class="built_in">reset</span>();</span><br><span class="line">        <span class="built_in">dfs</span>(arr[i].S.F, arr[i].S.S, arr[i].F);</span><br><span class="line">        valids&amp;=valid;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(valids)</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n<span class="number">-1</span>; i++) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="built_in">min</span>(ans[i], <span class="number">1000000</span>) &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> cout &lt;&lt; <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>Competitive Programming</tag>
        <tag>Codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title>TIOJ-1225</title>
    <url>/TIOJ-1225/</url>
    <content><![CDATA[<p>黑板上有n個數字寫成一排，現在每次選擇兩個相鄰的數字，把比較小的那個數字擦掉(如果兩個數字一樣大，那麼擦掉任何一個都可以。)然而，這些步驟需要花費，這個花費恰好等於留下來的那個數字(比較大的那個)。<br>請問經過n-1次操作，黑板上會剩下的那個數字是多少？</p>
<span id="more"></span>
<p>你以為問題這麼簡單嗎？<strong>錯</strong>!<br>真正的問題是：<br>請問經過n-1次操作，黑板上會剩下最大的那個數字，所有操作方法中，最小總花費是多少？<br>$1\leq n\leq 1,000,000$</p>
<hr>
<p>如果花費要小 在每次砍數字的時候比較大的那個數字要比較小<br>換個角度就是在砍掉某個數字時我們要選擇他左右兩邊比較小的那個數字<br>然後就Linked List就好了<br>不過我好懶得寫指標型 所以就<del>陣列開下去</del><br>複雜度$\mathcal{O}(NlogN)$</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int64_t</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF     = <span class="number">0x3F3F3F3F</span>;</span><br><span class="line"><span class="comment">/*-----------------------------------------------------------------------------------------------------*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int ll</span></span><br><span class="line"><span class="keyword">int</span> prv[<span class="number">1000000</span>], nxt[<span class="number">1000000</span>], num[<span class="number">1000000</span>];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">CMP</span> &#123;</span></span><br><span class="line">	<span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span> <span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> (num[a]&gt;num[b]);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>); cin.<span class="built_in">tie</span>(<span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> n;</span><br><span class="line">	ll ans = <span class="number">0</span>;</span><br><span class="line">	cin &gt;&gt; n;</span><br><span class="line">	priority_queue&lt;<span class="keyword">int</span>, vector&lt;<span class="keyword">int</span>&gt;, CMP&gt; pq;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) cin &gt;&gt; num[i];</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) prv[i]=i<span class="number">-1</span>, nxt[i]=i+<span class="number">1</span>, pq.<span class="built_in">push</span>(i);</span><br><span class="line">	prv[<span class="number">0</span>]=nxt[n<span class="number">-1</span>]=<span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">while</span>(pq.<span class="built_in">size</span>()&gt;<span class="number">1</span>) &#123;</span><br><span class="line">		<span class="keyword">int</span> now=pq.<span class="built_in">top</span>();</span><br><span class="line">		pq.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">		<span class="keyword">int</span> a, b;</span><br><span class="line">		<span class="keyword">if</span>(prv[now]==<span class="number">-1</span>) a=INF;</span><br><span class="line">		<span class="keyword">else</span> a=num[prv[now]];</span><br><span class="line">		<span class="keyword">if</span>(nxt[now]==<span class="number">-1</span>) b=INF;</span><br><span class="line">		<span class="keyword">else</span> b=num[nxt[now]];</span><br><span class="line">		ans+=<span class="built_in">min</span>(a, b);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">int</span> pr=prv[now], nx=nxt[now];</span><br><span class="line">		<span class="keyword">if</span>(nx!=<span class="number">-1</span>) prv[nx]=pr;</span><br><span class="line">		<span class="keyword">if</span>(pr!=<span class="number">-1</span>) nxt[pr]=nx;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; ans;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>Competitive Programming</tag>
        <tag>TIOJ</tag>
      </tags>
  </entry>
  <entry>
    <title>TIOJ-1500</title>
    <url>/TIOJ-1500/</url>
    <content><![CDATA[<p>It’s perfectly normal, nothing wrong with me<br>But we’re going to need a clean up on aisle 3<br>And now I’m posed in an awkward stance because I<br>據說有位顧客，因為超商的動線設計不良，不小心把東西翻倒在褲子上，使得他要去第三排走廊清理一下。之後超商在檢討為什麼會發生這種事情，他們發現若有兩兩障礙物離太近就會有奇怪的顧客，故意從兩障礙的夾縫中走過去，就會發生意外。<br>你就是那位奇怪的顧客，你想知道兩障礙物最近的距離是多少。好穿越最近的夾縫獲得成就感。</p>
<span id="more"></span>
<p>$N&lt;50000$</p>
<hr>
<p>刷講義D&amp;C部分刷到的<br>一開始還以為跟逆序數對一樣能砸資結解決 不過我想不到&gt;&lt;<br>先根據$x$座標排序 分割問題當只有兩點時可以直接更新答案<br/><br>其餘的合併就是找左半邊最右邊的點的$x$的左右$ans$範圍內的點<br/><br>然後因為每點之間的距離肯定$\geq ans$ 因此只要找最多三個點就好了<br/><br>複雜度 $O(nlog^2n)$</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">--------------              |   /</span></span><br><span class="line"><span class="comment">      |                     |  /</span></span><br><span class="line"><span class="comment">      |                     | /</span></span><br><span class="line"><span class="comment">      |             *       |/          |    |         ------            *</span></span><br><span class="line"><span class="comment">      |                     |           |    |        /      \</span></span><br><span class="line"><span class="comment">      |             |       |\          |    |       |       |\          |</span></span><br><span class="line"><span class="comment">   \  |             |       | \         |    |       |       | \         |</span></span><br><span class="line"><span class="comment">    \ |             |       |  \        |    |        \     /   \        |</span></span><br><span class="line"><span class="comment">     V              |       |   \        \__/|         -----     \       |</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EmiliaMyWife ios::sync_with_stdio(0); cin.tie(NULL);</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> F first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> S second</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> all(a) (a).begin(), (a).end()</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int64_t</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;ll, ll&gt; pll;</span><br><span class="line"><span class="keyword">const</span> ll LINF     = <span class="number">4611686018427387903</span>;</span><br><span class="line"><span class="comment">/*-----------------------------------------------------------------------------------------------------*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">double</span> ans;</span><br><span class="line">vector&lt;pll&gt; arr;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(pll a, pll b)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> (a.S&lt;b.S);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">getD</span><span class="params">(pll a, pll b)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">sqrt</span>(<span class="built_in"><span class="keyword">double</span></span>(a.F-b.F)*(a.F-b.F)+<span class="built_in"><span class="keyword">double</span></span>(a.S-b.S)*(a.S-b.S));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getAns</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(l&gt;=r) <span class="keyword">return</span>;</span><br><span class="line">	<span class="keyword">if</span>(l==r<span class="number">-1</span>) &#123;</span><br><span class="line">		ans=<span class="built_in">min</span>(ans, <span class="built_in">getD</span>(arr[l], arr[r]));</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> m = (l+r)/<span class="number">2</span>;</span><br><span class="line">	<span class="built_in">getAns</span>(l, m);</span><br><span class="line">	<span class="built_in">getAns</span>(m+<span class="number">1</span>, r);</span><br><span class="line">	vector&lt;pll&gt; aw, bw;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = m; i&gt;=l; i--) &#123;</span><br><span class="line">		<span class="keyword">if</span>(arr[m].F-arr[i].F &gt; ans) <span class="keyword">break</span>;</span><br><span class="line">		aw.<span class="built_in">pb</span>(arr[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = m+<span class="number">1</span>; i&lt;=r; i++) &#123;</span><br><span class="line">		<span class="keyword">if</span>(arr[i].F-arr[m].F&gt;ans) <span class="keyword">break</span>;</span><br><span class="line">		bw.<span class="built_in">pb</span>(arr[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">sort</span>(<span class="built_in">all</span>(aw), cmp);</span><br><span class="line">	<span class="built_in">sort</span>(<span class="built_in">all</span>(bw), cmp);</span><br><span class="line">	<span class="keyword">int</span> b=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span>(bw.<span class="built_in">empty</span>()) <span class="keyword">return</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; aw.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">		<span class="keyword">while</span>(b+<span class="number">1</span>&lt;bw.<span class="built_in">size</span>() &amp;&amp; bw[b].S&lt;aw[i].S) b++;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> x = <span class="built_in">max</span>(<span class="number">0</span>, b<span class="number">-2</span>); x &lt;= b; x++) ans=<span class="built_in">min</span>(ans, <span class="built_in">getD</span>(aw[i], bw[x]));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	EmiliaMyWife</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; fixed &lt;&lt; <span class="built_in">setprecision</span>(<span class="number">6</span>);</span><br><span class="line">	<span class="keyword">int</span> n;</span><br><span class="line">	<span class="keyword">while</span>(cin &gt;&gt; n) &#123;</span><br><span class="line">		arr.<span class="built_in">clear</span>();</span><br><span class="line">		arr.<span class="built_in">resize</span>(n);</span><br><span class="line">		ans=LINF;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) cin &gt;&gt; arr[i].F &gt;&gt; arr[i].S;</span><br><span class="line">		<span class="built_in">sort</span>(<span class="built_in">all</span>(arr));</span><br><span class="line">		<span class="built_in">getAns</span>(<span class="number">0</span>, n<span class="number">-1</span>);</span><br><span class="line">		cout &lt;&lt; ans &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>Competitive Programming</tag>
        <tag>TIOJ</tag>
      </tags>
  </entry>
  <entry>
    <title>TIOJ-1208</title>
    <url>/TIOJ-1208/</url>
    <content><![CDATA[<p>給你一個數列S，一個該數列的連續和(Continuous Sum,以下簡稱CS)是指S當中的某些連續項之總和。<br>很容易算得出來，一個總長度為項的數列S，其連續和(CS)共有$\frac{n(n+1)}{2}$個。 注意，問題來囉！<br/><br>請問，這$\frac{n(n+1)}{2}$個連續和(CS)之中，第k大的是多少？</p>
<span id="more"></span>
<p>$n\leq 20000, |a_i|\leq 10000$</p>
<hr>
<p>二分搜+merge sort<br>複雜度 $O(nlognlogC), C=20000\times 10000\times 2$<br/><br>結果卻狂吃TLE 花了3個小時debug 丟了27筆submission<br>問了幾個電神 其中一個叫我注意二分搜<br>我原本範圍設<br><code>l=-200000025, r=200000025</code><br>改成沒負數之後<br>他過了<br><strong>他過了</strong><br><em><strong>他過了</strong></em><br>我好可撥</p>
<blockquote>
<p>後來才想到 當$l=-1,\ r=0$時 $r=m$會無法更新 以後隨時提醒自己二分搜有負數時要特別小心@@</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; tmp;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">num</span><span class="params">(<span class="keyword">int</span> ans, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(l&gt;=r) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> m = (l+r)/<span class="number">2</span>;</span><br><span class="line">	<span class="keyword">int</span> cnt = <span class="built_in">num</span>(ans, l, m)+<span class="built_in">num</span>(ans, m+<span class="number">1</span>, r);</span><br><span class="line">	<span class="keyword">int</span> it = l;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = m+<span class="number">1</span>; i &lt;= r; i++) &#123;</span><br><span class="line">		<span class="keyword">while</span>(it&lt;=m &amp;&amp; tmp[i]-tmp[it]&gt;ans) &#123;</span><br><span class="line">			it++;</span><br><span class="line">		&#125;</span><br><span class="line">		cnt+=(m+<span class="number">1</span>)-it;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	vector&lt;<span class="keyword">int</span>&gt; www;</span><br><span class="line">	<span class="keyword">int</span> a=l, b=m+<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; r-l+<span class="number">1</span>; i++) &#123;</span><br><span class="line">		<span class="keyword">if</span>(a&gt;m || (b&lt;=r &amp;&amp;tmp[b]&lt;tmp[a])) &#123;</span><br><span class="line">			www.<span class="built_in">push_back</span>(tmp[b]);</span><br><span class="line">			b++;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			www.<span class="built_in">push_back</span>(tmp[a]);</span><br><span class="line">			a++;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; r-l+<span class="number">1</span>; i++) tmp[l+i]=www[i];</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> cnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>); cin.<span class="built_in">tie</span>(<span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> n, k;</span><br><span class="line">	<span class="keyword">while</span>(cin &gt;&gt; n &gt;&gt; k) &#123;</span><br><span class="line">		<span class="keyword">if</span>(!n) <span class="keyword">break</span>;</span><br><span class="line">		<span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">sum</span><span class="params">(n+<span class="number">1</span>)</span></span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">			cin &gt;&gt; sum[i];</span><br><span class="line">			sum[i]+=sum[i<span class="number">-1</span>];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">int</span> l = <span class="number">0</span>, r=<span class="number">400000050</span>;</span><br><span class="line">		<span class="keyword">int</span> rk = ((n+<span class="number">1</span>)*n)/<span class="number">2</span>-k+<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">while</span>(l&lt;r) &#123;</span><br><span class="line">			tmp=sum;</span><br><span class="line">			<span class="keyword">int</span> m = (l+r)/<span class="number">2</span>;</span><br><span class="line">			<span class="keyword">int</span> cnt = <span class="built_in">num</span>(m<span class="number">-200000025</span>, <span class="number">0</span>, n);</span><br><span class="line">			<span class="keyword">if</span>(cnt &lt; rk) l=m+<span class="number">1</span>;</span><br><span class="line">			<span class="keyword">else</span> r=m;</span><br><span class="line">		&#125;</span><br><span class="line">		cout &lt;&lt; l<span class="number">-200000025</span> &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>Competitive Programming</tag>
        <tag>TIOJ</tag>
      </tags>
  </entry>
  <entry>
    <title>CF-1326D</title>
    <url>/CF-1326D/</url>
    <content><![CDATA[<p>You are given a string $s$, consisting of lowercase English letters. Find the longest string, $t$, which satisfies the following conditions:</p>
<ul>
<li>The length of $t$ does not exceed the length of $s$.</li>
<li>$t$ is a palindrome.</li>
<li>There exists two strings $a$ and $b$ (possibly empty), such that $t=a+b$ ( “$+$” represents concatenation), and $a$ is prefix of $s$ while $b$ is suffix of $s$.<span id="more"></span></li>
</ul>
<p>Easy Version: $|s|\leq 5000$<br/><br>Hard Version: $|s|\leq 10^6$ </p>
<hr>
<p>把左右一樣的砍掉，他們肯定回文<br>中間的看要取左或取右，並且也要是回文<br>學完manacher’s algorithm後把他砸在這題&gt;&lt;<br>複雜度$\mathcal{O}(n)$</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	string s;</span><br><span class="line">	cin &gt;&gt; s;</span><br><span class="line">	<span class="keyword">int</span> n = s.<span class="built_in">size</span>();</span><br><span class="line">	<span class="keyword">int</span> border = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>(border&lt;n-border<span class="number">-1</span> &amp;&amp; s[border]==s[n-border<span class="number">-1</span>]) border++;</span><br><span class="line">	string a = <span class="string">&quot;#&quot;</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = border; i &lt; n-border; i++) &#123;</span><br><span class="line">		a.<span class="built_in">push_back</span>(s[i]);</span><br><span class="line">		a.<span class="built_in">push_back</span>(<span class="string">&#x27;#&#x27;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> l = <span class="number">0</span>, r = <span class="number">-1</span>, x, y=<span class="number">-1</span>;</span><br><span class="line">	<span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">arr</span><span class="params">(a.size())</span></span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; a.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">		arr[i]= i&lt;=r?<span class="built_in">min</span>(arr[<span class="number">2</span>*l-i], r-i):<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">while</span>(~(i-arr[i]) &amp;&amp; i+arr[i]&lt;a.<span class="built_in">size</span>() &amp;&amp; a[i+arr[i]]==a[i-arr[i]]) arr[i]++;</span><br><span class="line">		<span class="keyword">if</span>(i+arr[i]<span class="number">-1</span> &gt; r) r=i+arr[i]<span class="number">-1</span>, l=i;</span><br><span class="line">		<span class="keyword">if</span>(arr[i]<span class="number">-1</span>==i) x=i;</span><br><span class="line">		<span class="keyword">if</span>(arr[i]+i==a.<span class="built_in">size</span>() &amp;&amp; y&lt;<span class="number">0</span>) y=i;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(arr[x]&gt;arr[y]) &#123;</span><br><span class="line">		cout &lt;&lt; s.<span class="built_in">substr</span>(<span class="number">0</span>, border) &lt;&lt; s.<span class="built_in">substr</span>(border, arr[x]<span class="number">-1</span>) &lt;&lt; s.<span class="built_in">substr</span>(n-border, border);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		cout &lt;&lt; s.<span class="built_in">substr</span>(<span class="number">0</span>, border) &lt;&lt; s.<span class="built_in">substr</span>(n-border-arr[y]+<span class="number">1</span>, arr[y]<span class="number">-1</span>) &lt;&lt; s.<span class="built_in">substr</span>(n-border, border);</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>); cin.<span class="built_in">tie</span>(<span class="literal">NULL</span>);</span><br><span class="line"> </span><br><span class="line">	<span class="keyword">int</span> t;</span><br><span class="line">	cin &gt;&gt; t;</span><br><span class="line">	<span class="keyword">while</span>(t--) <span class="built_in">solve</span>();</span><br><span class="line"> </span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>Competitive Programming</tag>
        <tag>Codeforces</tag>
        <tag>string</tag>
        <tag>manacher</tag>
      </tags>
  </entry>
  <entry>
    <title>TIOJ-1535</title>
    <url>/TIOJ-1535/</url>
    <content><![CDATA[<p>相信大家都對質數這種特殊的正整數不陌生: 一個大於1的自然數中，除了1和此整數自身外，沒辦法被其他自然數整除的數；<br>即只有兩個正因數（1和自己）的自然數，就是質數。<br>如果一個質數在將其<strong>所有位數顛倒(reverse)<strong>後仍是一個質數，那麼我們就稱這個數是「</strong>Emirp</strong>」(中文譯作「反質數」)，</p>
<span id="more"></span>
<p>而這個名字的由來也很容易能理解。(Emirp 正是質數的英文 Prime 反過來書寫的結果)<br>※舉例來說:<br>17 是質數，而將其每位數反轉後我們得到 71 ，而 71 恰好也是質數。因此，17 是一個 Emirp。<br>同理，71 也必然是 Emirp 。<br>--<br>現在，請你寫一個程式，找出由小到大數來第 n 個 Emirp 是哪個數。<br>(注意 : 在這個問題中，3, 5, 7, 11, 191 這類「<strong>迴文質數</strong>」由於反轉前後的結果一樣，因此我們不將其視為 Emirp。)<br>$$1\leq N\leq 100,000$$<br><img src="1535_1.jpg"></p>
<hr>
<p>本機爆搜後發現第10000個Emirp是11293973，直接蓋表，為了rever方便所以就蓋到1e8<br>原本想說這複雜度蠻可怕的，且本機的確跑了好幾秒，不過丟到OJ上是好的<br>…<del>難道我該換電腦了嗎</del><br>用$O(n)$篩不知道為什麼會出事，還沒找到原因<br/><br>$O(nlogn)$卻好好的@@</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">--------------              |   /</span></span><br><span class="line"><span class="comment">      |                     |  /</span></span><br><span class="line"><span class="comment">      |                     | /</span></span><br><span class="line"><span class="comment">      |             *       |/          |    |         ------            *</span></span><br><span class="line"><span class="comment">      |                     |           |    |        /      \</span></span><br><span class="line"><span class="comment">      |             |       |\          |    |       |       |\          |</span></span><br><span class="line"><span class="comment">   \  |             |       | \         |    |       |       | \         |</span></span><br><span class="line"><span class="comment">    \ |             |       |  \        |    |        \     /   \        |</span></span><br><span class="line"><span class="comment">     V              |       |   \        \__/|         -----     \       |</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EmiliaMyWife ios::sync_with_stdio(0); cin.tie(NULL);</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mem(i,j) memset(i,j,sizeof (i));</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> F first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> S second</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mp make_pair</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> all(a) (a).begin(), (a).end()</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lowbit(x) ((x)&amp;(-(x)))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> siz(v) (long long)(v).size()</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int64_t</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">uint64_t</span> ull;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; pii;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;ll, ll&gt; pll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> EPS  = <span class="number">1e-8</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF     = <span class="number">0x3F3F3F3F</span>;</span><br><span class="line"><span class="keyword">const</span> ll LINF     = <span class="number">4611686018427387903</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MOD     = <span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN    = <span class="number">2e5</span>+<span class="number">9</span>;</span><br><span class="line"><span class="comment">/*-----------------------------------------------------------------------------------------------------*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int ll</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">rever</span><span class="params">(<span class="keyword">int</span> a)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> b = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>(a) &#123;</span><br><span class="line">		b*=<span class="number">10</span>;</span><br><span class="line">		b+=a%<span class="number">10</span>;</span><br><span class="line">		a/=<span class="number">10</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100000000</span>;</span><br><span class="line"></span><br><span class="line">bitset&lt;N&gt; isP;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	EmiliaMyWife</span><br><span class="line"></span><br><span class="line">	vector&lt;<span class="keyword">int</span>&gt; p;</span><br><span class="line">	isP[<span class="number">0</span>]=isP[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; N; i++) &#123;</span><br><span class="line">		<span class="keyword">if</span>(isP[i]) <span class="keyword">continue</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j = i*i; j &lt; N; j+=i) isP[j]=<span class="number">1</span>;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	vector&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i&lt;N; i++) &#123;</span><br><span class="line">		<span class="keyword">int</span> k = <span class="built_in">rever</span>(i);</span><br><span class="line">		<span class="keyword">if</span>(k!=i &amp;&amp; !isP[i] &amp;&amp; !isP[k]) ans.<span class="built_in">pb</span>(i);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> t, n;</span><br><span class="line">	cin &gt;&gt; t;</span><br><span class="line">	<span class="keyword">while</span>(t--) &#123;</span><br><span class="line">		cin &gt;&gt; n;</span><br><span class="line">		cout &lt;&lt; ans[n<span class="number">-1</span>] &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>Competitive Programming</tag>
        <tag>TIOJ</tag>
      </tags>
  </entry>
  <entry>
    <title>TIOJ-1157</title>
    <url>/TIOJ-1157/</url>
    <content><![CDATA[<p>1947年美國勞動統計局花了兩年的時間，收集超過250,000經濟資訊。兩年後哈佛大學Wassily Leontief教授將這些經濟活動分析成500產業，其中包括煤業、汽車業、運輸業等。對每一個產業，Leontief教授用一個線性方程式來表達這個產業如何將其產出分散或影響其他的產業。他的研究開啟了日後利用電腦來解決大型數學問題的先例。Leontief教授後來在1973年獲得諾貝爾經濟貢獻奬。<br>由於在科學或經濟上所包含的資料都相當多，有很多數學模式都是線性的，所以線性系統求解可以說是相當重要。有關線性系統的解法可以應用高斯消去法(Gauss-Jordan Elimination) 來求解。<br>(以下略)</p>
<span id="more"></span>

<p>$n&lt;50&lt;b$<br/><br>第一行為0或1或N分別表示無解、1組解、及無限多組解</p>
<hr>
<p>前幾天看了一陣子的高斯消去，數學不好沒辦法&gt;&lt;<br>然後就來寫裸題了<br>輸出分數的部分我不想讓code變太髒於是決定統一用運算子重載<br>複雜度$\mathcal{O}(n^3logn)$($logn$來自約分)</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">long</span> <span class="keyword">long</span>, <span class="keyword">long</span> <span class="keyword">long</span>&gt; pll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> S second</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> F first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mp make_pair</span></span><br><span class="line">pll <span class="keyword">operator</span>-(<span class="keyword">const</span> pll &amp;a, <span class="keyword">const</span> pll &amp;b) &#123;</span><br><span class="line">	ll g = b.S/__gcd(<span class="built_in">abs</span>(a.S), b.S)*a.S;</span><br><span class="line">	ll x = a.F*g/a.S-b.F*g/b.S, y = g;</span><br><span class="line">	g = __gcd(<span class="built_in">abs</span>(x), y);</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">mp</span>(x/g, y/g);</span><br><span class="line">&#125;</span><br><span class="line">pll <span class="keyword">operator</span>*(<span class="keyword">const</span> pll &amp;a, <span class="keyword">const</span> pll &amp;b) &#123;</span><br><span class="line">	ll x = a.F*b.F;</span><br><span class="line">	ll y = a.S*b.S;</span><br><span class="line">	<span class="keyword">if</span>(y &lt; <span class="number">0</span>) y*=<span class="number">-1</span>, x*=<span class="number">-1</span>;</span><br><span class="line">	ll g = __gcd(<span class="built_in">abs</span>(x), y);</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">mp</span>(x/g, y/g);</span><br><span class="line">&#125;</span><br><span class="line">ostream &amp;<span class="keyword">operator</span>&lt;&lt;(ostream &amp;out, <span class="keyword">const</span> pll &amp;a) &#123;</span><br><span class="line">	<span class="keyword">if</span>(a.S == <span class="number">1</span>)</span><br><span class="line">		out &lt;&lt; a.F;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		out &lt;&lt; a.F &lt;&lt; <span class="string">&#x27;/&#x27;</span> &lt;&lt; a.S;</span><br><span class="line">	<span class="keyword">return</span> out;</span><br><span class="line">&#125;</span><br><span class="line">pll <span class="keyword">operator</span>/(<span class="keyword">const</span> pll &amp;a, <span class="keyword">const</span> pll &amp;b) &#123;</span><br><span class="line">	ll x = a.F*b.S;</span><br><span class="line">	ll y = a.S*b.F;</span><br><span class="line">	<span class="keyword">if</span>(y &lt; <span class="number">0</span>) y*=<span class="number">-1</span>, x*=<span class="number">-1</span>;</span><br><span class="line">	ll g = __gcd(<span class="built_in">abs</span>(x), y);</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">mp</span>(x/g, y/g);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>); cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> n;</span><br><span class="line">	cin &gt;&gt; n;</span><br><span class="line">	vector&lt;vector&lt;pll&gt;&gt; <span class="built_in">arr</span>(n, vector&lt;pll&gt;(n+<span class="number">1</span>));</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>, a; j &lt; n+<span class="number">1</span>; j++)</span><br><span class="line">			cin &gt;&gt; a, arr[i][j]=<span class="built_in">mp</span>(a, <span class="number">1</span>);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">		<span class="keyword">bool</span> can = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j = i; j &lt; n; j++) &#123;</span><br><span class="line">			<span class="keyword">if</span>(arr[j][i].F != <span class="number">0</span>) &#123;</span><br><span class="line">				<span class="keyword">if</span>(i!=j)</span><br><span class="line">					<span class="built_in">swap</span>(arr[i], arr[j]);</span><br><span class="line">				can = <span class="number">1</span>;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(!can) &#123;</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">			<span class="keyword">if</span>(i == j)</span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">			<span class="keyword">auto</span> x = arr[j][i]/arr[i][i];</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; n+<span class="number">1</span>; k++)</span><br><span class="line">				arr[j][k] = (arr[j][k]-(arr[i][k]*x));</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">		<span class="keyword">bool</span> can = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++)</span><br><span class="line">			can|=arr[i][j].F;</span><br><span class="line">		<span class="keyword">if</span>(!can) &#123;</span><br><span class="line">			<span class="keyword">if</span>(arr[i][n].F)</span><br><span class="line">				<span class="keyword">return</span> cout &lt;&lt; <span class="string">&#x27;0&#x27;</span>, <span class="number">0</span>;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">				<span class="keyword">return</span> cout &lt;&lt; <span class="string">&#x27;N&#x27;</span>, <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">		<span class="keyword">if</span>(!arr[i][i].F)</span><br><span class="line">			<span class="keyword">return</span> cout &lt;&lt; <span class="string">&#x27;N&#x27;</span>, <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;1\n&quot;</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&#x27;x&#x27;</span> &lt;&lt; i+<span class="number">1</span> &lt;&lt; <span class="string">&quot; = &quot;</span> &lt;&lt; arr[i][n]/arr[i][i] &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>Competitive Programming</tag>
        <tag>TIOJ</tag>
      </tags>
  </entry>
  <entry>
    <title>TIOJ-1178</title>
    <url>/TIOJ-1178/</url>
    <content><![CDATA[<p>給定平面上N個點，請計算出凸包上的頂點數。所謂的凸包，就是指一個包含所有點的最小凸多邊形。<br>所謂凸包上的頂點，指的是轉折處(邊上的點不算)。</p>
<span id="more"></span>
<p>$1\leq N\leq 10,000$<br/><br>點的座標皆在int範圍</p>
<hr>
<p>凸包裸題<br>用Andrew’s Monotone Chain來實作<br>複雜度$\mathcal{O}(NlogN)$</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">cross</span><span class="params">(pair&lt;<span class="keyword">long</span> <span class="keyword">long</span>,<span class="keyword">long</span> <span class="keyword">long</span>&gt; &amp;a, pair&lt;<span class="keyword">long</span> <span class="keyword">long</span>,<span class="keyword">long</span> <span class="keyword">long</span>&gt; &amp;b, pair&lt;<span class="keyword">long</span> <span class="keyword">long</span>,<span class="keyword">long</span> <span class="keyword">long</span>&gt; &amp;c)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> (b.first-a.first) * (c.second - a.second) - (b.second - a.second) * (c.first - a.first);</span><br><span class="line">&#125;<span class="comment">//ab外積ac ab到ac為逆時針旋轉時外積為正 反則負 共線為0</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>); cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> n;</span><br><span class="line">	cin &gt;&gt; n;</span><br><span class="line">	vector&lt;pair&lt;<span class="keyword">long</span> <span class="keyword">long</span>,<span class="keyword">long</span> <span class="keyword">long</span>&gt;&gt; <span class="built_in">arr</span>(n), dn, up;<span class="comment">//點 下凸包 上凸包</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">		cin &gt;&gt; arr[i].first &gt;&gt; arr[i].second;</span><br><span class="line">	<span class="built_in">sort</span>(arr.<span class="built_in">begin</span>(), arr.<span class="built_in">end</span>());<span class="comment">//照座標排序</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">		<span class="keyword">while</span>(dn.<span class="built_in">size</span>() &gt;= <span class="number">2</span> &amp;&amp; <span class="built_in">cross</span>(dn[dn.<span class="built_in">size</span>()<span class="number">-2</span>], dn.<span class="built_in">back</span>(), arr[i]) &lt;= <span class="number">0</span>)</span><br><span class="line">			dn.<span class="built_in">pop_back</span>();</span><br><span class="line">		<span class="keyword">while</span>(up.<span class="built_in">size</span>() &gt;= <span class="number">2</span> &amp;&amp; <span class="built_in">cross</span>(up[up.<span class="built_in">size</span>()<span class="number">-2</span>], up.<span class="built_in">back</span>(), arr[i]) &gt;= <span class="number">0</span>)</span><br><span class="line">			up.<span class="built_in">pop_back</span>();</span><br><span class="line">		dn.<span class="built_in">push_back</span>(arr[i]);</span><br><span class="line">		up.<span class="built_in">push_back</span>(arr[i]);</span><br><span class="line">	&#125;<span class="comment">//單調隊列</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="built_in"><span class="keyword">int</span></span>(up.<span class="built_in">size</span>())<span class="number">-2</span>; i &gt; <span class="number">0</span>; i--)</span><br><span class="line">		dn.<span class="built_in">push_back</span>(up[i]);</span><br><span class="line">	<span class="comment">//把上凸包的中間元素以反方向push進下凸包(前後兩點為起終點 重複)</span></span><br><span class="line">	cout &lt;&lt; dn.<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>Competitive Programming</tag>
        <tag>TIOJ</tag>
      </tags>
  </entry>
  <entry>
    <title>TIOJ-1861</title>
    <url>/TIOJ-1861/</url>
    <content><![CDATA[<h1 id="description"><a href="#description" class="headerlink" title="description"></a>description</h1><p>給定一長度$n$的序列序列$a$<br/><br>將一塊大小為$\sum a_i$的人(?)切成$n$份，對應到$a$<br/><br>將一塊$x$大小切成$a,b$需要成本$x$<br/><br>求最佳化切法的最小成本</p>
<span id="more"></span>
<p>$n\leq 10^5$<br/><br>$a_i\leq 10^4$</p>
<hr>
<h1 id="solution"><a href="#solution" class="headerlink" title="solution"></a>solution</h1><p>把問題反過來想，可以發現等價於將$n$個數字合併，成本為合併後數字<br/><br>要讓它最小，可以greedy地每次都將當前兩個最小的合併</p>
<h2 id="sol-1"><a href="#sol-1" class="headerlink" title="sol.1"></a>sol.1</h2><p>利用heap維護當前最小<br>將所有數字都丟進去，每次取最小的兩個出來合併後丟回去<br>複雜度$\mathcal{O}(nlogn)$</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">--------------              |   /</span></span><br><span class="line"><span class="comment">      |                     |  /</span></span><br><span class="line"><span class="comment">      |                     | /</span></span><br><span class="line"><span class="comment">      |             *       |/          |    |         ------            *</span></span><br><span class="line"><span class="comment">      |                     |           |    |        /      \</span></span><br><span class="line"><span class="comment">      |             |       |\          |    |       |       |\          |</span></span><br><span class="line"><span class="comment">   \  |             |       | \         |    |       |       | \         |</span></span><br><span class="line"><span class="comment">    \ |             |       |  \        |    |        \     /   \        |</span></span><br><span class="line"><span class="comment">     V              |       |   \        \__/|         -----     \       |</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EmiliaMyWife ios::sync_with_stdio(0); cin.tie(NULL);</span></span><br><span class="line"><span class="comment">/*-----------------------------------------------------------------------------------------------------*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	EmiliaMyWife</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> n;</span><br><span class="line">	<span class="keyword">while</span>(cin &gt;&gt; n) &#123;</span><br><span class="line">		priority_queue&lt;<span class="keyword">int</span>, vector&lt;<span class="keyword">int</span>&gt;, greater&lt;<span class="keyword">int</span>&gt;&gt; pq;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>, a; i &lt; n; i++)</span><br><span class="line">			cin &gt;&gt; a, pq.<span class="built_in">push</span>(a);</span><br><span class="line">		ll ans = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n<span class="number">-1</span>; i++) &#123;</span><br><span class="line">			<span class="keyword">int</span> a = pq.<span class="built_in">top</span>(); pq.<span class="built_in">pop</span>();</span><br><span class="line">			<span class="keyword">int</span> b = pq.<span class="built_in">top</span>(); pq.<span class="built_in">pop</span>();</span><br><span class="line">			ans += a+b;</span><br><span class="line">			pq.<span class="built_in">push</span>(a+b);</span><br><span class="line">		&#125;</span><br><span class="line">		cout &lt;&lt; ans &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="sol-2"><a href="#sol-2" class="headerlink" title="sol.2"></a>sol.2</h2><p>可以發現到，每次合併後丟回去的數字都會成單調遞增，因此根本不用使用heap<br>只要用個queue把它們存起來就好，每次就取(排序後原數列前兩個和queue前兩個)四個中最小的兩個出來就好<br>複雜度 $\mathcal{O}(n+nlogn)$&lt;br/<br>如果把排序改成radix 複雜度$\mathcal{O}(n)$</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">--------------              |   /</span></span><br><span class="line"><span class="comment">      |                     |  /</span></span><br><span class="line"><span class="comment">      |                     | /</span></span><br><span class="line"><span class="comment">      |             *       |/          |    |         ------            *</span></span><br><span class="line"><span class="comment">      |                     |           |    |        /      \</span></span><br><span class="line"><span class="comment">      |             |       |\          |    |       |       |\          |</span></span><br><span class="line"><span class="comment">   \  |             |       | \         |    |       |       | \         |</span></span><br><span class="line"><span class="comment">    \ |             |       |  \        |    |        \     /   \        |</span></span><br><span class="line"><span class="comment">     V              |       |   \        \__/|         -----     \       |</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EmiliaMyWife ios::sync_with_stdio(0); cin.tie(NULL);</span></span><br><span class="line"><span class="comment">/*-----------------------------------------------------------------------------------------------------*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">radix_sort</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt; &amp;arr)</span> </span>&#123;</span><br><span class="line">	vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">digs</span>(<span class="number">10</span>);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>, cur = <span class="number">1</span>; i &lt; <span class="number">5</span>; i++, cur*=<span class="number">10</span>) &#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; arr.<span class="built_in">size</span>(); j++) &#123;</span><br><span class="line">			digs[arr[j] / cur % <span class="number">10</span>].<span class="built_in">push_back</span>(arr[j]);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>, it = <span class="number">0</span>; j &lt; <span class="number">10</span>; j++) &#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> &amp;a: digs[j])</span><br><span class="line">				arr[it++] = a;</span><br><span class="line">			digs[j].<span class="built_in">clear</span>();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">queue&lt;<span class="keyword">int</span>&gt; old;</span><br><span class="line">queue&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt; nw;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">getn</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">long</span> <span class="keyword">long</span> tmp;</span><br><span class="line">	<span class="keyword">if</span>(nw.<span class="built_in">empty</span>() || (old.<span class="built_in">size</span>() &amp;&amp; old.<span class="built_in">front</span>() &lt; nw.<span class="built_in">front</span>()))</span><br><span class="line">		tmp = old.<span class="built_in">front</span>(), old.<span class="built_in">pop</span>();</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		tmp = nw.<span class="built_in">front</span>(), nw.<span class="built_in">pop</span>();</span><br><span class="line">	<span class="keyword">return</span> tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	EmiliaMyWife</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> n;</span><br><span class="line">	<span class="keyword">while</span>(cin &gt;&gt; n) &#123;</span><br><span class="line">		<span class="keyword">while</span>(old.<span class="built_in">size</span>())</span><br><span class="line">			old.<span class="built_in">pop</span>();</span><br><span class="line">		<span class="keyword">while</span>(nw.<span class="built_in">size</span>())</span><br><span class="line">			nw.<span class="built_in">pop</span>();</span><br><span class="line">		<span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">arr</span><span class="params">(n)</span></span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">			cin &gt;&gt; arr[i];</span><br><span class="line"></span><br><span class="line">		<span class="built_in">radix_sort</span>(arr);</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">			old.<span class="built_in">push</span>(arr[i]);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">long</span> <span class="keyword">long</span> ans = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++)  &#123;</span><br><span class="line">			<span class="keyword">long</span> <span class="keyword">long</span> a = <span class="built_in">getn</span>(), b = <span class="built_in">getn</span>();</span><br><span class="line">			ans += a+b;</span><br><span class="line">			nw.<span class="built_in">push</span>(a+b);</span><br><span class="line">		&#125;</span><br><span class="line">		cout &lt;&lt; ans &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>Competitive Programming</tag>
        <tag>TIOJ</tag>
      </tags>
  </entry>
  <entry>
    <title>TIOJ-1063</title>
    <url>/TIOJ-1063/</url>
    <content><![CDATA[<p>給一$n\times m$矩陣，求最大的子矩陣面積滿足子矩陣內全部都是1</p>
<span id="more"></span>
<p>$n,m\leq 200$</p>
<hr>
<p>這題最直覺的做法就是枚舉一個維度的左右界，可以轉化成最大連續和問題，時間複雜度$\mathcal{O}(n^2m)$<br/><br>但可以透過建表來得知一格的高(該格以上有多長的連續1)，比如範測:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0 0 1 1 0</span><br><span class="line">0 1 1 1 1</span><br><span class="line">0 1 1 1 1</span><br><span class="line">0 0 1 0 0 </span><br></pre></td></tr></table></figure>
<p>可以蓋成:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0 0 1 1 0</span><br><span class="line">0 1 2 2 1</span><br><span class="line">0 2 3 3 2</span><br><span class="line">0 0 4 0 0 </span><br></pre></td></tr></table></figure>
<p>這時就可以在單一維度求解了<br>例如第三列0 2 3 3 2<br>若取2<del>3則面積是$min(2,3)\times (3-2+1)=4$<br/><br>取2</del>4則面積是$min(2,3,3,2)\times (4-2+1)=8$就是答案<br/><br>處理這個可以用到直方圖求最大面積的手段 - 單調stack<br>維護一個單調遞增的stack，可以得知每個點所能觸及到(比該點大)的左右界<br>若這個點比前面的點小，則後面的點的左界肯定不會是前面的點，可以直接pop<br>pop時，因為該點比前面的點小才會pop，同時可維護被pop點的右界<br>最後就該點長度*左右界區間<br>枚舉維度$n$，每一點只會進出stack一次，時間複雜度$\mathcal{O}(nm)$</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">--------------              |   /</span></span><br><span class="line"><span class="comment">      |                     |  /</span></span><br><span class="line"><span class="comment">      |                     | /</span></span><br><span class="line"><span class="comment">      |             *       |/          |    |         ------            *</span></span><br><span class="line"><span class="comment">      |                     |           |    |        /      \</span></span><br><span class="line"><span class="comment">      |             |       |\          |    |       |       |\          |</span></span><br><span class="line"><span class="comment">   \  |             |       | \         |    |       |       | \         |</span></span><br><span class="line"><span class="comment">    \ |             |       |  \        |    |        \     /   \        |</span></span><br><span class="line"><span class="comment">     V              |       |   \        \__/|         -----     \       |</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EmiliaMyWife ios::sync_with_stdio(0); cin.tie(NULL);</span></span><br><span class="line"><span class="comment">/*-----------------------------------------------------------------------------------------------------*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> arr[<span class="number">201</span>][<span class="number">201</span>], l[<span class="number">201</span>], r[<span class="number">201</span>];</span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	EmiliaMyWife</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> n, m, ans = <span class="number">0</span>;</span><br><span class="line">	cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; j++)</span><br><span class="line">			cin &gt;&gt; arr[i][j];</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; j++) &#123;</span><br><span class="line">			<span class="keyword">if</span>(arr[i][j])</span><br><span class="line">				arr[i][j] += arr[i<span class="number">-1</span>][j];<span class="comment">//蓋表</span></span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		arr[i][<span class="number">0</span>] = -INF;</span><br><span class="line">		stack&lt;<span class="keyword">int</span>&gt; cur;</span><br><span class="line">		cur.<span class="built_in">push</span>(<span class="number">0</span>);</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; j++) &#123;</span><br><span class="line">			<span class="keyword">while</span>(arr[i][cur.<span class="built_in">top</span>()] &gt;= arr[i][j])</span><br><span class="line">				r[cur.<span class="built_in">top</span>()] = j, cur.<span class="built_in">pop</span>();<span class="comment">//維護stack</span></span><br><span class="line">			l[j] = cur.<span class="built_in">top</span>();</span><br><span class="line">			cur.<span class="built_in">push</span>(j);</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">while</span>(cur.<span class="built_in">size</span>())</span><br><span class="line">			r[cur.<span class="built_in">top</span>()] = m+<span class="number">1</span>, cur.<span class="built_in">pop</span>();</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; j++)</span><br><span class="line">			ans = <span class="built_in">max</span>(ans, arr[i][j] * (r[j]-l[j]<span class="number">-1</span>));<span class="comment">//更新答案</span></span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; ans;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>Competitive Programming</tag>
        <tag>TIOJ</tag>
      </tags>
  </entry>
  <entry>
    <title>TIOJ-1762</title>
    <url>/TIOJ-1762/</url>
    <content><![CDATA[<p>給一$N\times M$的矩陣，求面積最大的子矩陣滿足該矩陣內所有數字加起來$\leq R$</p>
<span id="more"></span>
<p>$1\leq N,M,R\leq 1,000$</p>
<hr>
<p>看到這題範圍1000，我還一直想要怎麼做得比$\mathcal{O}(N^3)$快，結果看一下時限發現是10s，<del>瞬間變水了</del><br/><br>枚舉一個維度的的左右界，第二個維度就用雙指針迭代右界並且讓左界滿足題目條件，同時不斷更新答案<br>實作上，開個長度$M$的臨時陣列，每到新的右界就把該列的都加上去，這樣就可以壓成一維了<br>枚舉左右界$\mathcal{O}(N^2)$，雙指針$\mathcal{O}(N)$，總複雜度$O(N^3)$</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">--------------              |   /</span></span><br><span class="line"><span class="comment">      |                     |  /</span></span><br><span class="line"><span class="comment">      |                     | /</span></span><br><span class="line"><span class="comment">      |             *       |/          |    |         ------            *</span></span><br><span class="line"><span class="comment">      |                     |           |    |        /      \</span></span><br><span class="line"><span class="comment">      |             |       |\          |    |       |       |\          |</span></span><br><span class="line"><span class="comment">   \  |             |       | \         |    |       |       | \         |</span></span><br><span class="line"><span class="comment">    \ |             |       |  \        |    |        \     /   \        |</span></span><br><span class="line"><span class="comment">     V              |       |   \        \__/|         -----     \       |</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EmiliaMyWife ios::sync_with_stdio(0); cin.tie(NULL);</span></span><br><span class="line"><span class="comment">/*-----------------------------------------------------------------------------------------------------*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	EmiliaMyWife</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> n, m, r, ans = <span class="number">0</span>;</span><br><span class="line">	cin &gt;&gt; n &gt;&gt; m &gt;&gt; r;</span><br><span class="line">	vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">arr</span>(n, vector&lt;<span class="keyword">int</span>&gt;(m));</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m; j++)</span><br><span class="line">			cin &gt;&gt; arr[i][j];</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">		<span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">tmp</span><span class="params">(m)</span></span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j = i; j &lt; n; j++) &#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; m; k++)</span><br><span class="line">				tmp[k] += arr[j][k];</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>, it = <span class="number">0</span>, sum = <span class="number">0</span>; k &lt; m; k++) &#123;</span><br><span class="line">				sum += tmp[k];</span><br><span class="line">				<span class="keyword">while</span>(sum &gt; r) &#123;</span><br><span class="line">					sum -= tmp[it];</span><br><span class="line">					it++;</span><br><span class="line">				&#125;</span><br><span class="line">				ans = <span class="built_in">max</span>(ans, (j-i+<span class="number">1</span>)*(k-it+<span class="number">1</span>));</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; ans &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>Competitive Programming</tag>
        <tag>TIOJ</tag>
      </tags>
  </entry>
  <entry>
    <title>TIOJ-1305</title>
    <url>/TIOJ-1305/</url>
    <content><![CDATA[<p>維護一個集合，支援三種操作:</p>
<ol>
<li>插入元素$x$</li>
<li>移除元素$x$</li>
<li>詢問集合第$k$大</li>
</ol>
<span id="more"></span>
<p>指令數量$\leq 10^5$，<strong>指令參數皆可用32-bit有號整數儲存</strong></p>
<hr>
<p>std::set不支援第三種操作，但pbds好像可以，但我不會。<br>之前聽過有資結能在線處理這東西，但我忘了。<br>所以只好離線。<br>將所有元素當索引值對應到陣列，插入就將那個值+1，移除就-1，這樣就能用前綴和詢問某個元素是第幾大，因為有單調性，所以可以用二分搜找出第k大的元素。<br>不過值域太大，所以得離線來進行離散化。<br>複雜度$O(nlognlogn)$(詢問)，但執行時間還算不錯，大概是二分搜跟BIT都很小吧。<br/><br>不過這題很坑的地方是，上面限制的指令參數包含k，所以k不一定是正整數= =;</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">--------------              |   /</span></span><br><span class="line"><span class="comment">      |                     |  /</span></span><br><span class="line"><span class="comment">      |                     | /</span></span><br><span class="line"><span class="comment">      |             *       |/          |    |         ------            *</span></span><br><span class="line"><span class="comment">      |                     |           |    |        /      \</span></span><br><span class="line"><span class="comment">      |             |       |\          |    |       |       |\          |</span></span><br><span class="line"><span class="comment">   \  |             |       | \         |    |       |       | \         |</span></span><br><span class="line"><span class="comment">    \ |             |       |  \        |    |        \     /   \        |</span></span><br><span class="line"><span class="comment">     V              |       |   \        \__/|         -----     \       |</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EmiliaMyWife ios::sync_with_stdio(0); cin.tie(NULL);</span></span><br><span class="line"><span class="comment">/*-----------------------------------------------------------------------------------------------------*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100001</span>;</span><br><span class="line"><span class="keyword">bool</span> has[N];</span><br><span class="line"><span class="keyword">int</span> bit[N], sz;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mod</span><span class="params">(<span class="keyword">int</span> pos, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(; pos &lt; N; pos+=(pos&amp;-pos))</span><br><span class="line">		bit[pos] += val;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">que</span><span class="params">(<span class="keyword">int</span> pos)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(; pos; pos-=(pos&amp;-pos))</span><br><span class="line">		res += bit[pos];</span><br><span class="line">	<span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	EmiliaMyWife</span><br><span class="line"></span><br><span class="line">	vector&lt;pair&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt;&gt; query;</span><br><span class="line">	vector&lt;<span class="keyword">int</span>&gt; arr;</span><br><span class="line">	string s;</span><br><span class="line">	<span class="keyword">int</span> x;</span><br><span class="line">	<span class="keyword">while</span>(cin &gt;&gt; s) &#123;</span><br><span class="line">		<span class="keyword">if</span>(s[<span class="number">0</span>]==<span class="string">&#x27;e&#x27;</span>)</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		cin &gt;&gt; x;</span><br><span class="line">		query.<span class="built_in">push_back</span>(&#123;s[<span class="number">0</span>], x&#125;);</span><br><span class="line">		<span class="keyword">if</span>(s[<span class="number">0</span>] != <span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">			arr.<span class="built_in">push_back</span>(x);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">sort</span>(arr.<span class="built_in">begin</span>(), arr.<span class="built_in">end</span>()); arr.<span class="built_in">erase</span>(<span class="built_in">unique</span>(arr.<span class="built_in">begin</span>(), arr.<span class="built_in">end</span>()), arr.<span class="built_in">end</span>());</span><br><span class="line">	<span class="meta">#<span class="meta-keyword">define</span> fnd(x) (lower_bound(arr.begin(),arr.end(),(x))-arr.begin()+1)</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">auto</span> &amp;x : query) &#123;</span><br><span class="line">		<span class="keyword">int</span> num = x.second;</span><br><span class="line">		<span class="keyword">if</span>(x.first == <span class="string">&#x27;i&#x27;</span>) &#123;</span><br><span class="line">			num = <span class="built_in">fnd</span>(num);</span><br><span class="line">			<span class="keyword">if</span>(!has[num])</span><br><span class="line">				<span class="built_in">mod</span>(num, <span class="number">1</span>), sz++, has[num] = <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(x.first == <span class="string">&#x27;r&#x27;</span>) &#123;</span><br><span class="line">			num = <span class="built_in">fnd</span>(num);</span><br><span class="line">			<span class="keyword">if</span>(has[num])</span><br><span class="line">				<span class="built_in">mod</span>(num, <span class="number">-1</span>), sz--, has[num] = <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(x.first == <span class="string">&#x27;a&#x27;</span>) &#123;</span><br><span class="line">			<span class="keyword">if</span>(sz &lt; num || num&lt;<span class="number">1</span>) &#123;</span><br><span class="line">				cout &lt;&lt; <span class="string">&quot;error\n&quot;</span>;</span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">int</span> l = <span class="number">1</span>, r = N<span class="number">-1</span>;</span><br><span class="line">			<span class="keyword">while</span>(l &lt; r) &#123;</span><br><span class="line">				<span class="keyword">int</span> m = (l+r)/<span class="number">2</span>;</span><br><span class="line">				<span class="keyword">if</span>(<span class="built_in">que</span>(m) &lt; num)</span><br><span class="line">					l = m+<span class="number">1</span>;</span><br><span class="line">				<span class="keyword">else</span></span><br><span class="line">					r = m;</span><br><span class="line">			&#125;</span><br><span class="line">			cout &lt;&lt; arr[l<span class="number">-1</span>] &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>Competitive Programming</tag>
        <tag>TIOJ</tag>
      </tags>
  </entry>
  <entry>
    <title>TIOJ-1931</title>
    <url>/TIOJ-1931/</url>
    <content><![CDATA[<p>$T$筆測資，<br/><br>每筆測資給一$N$項數列，每次操作可以刪除兩項$a_i,a_j(i\ne j)$，並獲得$2(a_i+a_j-|a_i-a_j|)$價值，求最大可獲得價值。</p>
<span id="more"></span>
<p>$T\le 6,N\le 10^5, 1\le a_i\le 10^9$</p>
<hr>
<p>假設$a_i&lt;a_j$，那<br/><br>$$2(a_i+a_j-|a_i-a_j|)=2[a_i+a_j-(a_j-a_i)]=4a_i$$<br>所以每次刪除可獲得比較小的那一項$\times 4$，因此我們要讓每對比較小的那一項越大越好。<br/><br>考慮以下greedy策略：將第一大跟第二大配對，第三大跟第四大配對…第$2i-1$大跟第$2i$大配對。<br/><br>排序後就能線性時間配對，時間複雜度$\mathcal{O}(TNlogN)$</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">--------------              |   /</span></span><br><span class="line"><span class="comment">      |                     |  /</span></span><br><span class="line"><span class="comment">      |                     | /</span></span><br><span class="line"><span class="comment">      |             *       |/          |    |         ------            *</span></span><br><span class="line"><span class="comment">      |                     |           |    |        /      \</span></span><br><span class="line"><span class="comment">      |             |       |\          |    |       |       |\          |</span></span><br><span class="line"><span class="comment">   \  |             |       | \         |    |       |       | \         |</span></span><br><span class="line"><span class="comment">    \ |             |       |  \        |    |        \     /   \        |</span></span><br><span class="line"><span class="comment">     V              |       |   \        \__/|         -----     \       |</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EmiliaMyWife ios::sync_with_stdio(0); cin.tie(NULL);</span></span><br><span class="line"><span class="keyword">using</span> ll = <span class="keyword">int64_t</span>;</span><br><span class="line"><span class="comment">/*-----------------------------------------------------------------------------------------------------*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	EmiliaMyWife</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">int</span> t;</span><br><span class="line">	cin &gt;&gt; t;</span><br><span class="line">	<span class="keyword">while</span>(t--) &#123;</span><br><span class="line">		<span class="keyword">int</span> n;</span><br><span class="line">		cin &gt;&gt; n;</span><br><span class="line">		<span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">arr</span><span class="params">(n)</span></span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">			cin &gt;&gt; arr[i];</span><br><span class="line">		ll ans = <span class="number">0</span>;</span><br><span class="line">		<span class="built_in">sort</span>(arr.<span class="built_in">begin</span>(), arr.<span class="built_in">end</span>(), greater&lt;<span class="keyword">int</span>&gt;());</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i+=<span class="number">2</span>)</span><br><span class="line">			ans += <span class="number">1LL</span>*arr[i]*<span class="number">4</span>;</span><br><span class="line">		cout &lt;&lt; ans &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>TIOJ</tag>
        <tag>greedy</tag>
      </tags>
  </entry>
  <entry>
    <title>TIOJ-2066</title>
    <url>/TIOJ-2066/</url>
    <content><![CDATA[<p>$T$筆測資，<br/><br>每筆測資給一$N$項數列及一數字$K$，求長度介於$[1,K]$的相異遞增子序列數量$\mod 2^{61}-1$。</p>
<span id="more"></span>
<p>$T\le 8,N\le 10^5,K\le 70, 1\le a_i\le 10^9$</p>
<hr>
<p>令$dp[i][j]$為結尾為$a_i$，且長度為$j$的遞增子序列數量，轉移式為：<br>$$dp[i][j] = \sum^{i}_{k=1} dp[k][j-1],\ a_k&lt;a_i$$<br>以上轉移可用單點修改，求前綴和的資料結構來達到$\mathcal{O}(log n)$轉移。<br/><br>將$a_i$當成index，$dp[i][j-1]$當成value，上述dp的轉移可視為求$1$到$a_i-1$的前綴和，但$a_i$範圍太大，需要先離散化。<br/><br>且最後一筆會卡空間，因此必須將$j$那一維壓成滾動。<br/><br>時間複雜度$\mathcal{O}(TNK)$，空間複雜度$\mathcal{O}(N)$</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">--------------              |   /</span></span><br><span class="line"><span class="comment">      |                     |  /</span></span><br><span class="line"><span class="comment">      |                     | /</span></span><br><span class="line"><span class="comment">      |             *       |/          |    |         ------            *</span></span><br><span class="line"><span class="comment">      |                     |           |    |        /      \</span></span><br><span class="line"><span class="comment">      |             |       |\          |    |       |       |\          |</span></span><br><span class="line"><span class="comment">   \  |             |       | \         |    |       |       | \         |</span></span><br><span class="line"><span class="comment">    \ |             |       |  \        |    |        \     /   \        |</span></span><br><span class="line"><span class="comment">     V              |       |   \        \__/|         -----     \       |</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EmiliaMyWife ios::sync_with_stdio(0); cin.tie(NULL);</span></span><br><span class="line"><span class="keyword">using</span> ll = <span class="keyword">int64_t</span>;</span><br><span class="line"><span class="comment">/*-----------------------------------------------------------------------------------------------------*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> ll mod = (<span class="number">1LL</span>&lt;&lt;<span class="number">61</span>)<span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span>+<span class="number">25</span>;</span><br><span class="line">ll bit[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">modify</span><span class="params">(<span class="keyword">int</span> p, ll val)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(; p&lt;N; p+=p&amp;-p)</span><br><span class="line">		bit[p] = (bit[p] + val) % mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">sum</span><span class="params">(<span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">	ll res = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(; p; p-=p&amp;-p)</span><br><span class="line">		res = (res + bit[p]) % mod;</span><br><span class="line">	<span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	EmiliaMyWife</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> t;</span><br><span class="line">	cin &gt;&gt; t;</span><br><span class="line">	<span class="keyword">while</span>(t--) &#123;</span><br><span class="line">		<span class="keyword">int</span> n, k;</span><br><span class="line">		cin &gt;&gt; n &gt;&gt; k;</span><br><span class="line">		<span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">arr</span><span class="params">(n+<span class="number">1</span>)</span>, v</span>;</span><br><span class="line">		vector&lt;vector&lt;ll&gt;&gt; <span class="built_in">dp</span>(<span class="number">2</span>, vector&lt;ll&gt;(n+<span class="number">1</span>));</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">			cin &gt;&gt; arr[i], v.<span class="built_in">push_back</span>(arr[i]);</span><br><span class="line">		v.<span class="built_in">push_back</span>(<span class="number">0</span>);</span><br><span class="line">		<span class="built_in">sort</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>()); v.<span class="built_in">erase</span>(<span class="built_in">unique</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>()), v.<span class="built_in">end</span>());</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; i++)</span><br><span class="line">			arr[i] = <span class="built_in">upper_bound</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), arr[i])-v.<span class="built_in">begin</span>();</span><br><span class="line">		dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">		ll ans = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">int</span> now = <span class="number">1</span>, prv = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= k; i++) &#123;</span><br><span class="line">			<span class="built_in">memset</span>(bit, <span class="number">0</span>, <span class="keyword">sizeof</span> bit);</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= n; j++)</span><br><span class="line">				dp[now][j] = <span class="number">0</span>;</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">				<span class="built_in">modify</span>(arr[j<span class="number">-1</span>], dp[prv][j<span class="number">-1</span>]);</span><br><span class="line">				dp[now][j] = <span class="built_in">sum</span>(arr[j]<span class="number">-1</span>);</span><br><span class="line">				ans = (ans + dp[now][j]) % mod;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="built_in">swap</span>(now, prv);</span><br><span class="line">		&#125;</span><br><span class="line">		cout &lt;&lt; ans &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>TIOJ</tag>
      </tags>
  </entry>
  <entry>
    <title>TIOJ-2145</title>
    <url>/TIOJ-2145/</url>
    <content><![CDATA[<p>將毯子分成九個格子，中間那格塗黑，再往其他八格遞迴。<br>給定$N$，輸出邊長為$3^n$經過上述操作所得出的成品。</p>
<span id="more"></span>
<p>$N\le 7$</p>
<hr>
<p>$3^7=2187$，所以可以直接照題述來遞迴，一次打九行程式碼太累了，所以我就將切點存起來，就能用迴圈了。<br/><br>複雜度的部分，遞迴感覺很難估計，其實可以發現每格只會被處理一次，所以複雜度會是$\mathcal{O}((3^7)^2)$。<br/><br>嚴謹一點也可由Master Theorem得知。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">--------------              |   /</span></span><br><span class="line"><span class="comment">      |                     |  /</span></span><br><span class="line"><span class="comment">      |                     | /</span></span><br><span class="line"><span class="comment">      |             *       |/          |    |         ------            *</span></span><br><span class="line"><span class="comment">      |                     |           |    |        /      \</span></span><br><span class="line"><span class="comment">      |             |       |\          |    |       |       |\          |</span></span><br><span class="line"><span class="comment">   \  |             |       | \         |    |       |       | \         |</span></span><br><span class="line"><span class="comment">    \ |             |       |  \        |    |        \     /   \        |</span></span><br><span class="line"><span class="comment">     V              |       |   \        \__/|         -----     \       |</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EmiliaMyWife ios::sync_with_stdio(0); cin.tie(NULL);</span></span><br><span class="line"><span class="comment">/*-----------------------------------------------------------------------------------------------------*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> owo[<span class="number">2500</span>][<span class="number">2500</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> lx, <span class="keyword">int</span> rx, <span class="keyword">int</span> ly, <span class="keyword">int</span> ry, <span class="keyword">bool</span> stat)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(stat) &#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = lx; i &lt; rx; i++)</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> j = ly; j &lt; ry; j++)</span><br><span class="line">				owo[i][j] = <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(lx == rx<span class="number">-1</span>)</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	<span class="keyword">int</span> a[<span class="number">4</span>] = &#123;lx, lx+(rx-lx)/<span class="number">3</span>, rx-(rx-lx)/<span class="number">3</span>, rx&#125;;</span><br><span class="line">	<span class="keyword">int</span> b[<span class="number">4</span>] = &#123;ly, ly+(ry-ly)/<span class="number">3</span>, ry-(ry-ly)/<span class="number">3</span>, ry&#125;;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++)</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">3</span>; j++)</span><br><span class="line">			<span class="built_in">solve</span>(a[i], a[i+<span class="number">1</span>], b[j], b[j+<span class="number">1</span>], (i==<span class="number">1</span>)&amp;&amp;(j==<span class="number">1</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	EmiliaMyWife</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">int</span> n;</span><br><span class="line">	cin &gt;&gt; n;</span><br><span class="line">	<span class="keyword">int</span> w = <span class="built_in">pow</span>(<span class="number">3</span>, n);</span><br><span class="line">	<span class="built_in">solve</span>(<span class="number">0</span>, w, <span class="number">0</span>, w, <span class="number">0</span>);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; w; i++)</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; w; j++) &#123;</span><br><span class="line">			cout &lt;&lt; (owo[i][j]?<span class="string">&#x27;#&#x27;</span>:<span class="string">&#x27;.&#x27;</span>);</span><br><span class="line">			<span class="keyword">if</span>(j==w<span class="number">-1</span>)</span><br><span class="line">				cout &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>Competitive Programming</tag>
        <tag>TIOJ</tag>
      </tags>
  </entry>
  <entry>
    <title>TIOJ-1204</title>
    <url>/TIOJ-1204/</url>
    <content><![CDATA[<p>給一棵笛卡兒樹的中序遍歷，輸出其前序遍歷。</p>
<blockquote>
<p>笛卡兒樹: 一棵滿足任意節點權重皆小於其所有子節點的樹。</p>
</blockquote>
<span id="more"></span>
<p>$N\le 10^4, 1\le a_i \le 10^9, a_i \ne a_j(i\ne j)$</p>
<hr>
<p>首先要知道：笛卡兒樹是一個根據數列蓋出來的樹，而<strong>其中序遍歷會剛好還原出原本的數列</strong>，所以問題就變成：給一個數列，輸出其特定的笛卡兒樹的前序遍歷。<br>然後再知道：中序遍歷中，對於任意點其左子樹都會在該點左邊，右子樹會在該點右邊。<br>這樣就有一個解法了：每次找出最小的元素(根節點)，輸出他(前序遍歷)，然後再分別遞迴左右半邊(左子樹&amp;右子樹)，一路遞迴到沒東西為止。<br>複雜度的部分：因為每次都會花$\mathcal{O}(n)$時間找出最小的元素，且會遞迴$\mathcal{O}(logn)$層，所以複雜度是$\mathcal{O}(nlogn)$。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">--------------              |   /</span></span><br><span class="line"><span class="comment">      |                     |  /</span></span><br><span class="line"><span class="comment">      |                     | /</span></span><br><span class="line"><span class="comment">      |             *       |/          |    |         ------            *</span></span><br><span class="line"><span class="comment">      |                     |           |    |        /      \</span></span><br><span class="line"><span class="comment">      |             |       |\          |    |       |       |\          |</span></span><br><span class="line"><span class="comment">   \  |             |       | \         |    |       |       | \         |</span></span><br><span class="line"><span class="comment">    \ |             |       |  \        |    |        \     /   \        |</span></span><br><span class="line"><span class="comment">     V              |       |   \        \__/|         -----     \       |</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EmiliaMyWife ios::sync_with_stdio(0); cin.tie(NULL);</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mem(i,j) memset(i,j,sizeof (i));</span></span><br><span class="line"><span class="keyword">using</span> ll = <span class="keyword">int64_t</span>;</span><br><span class="line"><span class="keyword">using</span> ull = <span class="keyword">uint64_t</span>;</span><br><span class="line"><span class="keyword">using</span> ld = <span class="keyword">long</span> <span class="keyword">double</span>;</span><br><span class="line"><span class="keyword">using</span> uint = <span class="keyword">uint32_t</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> EPS  = <span class="number">1e-8</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF     = <span class="number">0x3F3F3F3F</span>;</span><br><span class="line"><span class="keyword">const</span> ll LINF     = <span class="number">4611686018427387903</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MOD     = <span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="comment">/*-----------------------------------------------------------------------------------------------------*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, vector&lt;<span class="keyword">int</span>&gt; &amp;arr)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(l &gt;= r)</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	<span class="keyword">int</span> w = <span class="built_in">min_element</span>(arr.<span class="built_in">begin</span>() + l, arr.<span class="built_in">begin</span>() + r) - arr.<span class="built_in">begin</span>();</span><br><span class="line">	cout &lt;&lt; arr[w] &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">	<span class="built_in">solve</span>(l, w, arr);</span><br><span class="line">	<span class="built_in">solve</span>(w + <span class="number">1</span>, r, arr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	EmiliaMyWife</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">int</span> n;</span><br><span class="line">	<span class="keyword">while</span>(cin &gt;&gt; n, n) &#123;</span><br><span class="line">		<span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">arr</span><span class="params">(n)</span></span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">			cin &gt;&gt; arr[i];</span><br><span class="line">		<span class="built_in">solve</span>(<span class="number">0</span>, n, arr);</span><br><span class="line">		cout &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>Competitive Programming</tag>
        <tag>TIOJ</tag>
      </tags>
  </entry>
  <entry>
    <title>TIOJ-1406</title>
    <url>/TIOJ-1406/</url>
    <content><![CDATA[<p>在一個沿海的國家中，所有的村莊都是沿著海岸線分佈的（因此它們連成一條直線）。一條筆直的道路連接起所有沿海的村莊。所有的村莊都可以用一個非負整數表示——代表與道路開端的距離(以公里計)。<br>大部分的居民從事漁業活動。捕魚季節結束以後，在旅遊季節還沒有開始之前，這些居民所捕的魚可以被運送至不同的城鎮。只要某個城鎮的魚貨儲存量至少有X噸，那麼該城鎮可以提供X位旅客服務。而目標就是<strong>盡可能將所有旅客平均的分佈</strong>在每個城鎮。換句話說，我們要找出<strong>最大的整數Y</strong>，使得經過村莊與村莊間的魚貨運送，每一個村莊都至少儲存了<strong>Y噸以上</strong>的魚。<br>城鎮與城鎮之間可以運輸<strong>整數噸數</strong>的魚貨。但是每次在運送時，每載送一公里，就會有山上的搶匪搶走一噸的魚。具體來說，若某個村莊欲運送 F噸的魚到距離D公里遠的另一個村莊，那麼實際到達目的地的魚貨量為 F-D 噸。若F小於D，那麼整批的魚貨將會消失不見。<br>當然，你可以任意的在某些村莊將這些魚貨重新包裝、組合，然後再運送出去。舉個例子來說，你可以在城鎮C，將從城鎮A和城鎮B運來的魚的各一半，整理一下，然後整批運送到城鎮D，這樣只算是一次運送。</p>
<span id="more"></span>
<p>$N\le 10^5, P,F\le 10^{12}$($P$為城鎮的位置，$F$為漁獲)</p>
<hr>
<p>要greedy的找出Y很難，因此考慮二分搜，對於每個可能的答案我們都能在線性時間檢驗是否可以達到。<br>題目最後一句頗重要，代表著我們<strong>每條路都只會被收最多一次過路費</strong>，所以可以維護兩個變數：在這之前所需的量nd及在這之前能供給的量cur。<br>如果當前的村莊漁獲大於答案，就能讓她消耗nd或加進cur，反之則相反。<br>迭代到下個村莊前扣掉/加上兩村莊的距離就好。<br>時間複雜度$\mathcal{O}(nlogC)$。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">--------------              |   /</span></span><br><span class="line"><span class="comment">      |                     |  /</span></span><br><span class="line"><span class="comment">      |                     | /</span></span><br><span class="line"><span class="comment">      |             *       |/          |    |         ------            *</span></span><br><span class="line"><span class="comment">      |                     |           |    |        /      \</span></span><br><span class="line"><span class="comment">      |             |       |\          |    |       |       |\          |</span></span><br><span class="line"><span class="comment">   \  |             |       | \         |    |       |       | \         |</span></span><br><span class="line"><span class="comment">    \ |             |       |  \        |    |        \     /   \        |</span></span><br><span class="line"><span class="comment">     V              |       |   \        \__/|         -----     \       |</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EmiliaMyWife ios::sync_with_stdio(0); cin.tie(NULL);</span></span><br><span class="line"><span class="keyword">using</span> ll = <span class="keyword">int64_t</span>;</span><br><span class="line"><span class="comment">/*-----------------------------------------------------------------------------------------------------*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(ll x, vector&lt;pair&lt;ll, ll&gt;&gt; &amp;arr)</span> </span>&#123;</span><br><span class="line">	ll nd = <span class="number">0</span>, cur = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> n = arr.<span class="built_in">size</span>();</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">		<span class="keyword">if</span>(arr[i].second &gt; x) &#123;</span><br><span class="line">			ll w = <span class="built_in">min</span>(nd, arr[i].second - x);</span><br><span class="line">			nd -= w;</span><br><span class="line">			cur += arr[i].second - w - x;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			ll owo = x - arr[i].second;</span><br><span class="line">			ll w = <span class="built_in">min</span>(cur, owo);</span><br><span class="line">			cur -= w;</span><br><span class="line">			nd += owo - w;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(i &lt; n - <span class="number">1</span>) &#123;</span><br><span class="line">			cur = max&lt;ll&gt;(<span class="number">0</span>, cur - (arr[i + <span class="number">1</span>].first - arr[i].first));</span><br><span class="line">			<span class="keyword">if</span>(nd)</span><br><span class="line">				nd += arr[i + <span class="number">1</span>].first - arr[i].first;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> (!nd);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	EmiliaMyWife</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">int</span> n;</span><br><span class="line">	<span class="keyword">while</span>(cin &gt;&gt; n) &#123;</span><br><span class="line">		vector&lt;pair&lt;ll, ll&gt;&gt; <span class="built_in">arr</span>(n);</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">			cin &gt;&gt; arr[i].first &gt;&gt; arr[i].second;</span><br><span class="line">		ll l = <span class="number">0</span>, r = <span class="number">2e12</span>;</span><br><span class="line">		<span class="keyword">while</span>(l &lt; r) &#123;</span><br><span class="line">			ll m = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">			<span class="keyword">if</span>(!<span class="built_in">check</span>(m, arr))</span><br><span class="line">				r = m;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">				l = m + <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		cout &lt;&lt; l - <span class="number">1</span> &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>Competitive Programming</tag>
        <tag>TIOJ</tag>
      </tags>
  </entry>
  <entry>
    <title>TIOJ-1202</title>
    <url>/TIOJ-1202/</url>
    <content><![CDATA[<p>地平線上有許多房子，而這些房子在夕陽的照射之下形成有趣的輪廓，我們稱之為天際線(Skyline)。<br>為了方便起見，你可以假設所有的房子都是一個位在2D平面上的矩形，並且有一條邊貼在這個假想2D平面上的X軸。<br>一棟建築可以用三元數組(Li,Hi,Ri)來表示，依序代表該建築物的左界座標、高度、右界座標。下方左圖中的八棟建築就是用此方法表示就是(1,11,5), (2,6,7), (3,13,9), (12,7,16), (14,3,25), (19,18,22), (23,13,29), (24,4,28)。<br><img src="https://tioj.ck.tp.edu.tw/pimgs/1202.gif" alt="Houses"><br>一個天際線也可以用類似的「X-遞增序列」表示出來，例如上面的八棟建築合併之後上方右圖的天際線可表示為：<br>(1, 11, 3, 13, 9, 0, 12, 7, 16, 3, 19, 18, 22, 3, 23, 13, 29, 0)<br>請你寫一個程式，給你這些房子的位置，請你把它們形成的天際線描述出來。</p>
<blockquote>
<p>請注意，最後一個數字一定是0。也請不要輸出多餘空白。</p>
</blockquote>
<span id="more"></span>
<p>$n\le 30000, L_i\le R_i, 1\le L_i,R_i,H_i\le 10^9$</p>
<hr>
<p>天際線的定義其實就是找出每個x上的房子高度最大值，如果跟前一格不一樣就記錄下來。<br>可能會發生最大高度變動的只有每個房子的左右界，所以就先記錄下來，將房子按左界排序，然後就能掃描線了。<br>之後維護一個隨右界遞減的單調對列，不過右界並沒有單調性，所以得用map之類的結構。<br>先將左邊右界小於當前座標的房子都pop掉，之後加入左界為當前座標的房子。<br>加入一棟房子時，先檢查它右邊第一個是否比它大，如果比它大那這個房子就用不到，否則就插入，插入後還得將它左邊比它小的都pop掉。<br>每個點的最大值就會是隊列的首項，一開始先插入[INF, 0]，這樣在沒房子時高度會視為0。<br>時間複雜度：因為左右界最多只會有$2n$個，所以只會迭代$\mathcal{O}(n)$次，配上map的複雜度，總共$\mathcal{O}(nlogn)$。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">--------------              |   /</span></span><br><span class="line"><span class="comment">      |                     |  /</span></span><br><span class="line"><span class="comment">      |                     | /</span></span><br><span class="line"><span class="comment">      |             *       |/          |    |         ------            *</span></span><br><span class="line"><span class="comment">      |                     |           |    |        /      \</span></span><br><span class="line"><span class="comment">      |             |       |\          |    |       |       |\          |</span></span><br><span class="line"><span class="comment">   \  |             |       | \         |    |       |       | \         |</span></span><br><span class="line"><span class="comment">    \ |             |       |  \        |    |        \     /   \        |</span></span><br><span class="line"><span class="comment">     V              |       |   \        \__/|         -----     \       |</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EmiliaMyWife ios::sync_with_stdio(0); cin.tie(NULL);</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mem(i,j) memset(i,j,sizeof (i));</span></span><br><span class="line"><span class="keyword">using</span> ll = <span class="keyword">int64_t</span>;</span><br><span class="line"><span class="keyword">using</span> ull = <span class="keyword">uint64_t</span>;</span><br><span class="line"><span class="keyword">using</span> ld = <span class="keyword">long</span> <span class="keyword">double</span>;</span><br><span class="line"><span class="keyword">using</span> uint = <span class="keyword">uint32_t</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> EPS  = <span class="number">1e-8</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF     = <span class="number">0x3F3F3F3F</span>;</span><br><span class="line"><span class="keyword">const</span> ll LINF     = <span class="number">4611686018427387903</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MOD     = <span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="comment">/*-----------------------------------------------------------------------------------------------------*/</span></span><br><span class="line"></span><br><span class="line">map&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; cur;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">seg</span> &#123;</span></span><br><span class="line">	<span class="keyword">int</span> l, r, y;</span><br><span class="line">	<span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(seg &amp;b) &#123;<span class="keyword">return</span> l==b.l ? r&lt;b.r : l&lt;b.l;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> y, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">auto</span> it = cur.<span class="built_in">lower_bound</span>(r);</span><br><span class="line">	<span class="keyword">if</span>(it-&gt;second &gt;= y)</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	it = cur.<span class="built_in">upper_bound</span>(r);</span><br><span class="line">	<span class="keyword">while</span>(it != cur.<span class="built_in">begin</span>()) &#123;</span><br><span class="line">		it--;</span><br><span class="line">		<span class="keyword">if</span>(it-&gt;second &lt;= y)</span><br><span class="line">			it = cur.<span class="built_in">erase</span>(it);</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	cur[r] = y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	EmiliaMyWife</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">int</span> n;</span><br><span class="line">	<span class="keyword">while</span>(cin &gt;&gt; n, n) &#123;</span><br><span class="line">		cur.<span class="built_in">clear</span>();</span><br><span class="line">		<span class="function">vector&lt;seg&gt; <span class="title">arr</span><span class="params">(n)</span></span>;</span><br><span class="line">		vector&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">			cin &gt;&gt; arr[i].l &gt;&gt; arr[i].y &gt;&gt; arr[i].r;</span><br><span class="line">			v.<span class="built_in">push_back</span>(arr[i].l);</span><br><span class="line">			v.<span class="built_in">push_back</span>(arr[i].r);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">sort</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>()); v.<span class="built_in">erase</span>(<span class="built_in">unique</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>()), v.<span class="built_in">end</span>());</span><br><span class="line">		<span class="built_in">sort</span>(arr.<span class="built_in">begin</span>(), arr.<span class="built_in">end</span>());</span><br><span class="line">		vector&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; ans;</span><br><span class="line">		<span class="keyword">int</span> prv = <span class="number">0</span>, it = <span class="number">0</span>;</span><br><span class="line">		cur[INF] = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i : v) &#123;</span><br><span class="line">			<span class="keyword">if</span>(cur.<span class="built_in">count</span>(i))</span><br><span class="line">				cur.<span class="built_in">erase</span>(i);</span><br><span class="line">			<span class="keyword">while</span>(it &lt; n &amp;&amp; arr[it].l == i) &#123;</span><br><span class="line">				<span class="built_in">add</span>(arr[it].y, arr[it].r);</span><br><span class="line">				it++;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span>(cur.<span class="built_in">begin</span>()-&gt;second != prv)</span><br><span class="line">				ans.<span class="built_in">push_back</span>(&#123;i, prv = cur.<span class="built_in">begin</span>()-&gt;second&#125;);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; ans.<span class="built_in">size</span>(); i++)</span><br><span class="line">			cout &lt;&lt; ans[i].first &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; ans[i].second &lt;&lt; <span class="string">&quot; \n&quot;</span>[i + <span class="number">1</span> == ans.<span class="built_in">size</span>()];</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>Competitive Programming</tag>
        <tag>TIOJ</tag>
      </tags>
  </entry>
  <entry>
    <title>TIOJ-1316</title>
    <url>/TIOJ-1316/</url>
    <content><![CDATA[<p><img src="https://tioj.ck.tp.edu.tw/pimgs/1316.png" alt="The chips"><br>現在有許多個晶片排成一列，其中兩兩希望連成一對(但一對晶片不一定相鄰)，如下圖所示。<br>然而一個小小(其實不小)的問題是，由於空間關係，晶片間的連線最多只能列上方一條，列下方一條<br>也就是同一個鉛直位置最多只有兩條連線經過。<br>試問給定一列晶片的配對條件，在符合上述連線方式的情況下，最多可以連接幾對晶片？</p>
<span id="more"></span>
<p>給$2N$個數字，每個數字剛好出現兩次且介於$[1,N], N\le 4000$</p>
<hr>
<p>考慮貪心，只要走到了某個數字第二次出現就拿(如果可以的話)，沒那麼嚴謹的證明大概就是接下來的右界都會在更右邊，如果取了那些右界卻不取比較前面的，答案不會比較好。<br>時間複雜度$\mathcal{O}(N^2)$</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">--------------              |   /</span></span><br><span class="line"><span class="comment">      |                     |  /</span></span><br><span class="line"><span class="comment">      |                     | /</span></span><br><span class="line"><span class="comment">      |             *       |/          |    |         ------            *</span></span><br><span class="line"><span class="comment">      |                     |           |    |        /      \</span></span><br><span class="line"><span class="comment">      |             |       |\          |    |       |       |\          |</span></span><br><span class="line"><span class="comment">   \  |             |       | \         |    |       |       | \         |</span></span><br><span class="line"><span class="comment">    \ |             |       |  \        |    |        \     /   \        |</span></span><br><span class="line"><span class="comment">     V              |       |   \        \__/|         -----     \       |</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EmiliaMyWife ios::sync_with_stdio(0); cin.tie(NULL);</span></span><br><span class="line"><span class="comment">/*-----------------------------------------------------------------------------------------------------*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	EmiliaMyWife</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> n, ans = <span class="number">0</span>;</span><br><span class="line">	cin &gt;&gt; n;</span><br><span class="line">	<span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">arr</span><span class="params">(<span class="number">2</span> * n)</span>, <span class="title">cnt</span><span class="params">(<span class="number">2</span> * n)</span>, <span class="title">has</span><span class="params">(n + <span class="number">1</span>, <span class="number">-1</span>)</span></span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n * <span class="number">2</span>; i++)</span><br><span class="line">		cin &gt;&gt; arr[i];</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n * <span class="number">2</span>; i++) &#123;</span><br><span class="line">		<span class="keyword">if</span>(~has[arr[i]]) &#123;</span><br><span class="line">			<span class="keyword">bool</span> res = <span class="number">1</span>;</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> j = has[arr[i]]; j &lt;= i; j++)</span><br><span class="line">				res &amp;= (cnt[j] &lt; <span class="number">2</span>);</span><br><span class="line">			<span class="keyword">if</span>(res) &#123;</span><br><span class="line">				ans++;</span><br><span class="line">				<span class="keyword">for</span>(<span class="keyword">int</span> j = has[arr[i]]; j &lt;= i; j++)</span><br><span class="line">					cnt[j]++;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			has[arr[i]] = i;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; ans &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>TIOJ</tag>
        <tag>greedy</tag>
      </tags>
  </entry>
  <entry>
    <title>TIOJ-1838</title>
    <url>/TIOJ-1838/</url>
    <content><![CDATA[<p>給一座邊上帶權$T_i$的森林，加邊權為$l$邊把他們連成一棵樹，輸出最短樹直徑。</p>
<span id="more"></span>
<p>$N\le 10^5, 0\le M &lt; n,1\le T_i, l\le 10^4$</p>
<hr>
<p>*第二道靠自己寫出的IOI題目&gt;////&lt;*<br>先考慮圖上無任何邊(也就是只有$N$個點)的時候，最佳解應該是把他們連成這樣：<br/><br><img src="star.png" alt="star"><br>這樣樹直徑只會是$2l$，沒辦法再更少了。<br/><br>然後在考慮森林中的每棵樹，最佳解會是找出樹上某個點當根，並且以他當根的最大深度最小。(後來知道那叫圓心)找出那個點可以用樹dp做到，考慮以i為根最大深度，轉移時就把從父節點那一條給拉過來就好。<br>然後把根與根相接，接成上面的形狀，至於中間的點我們就選用最大深度最大的那棵樹。<br>可能會有三個case:</p>
<ol>
<li>本來某棵的樹直徑就已經最大</li>
<li>最大深度第二深的樹連到中間那個</li>
<li>第二大深度的樹連到第三大深度的樹</li>
</ol>
<p>這樣答案就會是$max($每棵樹的直徑$, $最大深度的樹$+l+$第二大深度的樹$, $第二大深度的樹$+2l+$第三大深度的樹$)$。<br/><br>時間複雜度$\mathcal{O}(nlogn)$</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">--------------              |   /</span></span><br><span class="line"><span class="comment">      |                     |  /</span></span><br><span class="line"><span class="comment">      |                     | /</span></span><br><span class="line"><span class="comment">      |             *       |/          |    |         ------            *</span></span><br><span class="line"><span class="comment">      |                     |           |    |        /      \</span></span><br><span class="line"><span class="comment">      |             |       |\          |    |       |       |\          |</span></span><br><span class="line"><span class="comment">   \  |             |       | \         |    |       |       | \         |</span></span><br><span class="line"><span class="comment">    \ |             |       |  \        |    |        \     /   \        |</span></span><br><span class="line"><span class="comment">     V              |       |   \        \__/|         -----     \       |</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EmiliaMyWife ios::sync_with_stdio(0); cin.tie(NULL);</span></span><br><span class="line"><span class="comment">/*-----------------------------------------------------------------------------------------------------*/</span></span><br><span class="line"></span><br><span class="line">vector&lt;vector&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt;&gt; edge;</span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; ans, dep;</span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; cur;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> v, <span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">auto</span> a : edge[v]) &#123;</span><br><span class="line">		<span class="keyword">if</span>(a.first == p)</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		<span class="built_in">dfs</span>(a.first, v);</span><br><span class="line">		dep[v] = <span class="built_in">max</span>(dep[v], dep[a.first] + a.second);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> v, <span class="keyword">int</span> p, <span class="keyword">int</span> w)</span> </span>&#123;</span><br><span class="line">	multiset&lt;<span class="keyword">int</span>&gt; des;</span><br><span class="line">	ans[v] = <span class="built_in">max</span>(dep[v], w);</span><br><span class="line">	cur.<span class="built_in">push_back</span>(ans[v]);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">auto</span> &amp;[a, b] : edge[v])</span><br><span class="line">		<span class="keyword">if</span>(a != p)</span><br><span class="line">			des.<span class="built_in">insert</span>(dep[a] + b);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">auto</span> &amp;[a, b] : edge[v]) &#123;</span><br><span class="line">		<span class="keyword">if</span>(a == p)</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		des.<span class="built_in">erase</span>(des.<span class="built_in">find</span>(dep[a] + b));</span><br><span class="line">		<span class="built_in">dfs</span>(a, v, <span class="built_in">max</span>(w, des.<span class="built_in">size</span>() ? *des.<span class="built_in">rbegin</span>() : <span class="number">0</span>) + b);</span><br><span class="line">		des.<span class="built_in">insert</span>(dep[a] + b);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m, <span class="keyword">int</span> l)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> lans = <span class="number">0</span>;</span><br><span class="line">	edge.<span class="built_in">clear</span>(); edge.<span class="built_in">resize</span>(n);</span><br><span class="line">	ans.<span class="built_in">clear</span>(); ans.<span class="built_in">resize</span>(n);</span><br><span class="line">	dep.<span class="built_in">clear</span>(); dep.<span class="built_in">resize</span>(n);</span><br><span class="line">	vector&lt;<span class="keyword">int</span>&gt; owo;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>, a, b, c; i &lt; m; i++)</span><br><span class="line">		cin &gt;&gt; a &gt;&gt; b &gt;&gt; c, edge[a].<span class="built_in">push_back</span>(&#123;b, c&#125;), edge[b].<span class="built_in">push_back</span>(&#123;a, c&#125;);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">		<span class="keyword">if</span>(ans[i])</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		<span class="built_in">dfs</span>(i, i);</span><br><span class="line">		<span class="built_in">dfs</span>(i, i, <span class="number">0</span>);</span><br><span class="line">		lans = <span class="built_in">max</span>(lans, *<span class="built_in">max_element</span>(cur.<span class="built_in">begin</span>(), cur.<span class="built_in">end</span>()));</span><br><span class="line">		owo.<span class="built_in">push_back</span>(*<span class="built_in">min_element</span>(cur.<span class="built_in">begin</span>(), cur.<span class="built_in">end</span>()));</span><br><span class="line">		cur.<span class="built_in">clear</span>();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">sort</span>(owo.<span class="built_in">begin</span>(), owo.<span class="built_in">end</span>(), greater&lt;<span class="keyword">int</span>&gt;());</span><br><span class="line">	<span class="keyword">if</span>(owo.<span class="built_in">size</span>() &gt; <span class="number">1</span>)</span><br><span class="line">		lans = <span class="built_in">max</span>(lans, owo[<span class="number">0</span>] + owo[<span class="number">1</span>] + l);</span><br><span class="line">	<span class="keyword">if</span>(owo.<span class="built_in">size</span>() &gt; <span class="number">2</span>)</span><br><span class="line">		lans = <span class="built_in">max</span>(lans, owo[<span class="number">1</span>] + owo[<span class="number">2</span>] + <span class="number">2</span> * l);</span><br><span class="line">	cout &lt;&lt; lans &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	EmiliaMyWife</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> n, m, l;</span><br><span class="line">	<span class="keyword">while</span>(cin &gt;&gt; n &gt;&gt; m &gt;&gt; l)</span><br><span class="line">		<span class="built_in">solve</span>(n, m, l);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>TIOJ</tag>
        <tag>greedy</tag>
        <tag>IOI</tag>
      </tags>
  </entry>
  <entry>
    <title>TIOJ-1924</title>
    <url>/TIOJ-1924/</url>
    <content><![CDATA[<p>有三個人(P, E, C)走在路上很無聊，於是他們開始了一個遊戲。<br/><br>他們將要走的路是一條筆直的路徑，依序有$N\le 2\times 10^6$顆石塊排成一排。這$N$顆石塊很特別，每一顆都只能被P、E、C其中一個人撿起。之後P、E、C會在走過這條路時選一個區間開始撿石塊，將區間內所有可以被他撿起的石塊都拿起來。然而為了避免P、E、C三個人在路途中打架，他們所選定的區間兩兩交集必須要是空的。<br/><br>說石持那十塊，P、E、C三個人已經走完這條路並且撿好石塊了。請計算他們三人所持有的石塊個數總和最大是多少。</p>
<span id="more"></span>
<hr>
<p>可以發現如果路上有任何地方沒被三個人的區間涵蓋到，那把這個地方也給涵蓋一定不會比較差，所以問題就變成把整條路切成三段，每段分配給其中一人。<br>考慮$dp[N][X][{S}]$，代表第$N$個石頭是分配給$X$，且已經$S$內的人皆已經被分配過了。<br/><br>轉移時，可能前一顆石頭也是給$X$，或者是給$S$內除了$X$的人。<br/><br>而這題會卡記憶體，所以要滾動，設$X$為人數(在這題中為3)，時間複雜度$\mathcal{O}(NX^22^X)$，空間複雜度$\mathcal{O}(2^XX)$。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">--------------              |   /</span></span><br><span class="line"><span class="comment">      |                     |  /</span></span><br><span class="line"><span class="comment">      |                     | /</span></span><br><span class="line"><span class="comment">      |             *       |/          |    |         ------            *</span></span><br><span class="line"><span class="comment">      |                     |           |    |        /      \</span></span><br><span class="line"><span class="comment">      |             |       |\          |    |       |       |\          |</span></span><br><span class="line"><span class="comment">   \  |             |       | \         |    |       |       | \         |</span></span><br><span class="line"><span class="comment">    \ |             |       |  \        |    |        \     /   \        |</span></span><br><span class="line"><span class="comment">     V              |       |   \        \__/|         -----     \       |</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EmiliaMyWife ios::sync_with_stdio(0); cin.tie(NULL);</span></span><br><span class="line"><span class="comment">/*-----------------------------------------------------------------------------------------------------*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> dp[<span class="number">2</span>][<span class="number">1</span> &lt;&lt; <span class="number">3</span>][<span class="number">3</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	EmiliaMyWife</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">int</span> n;</span><br><span class="line">	cin &gt;&gt; n;</span><br><span class="line">	string s;</span><br><span class="line">	cin &gt;&gt; s;</span><br><span class="line">	<span class="keyword">int</span> a = <span class="number">0</span>, b = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">		<span class="built_in">swap</span>(a, b);</span><br><span class="line">		<span class="keyword">char</span> c = s[i - <span class="number">1</span>];</span><br><span class="line">		<span class="keyword">int</span> owo;</span><br><span class="line">		<span class="keyword">if</span>(c == <span class="string">&#x27;P&#x27;</span>)</span><br><span class="line">			owo = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">if</span>(c == <span class="string">&#x27;C&#x27;</span>)</span><br><span class="line">			owo = <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">if</span>(c == <span class="string">&#x27;E&#x27;</span>)</span><br><span class="line">			owo = <span class="number">2</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; (<span class="number">1</span> &lt;&lt; <span class="number">3</span>); j++) &#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="number">3</span>; k++) &#123;</span><br><span class="line">				<span class="keyword">if</span>(!(j &gt;&gt; k &amp; <span class="number">1</span>))</span><br><span class="line">					<span class="keyword">continue</span>;</span><br><span class="line">				dp[a][j][k] = dp[b][j][k];</span><br><span class="line">				<span class="keyword">for</span>(<span class="keyword">int</span> w = <span class="number">0</span>; w &lt; <span class="number">3</span>; w++) &#123;</span><br><span class="line">					<span class="keyword">if</span>(j &gt;&gt; w &amp; <span class="number">1</span>)</span><br><span class="line">						dp[a][j][k] = <span class="built_in">max</span>(dp[a][j][k], dp[b][j ^ (<span class="number">1</span> &lt;&lt; k)][w]);</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">if</span>(k == owo)</span><br><span class="line">					dp[a][j][k]++;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; (<span class="number">1</span> &lt;&lt; <span class="number">3</span>); i++)</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">3</span>; j++)</span><br><span class="line">			ans = <span class="built_in">max</span>(ans, dp[a][i][j]);</span><br><span class="line">	cout &lt;&lt; ans &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>Competitive Programming</tag>
        <tag>TIOJ</tag>
      </tags>
  </entry>
  <entry>
    <title>TIOJ-1353</title>
    <url>/TIOJ-1353/</url>
    <content><![CDATA[<p>在歷史上，鴻門宴是齣很大的事件，鴻門宴上，雖不乏美酒佳肴，但卻暗藏殺機，項羽的亞父范增<br>一直主張殺掉劉邦，在酒宴上，三次舉起所佩玉玦，一再示意項羽發令，但項羽卻猶豫不決，<br>默然不應。范增召項莊舞劍為酒宴助興，趁機殺掉劉邦，項伯為保護劉邦，也撥劍起舞，掩護了劉邦，<br>在危急關頭，劉邦部下樊噲帶劍擁盾闖入軍門，怒目直視項羽，項羽見此人氣度不凡，只好問來者是何人，<br>當得知是劉邦的部將時，即命賜酒，樊噲立而飲之，樊噲還乘機說了一些劉邦的好話，項羽無言以對，劉邦乘機一走了之。<br>離開之後，劉邦心有不甘，所以假裝釋懷好意、盡釋前嫌，向項羽陪了不是，又邀請楚軍各大將領來參加他所舉辦的『綠門宴』，以殺掉他們的等級將領。</p>
<span id="more"></span>
<p>劉邦聽說楚軍將領的分級是按照令牌的數量來決定，而令牌上則有一些數字，很神奇的是除了1以外沒有小於他的數字能整除他，而將領們可以利用那些數字、大於等於一的次方以及乘法，來定義自己鎧甲上的號碼。<br>如：某A有2與3的令牌，他的鎧甲就有可能是$2^5 \times 3 = 96$<br/><br>今天將領們按照其鎧甲上的號碼入座，劉邦發現他們鎧甲上的數字剛好形成一個公差為1的等差數列。<br>如果能殺掉他們等級最高的將領，楚軍必會動搖，而漢軍就有機可乘了！你能幫助他嗎？</p>
<p>輸入兩個數字$a, b$，代表第一個人與最後一個人的號碼，輸出持有最多令牌的人的令牌數量與號碼。<br/><br>$a, b\le 10^6$，有多筆測資</p>
<hr>
<p>被包裝了一下。</p>
<blockquote>
<p>除了1以外沒有小於他的數字能整除他</p>
</blockquote>
<p>代表令牌上的數字為質數，令牌數量為質因數的數量。<br>所以這問題是給$L,R$，問區間$[L,R]$中含最多質因數的數字(因為公差為1，所以是從整個區間找)。<br/><br>範圍很大，對於每個數字都用根號去找不太好。<br>但總值域不大(只有$10^6$)，所以可以用埃氏篩，埃氏篩可以記錄每個數字的所有因數或質因數，就可以在$O(nlogn)$的時間建表。<br/><br>至於詢問，如果詢問數量有點多，那得用線段樹配二分搜，然而我偷懶想賭賭看詢問數很少，從執行時間來看的確很少。<br>複雜度:$O(nlogn+nT)$，$T$為測資數量。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">--------------              |   /</span></span><br><span class="line"><span class="comment">      |                     |  /</span></span><br><span class="line"><span class="comment">      |                     | /</span></span><br><span class="line"><span class="comment">      |             *       |/          |    |         ------            *</span></span><br><span class="line"><span class="comment">      |                     |           |    |        /      \</span></span><br><span class="line"><span class="comment">      |             |       |\          |    |       |       |\          |</span></span><br><span class="line"><span class="comment">   \  |             |       | \         |    |       |       | \         |</span></span><br><span class="line"><span class="comment">    \ |             |       |  \        |    |        \     /   \        |</span></span><br><span class="line"><span class="comment">     V              |       |   \        \__/|         -----     \       |</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EmiliaMyWife ios::sync_with_stdio(0); cin.tie(NULL);</span></span><br><span class="line"><span class="comment">/*-----------------------------------------------------------------------------------------------------*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e6</span> + <span class="number">25</span>;</span><br><span class="line"><span class="keyword">int</span> cnt[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="function">EmiliaMyWife</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">	<span class="title">for</span><span class="params">(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; N; i++)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(cnt[i])</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j = i; j &lt; N; j += i) &#123;</span><br><span class="line">			cnt[j]++;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> a, b;</span><br><span class="line">	<span class="keyword">while</span>(cin &gt;&gt; a &gt;&gt; b) &#123;</span><br><span class="line">		<span class="keyword">int</span> mx = <span class="number">0</span>, num = <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j = a; j &lt;= b; j++) &#123;</span><br><span class="line">			<span class="keyword">if</span>(mx &lt; cnt[j])</span><br><span class="line">				mx = cnt[j], num = j;</span><br><span class="line">		&#125;</span><br><span class="line">		cout &lt;&lt; num &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; mx &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>Competitive Programming</tag>
        <tag>TIOJ</tag>
      </tags>
  </entry>
  <entry>
    <title>TIOJ-1163</title>
    <url>/TIOJ-1163/</url>
    <content><![CDATA[<p>有一天，時弦無意間聽到了黑暗騎士與憂鬱人士的對話：<br>「最近家裡附近的道路又在整修了，我等了三天才有通路連到這裡，真是科科。」<br>「哭哭啦，你比我好多了。從我家到這裡的路蓋了五天才蓋好咧。」<br>時弦聽了以後覺得很有趣，於是就把他們兩人的對話對照了地圖：<br><img src="https://tioj.ck.tp.edu.tw/pimgs/1163_1.png" alt="map"><br>地圖上每個點都是一個地方，而每一條邊上面所寫的數字代表第幾天以後該道路才會通。<br>例如要有一條從A走到D的道路需要等到第三天才能通行。<br>「如果我隨便指定兩個點，要如何很快地知道這兩個地點要等到第幾天才有連接的道路呢？」<br>時弦想了很久，決定請TDY好威幫忙。哪知道TDY好威一下子就解決了這個問題，卻不告訴時弦。<br>他說：「你應該自己想出來的，這個題目根本就是秒殺嘛…」<br>四處求助無門的時弦，決定把解決這個問題的重責大任交給你！</p>
<span id="more"></span>
<p>$V\le 30000, E\le 50000, Q\le 50000$，詢問兩點不連通輸出-1。</p>
<hr>
<p>觀察一下可以發現，我們只需要盡可能用權重小的讓圖連通，因此就可以做MST。<br>用完MST後會變一座森林，對每棵樹做LCA即可知道他們路徑權重最大值。<br>連通可以直接用kruskal時的dsu來判，真的很好用。<br>實作量稍大，不過這也是必備的技能(吧<br>複雜度$\mathcal{O}((V+E)log(V+E))$。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">--------------              |   /</span></span><br><span class="line"><span class="comment">      |                     |  /</span></span><br><span class="line"><span class="comment">      |                     | /</span></span><br><span class="line"><span class="comment">      |             *       |/          |    |         ------            *</span></span><br><span class="line"><span class="comment">      |                     |           |    |        /      \</span></span><br><span class="line"><span class="comment">      |             |       |\          |    |       |       |\          |</span></span><br><span class="line"><span class="comment">   \  |             |       | \         |    |       |       | \         |</span></span><br><span class="line"><span class="comment">    \ |             |       |  \        |    |        \     /   \        |</span></span><br><span class="line"><span class="comment">     V              |       |   \        \__/|         -----     \       |</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EmiliaMyWife ios::sync_with_stdio(0); cin.tie(NULL);</span></span><br><span class="line"><span class="comment">/*-----------------------------------------------------------------------------------------------------*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">3e4</span> + <span class="number">25</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ed</span> &#123;</span></span><br><span class="line">	<span class="keyword">int</span> a, b, c;</span><br><span class="line">	<span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(ed x) &#123; <span class="keyword">return</span> c &lt; x.c; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">int</span> pa[N], sz[N], dep[N], lca[<span class="number">15</span>][N], mx[<span class="number">15</span>][N];</span><br><span class="line"><span class="keyword">bool</span> vis[N];</span><br><span class="line">vector&lt;vector&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt;&gt; edge;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fnd</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123; <span class="keyword">return</span> pa[x] == x ? pa[x] : pa[x] = <span class="built_in">fnd</span>(pa[x]); &#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">uni</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span>((a = <span class="built_in">fnd</span>(a)) == (b = <span class="built_in">fnd</span>(b)))</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	<span class="keyword">if</span>(sz[a] &gt; sz[b])</span><br><span class="line">		<span class="built_in">swap</span>(a, b);</span><br><span class="line">	<span class="keyword">return</span> sz[b] += sz[a], pa[a] = b, <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">	vis[v] = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">auto</span> [u, c] : edge[v]) &#123;</span><br><span class="line">		<span class="keyword">if</span>(!vis[u]) &#123;</span><br><span class="line">			dep[u] = dep[v] + <span class="number">1</span>;</span><br><span class="line">			lca[<span class="number">0</span>][u] = v;</span><br><span class="line">			mx[<span class="number">0</span>][u] = c;</span><br><span class="line">			<span class="built_in">dfs</span>(u);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(<span class="built_in">fnd</span>(a) != <span class="built_in">fnd</span>(b))</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span>(dep[a] &lt; dep[b])</span><br><span class="line">		<span class="built_in">swap</span>(a, b);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">14</span>; ~i; i--)</span><br><span class="line">		<span class="keyword">if</span>(dep[lca[i][a]] &gt;= dep[b])</span><br><span class="line">			res = <span class="built_in">max</span>(res, mx[i][a]), a = lca[i][a];</span><br><span class="line">	<span class="keyword">if</span>(a == b)</span><br><span class="line">		<span class="keyword">return</span> res;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">14</span>; ~i; i--) &#123;</span><br><span class="line">		<span class="keyword">if</span>(lca[i][a] != lca[i][b]) &#123;</span><br><span class="line">			res = <span class="built_in">max</span>(res, mx[i][a]); a = lca[i][a];</span><br><span class="line">			res = <span class="built_in">max</span>(res, mx[i][b]); b = lca[i][b];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">max</span>(&#123;res, mx[<span class="number">0</span>][a], mx[<span class="number">0</span>][b]&#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	EmiliaMyWife</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> n, m;</span><br><span class="line">	cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">		pa[i] = i, sz[i] = <span class="number">1</span>;</span><br><span class="line">	edge.<span class="built_in">resize</span>(n + <span class="number">1</span>);</span><br><span class="line">	<span class="function">vector&lt;ed&gt; <span class="title">edg</span><span class="params">(m)</span></span>;</span><br><span class="line">	<span class="function">vector&lt;<span class="keyword">bool</span>&gt; <span class="title">has</span><span class="params">(m)</span></span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++)</span><br><span class="line">		cin &gt;&gt; edg[i].a &gt;&gt; edg[i].b &gt;&gt; edg[i].c;</span><br><span class="line">	<span class="built_in">sort</span>(edg.<span class="built_in">begin</span>(), edg.<span class="built_in">end</span>());</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">		<span class="keyword">if</span>(<span class="built_in">uni</span>(edg[i].a, edg[i].b))</span><br><span class="line">			has[i] = <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">		<span class="keyword">if</span>(has[i]) &#123;</span><br><span class="line">			edge[edg[i].a].<span class="built_in">push_back</span>(&#123;edg[i].b, edg[i].c&#125;);</span><br><span class="line">			edge[edg[i].b].<span class="built_in">push_back</span>(&#123;edg[i].a, edg[i].c&#125;);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">		<span class="keyword">if</span>(!vis[i])</span><br><span class="line">			<span class="built_in">dfs</span>(i);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; <span class="number">15</span>; i++)</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++)</span><br><span class="line">			lca[i][j] = lca[i - <span class="number">1</span>][lca[i - <span class="number">1</span>][j]], mx[i][j] = <span class="built_in">max</span>(mx[i - <span class="number">1</span>][j], mx[i - <span class="number">1</span>][lca[i - <span class="number">1</span>][j]]);</span><br><span class="line">	<span class="keyword">int</span> q;</span><br><span class="line">	cin &gt;&gt; q;</span><br><span class="line">	<span class="keyword">while</span>(q--) &#123;</span><br><span class="line">		<span class="keyword">int</span> a, b;</span><br><span class="line">		cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line">		cout &lt;&lt; <span class="built_in">solve</span>(a, b) &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>TIOJ</tag>
        <tag>MST</tag>
        <tag>kruskal</tag>
        <tag>DSU</tag>
      </tags>
  </entry>
  <entry>
    <title>TIOJ-2038</title>
    <url>/TIOJ-2038/</url>
    <content><![CDATA[<p>金氏運動公司打算舉辦一場馬拉松比賽，為了締造亮眼的完成比賽時間，金氏運動公司打算選擇性地邀請選手參賽。分析過往的數據資料，金氏運動公司觀察到以下二個現象：<br>(a) 對於任何一位選手，如果愈多他的朋友參賽，則他就能跑得愈快，所以傾向於找一群選手使得彼此互相認識的情況很多。因為認識是雙向的，如果$P$認識$Q$，則$Q$認識$P$。所以當我們說$P$認識$Q$時，等同於表示$P$、$Q$兩位互相認識。<br/><br>(b) 如果參賽的選手當中，存在兩位選手$P$和$Q$彼此不認識，而且在參賽的選手當中無法找到$t$位選手$S_1,S_2,…S_t$($t$為任意大於0的整數)，使得$P$認識$S_1$，$S_2$認識$S_3$，…，$S_{t-1}$認識$S_t$，$S_t$認識$Q$，則比賽將會有嚴重的惡性競爭，所以需要避免這樣的狀況。</p>
<span id="more"></span>
<p>現在金氏運動公司手上有一份$N$位選手的名單以及一份顯示這$N$位選手彼此之間是否認識的表單，現在的任務是從這$N$位選手找出選手的子集合$S = {P_1, P_2, \ldots, P_{\lvert S \rvert} }$，使得$S$沒有惡性競爭的狀況，而且讓以下影響因子$F(S)$得到最大化，這影響因子的設計除了讓每位選手都認識夠多的參賽者，也兼顧了不讓參賽人數過少。<br/><br>$$F(S)=|S|\min_{1\le i\le |S|}D_i$$<br/><br>其中$D_i$表示選手$P_i$所認識的人當中，有多少人在子集合$S$裡面。在以下這個4位選手的例子中，選$S = {2, 3, 4}$比其他的選法有更高的$F(S)$。<br/><br><img src="https://tioj.ck.tp.edu.tw/pimgs/2038.png" alt="Select way"></p>
<p>$N\le 5000, M\le \frac{N\times (N-1)}{2}$</p>
<hr>
<p>這題簡單來說就是選取一個連通子集，且她們的最小度數*子集大小最大。<br>考慮枚舉最小的度數$D$由小到大，不斷將度數小於最小度數的點都拔掉，同時檢查她周遭的點是否會因為這個點被拔而跟著被拔。可以用bfs配合求拓樸排序那種手法處理，然而在找連通塊大小時得做一次dfs，總複雜度會退化成$O(N(N+M))$<del>(當然，可以直接砸可反悔的dsu)</del>。<br/><br>既然沒辦法好好維護連通塊大小，那就改成枚舉大到小，不斷把度數大於等於最小度數的都加進圖，直接用dsu維護最大連通大小，不過會遇到一個問題：該怎麼判斷加點的順序。<br>這就是這題有趣之處：事實上，直接將拔點順序反著插入會是好的。<br>詳細證明我也不會，大概就是拔點都是拔整個會影響的連通塊，插入也自然是插入整個連通塊。<br>所以就把拔點順序加進一個stack就好了<br>複雜度$O(N^2+M)$</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">--------------              |   /</span></span><br><span class="line"><span class="comment">      |                     |  /</span></span><br><span class="line"><span class="comment">      |                     | /</span></span><br><span class="line"><span class="comment">      |             *       |/          |    |         ------            *</span></span><br><span class="line"><span class="comment">      |                     |           |    |        /      \</span></span><br><span class="line"><span class="comment">      |             |       |\          |    |       |       |\          |</span></span><br><span class="line"><span class="comment">   \  |             |       | \         |    |       |       | \         |</span></span><br><span class="line"><span class="comment">    \ |             |       |  \        |    |        \     /   \        |</span></span><br><span class="line"><span class="comment">     V              |       |   \        \__/|         -----     \       |</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EmiliaMyWife ios::sync_with_stdio(0); cin.tie(NULL);</span></span><br><span class="line"><span class="comment">/*-----------------------------------------------------------------------------------------------------*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e4</span>;</span><br><span class="line"><span class="keyword">int</span> pa[N], sz[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fnd</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123; <span class="keyword">return</span> pa[x] == x ? pa[x] : pa[x] = <span class="built_in">fnd</span>(pa[x]); &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">uni</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span>((a = <span class="built_in">fnd</span>(a)) == (b = <span class="built_in">fnd</span>(b)))</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	<span class="keyword">if</span>(sz[a] &gt; sz[b])</span><br><span class="line">		<span class="built_in">swap</span>(a, b);</span><br><span class="line">	sz[b] += sz[a];</span><br><span class="line">	pa[a] = b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	EmiliaMyWife</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> n, m, ans = <span class="number">0</span>;</span><br><span class="line">	cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">		pa[i] = i, sz[i] = <span class="number">1</span>;</span><br><span class="line">		</span><br><span class="line">	vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">edge</span>(n + <span class="number">1</span>);</span><br><span class="line">	<span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">cnt</span><span class="params">(n + <span class="number">1</span>)</span>, <span class="title">rcnt</span><span class="params">(n + <span class="number">1</span>)</span>, <span class="title">has</span><span class="params">(n + <span class="number">1</span>)</span></span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>, a, b; i &lt; m; i++)</span><br><span class="line">		cin &gt;&gt; a &gt;&gt; b, cnt[a]++, cnt[b]++, edge[a].<span class="built_in">push_back</span>(b), edge[b].<span class="built_in">push_back</span>(a);</span><br><span class="line">		</span><br><span class="line">	stack&lt;<span class="keyword">int</span>&gt; owo;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; i++) &#123;</span><br><span class="line">		queue&lt;<span class="keyword">int</span>&gt; cc;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">			<span class="keyword">if</span>(has[j])</span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">			<span class="keyword">if</span>(cnt[j] &lt;= i) &#123;</span><br><span class="line">				cc.<span class="built_in">push</span>(j);</span><br><span class="line">				has[j] = <span class="number">1</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">while</span>(!cc.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">			<span class="keyword">int</span> v = cc.<span class="built_in">front</span>();</span><br><span class="line">			owo.<span class="built_in">push</span>(v);</span><br><span class="line">			cc.<span class="built_in">pop</span>();</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> u : edge[v]) &#123;</span><br><span class="line">				<span class="keyword">if</span>(has[u])</span><br><span class="line">					<span class="keyword">continue</span>;</span><br><span class="line">				cnt[u]--;</span><br><span class="line">				<span class="keyword">if</span>(cnt[u] &lt;= i) &#123;</span><br><span class="line">					cc.<span class="built_in">push</span>(u);</span><br><span class="line">					has[u] = <span class="number">1</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span>(!owo.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">		<span class="keyword">int</span> v = owo.<span class="built_in">top</span>();</span><br><span class="line">		owo.<span class="built_in">pop</span>();</span><br><span class="line">		has[v] = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> u : edge[v]) &#123;</span><br><span class="line">			<span class="keyword">if</span>(has[u])</span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">			<span class="built_in">uni</span>(u, v);</span><br><span class="line">			rcnt[v]++;</span><br><span class="line">		&#125;</span><br><span class="line">		ans = <span class="built_in">max</span>(ans, rcnt[v] * sz[<span class="built_in">fnd</span>(v)]);</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; ans &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>Competitive Programming</tag>
        <tag>TIOJ</tag>
      </tags>
  </entry>
  <entry>
    <title>TIOJ-1554</title>
    <url>/TIOJ-1554/</url>
    <content><![CDATA[<p>給一個$N\times N$的矩陣，取$N$個數字滿足他們都在不同行不同列，求最大的數字乘積。</p>
<span id="more"></span>
<p>$N\le 20, a_{ij}\ge 0$</p>
<hr>
<p>我有點把題目過度簡化，不過方向就是這樣，剩下的只差在實作細節。</p>
<h3 id="mathcal-O-N-22-N-solution"><a href="#mathcal-O-N-22-N-solution" class="headerlink" title="$\mathcal{O}(N^22^N)$ solution"></a>$\mathcal{O}(N^22^N)$ solution</h3><p>注意N很小，所以可以直接枚舉目前要拿第幾行，且每個數字是否被拿(位元DP)。<br>然後每一行再枚舉要拿哪一列，這樣會是$\mathcal{O}(N^22^N)$。<br/><br>附上TLE的code</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">--------------              |   /</span></span><br><span class="line"><span class="comment">      |                     |  /</span></span><br><span class="line"><span class="comment">      |                     | /</span></span><br><span class="line"><span class="comment">      |             *       |/          |    |         ------            *</span></span><br><span class="line"><span class="comment">      |                     |           |    |        /      \</span></span><br><span class="line"><span class="comment">      |             |       |\          |    |       |       |\          |</span></span><br><span class="line"><span class="comment">   \  |             |       | \         |    |       |       | \         |</span></span><br><span class="line"><span class="comment">    \ |             |       |  \        |    |        \     /   \        |</span></span><br><span class="line"><span class="comment">     V              |       |   \        \__/|         -----     \       |</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EmiliaMyWife ios::sync_with_stdio(0); cin.tie(NULL);</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mem(i,j) memset(i,j,sizeof (i));</span></span><br><span class="line"><span class="keyword">using</span> ll = <span class="keyword">int64_t</span>;</span><br><span class="line"><span class="keyword">using</span> ull = <span class="keyword">uint64_t</span>;</span><br><span class="line"><span class="keyword">using</span> ld = <span class="keyword">long</span> <span class="keyword">double</span>;</span><br><span class="line"><span class="keyword">using</span> uint = <span class="keyword">uint32_t</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> EPS  = <span class="number">1e-8</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF     = <span class="number">0x3F3F3F3F</span>;</span><br><span class="line"><span class="keyword">const</span> ll LINF     = <span class="number">4611686018427387903</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MOD     = <span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="comment">/*-----------------------------------------------------------------------------------------------------*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	EmiliaMyWife</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">int</span> n;</span><br><span class="line">	cin &gt;&gt; n;</span><br><span class="line">	<span class="function">vector&lt;<span class="keyword">double</span>&gt; <span class="title">dp</span><span class="params">(<span class="number">1</span> &lt;&lt; n)</span></span>;</span><br><span class="line">	vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">arr</span>(n, vector&lt;<span class="keyword">int</span>&gt;(n));</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++)</span><br><span class="line">			cin &gt;&gt; arr[i][j];</span><br><span class="line">	dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j = (<span class="number">1</span> &lt;&lt; n) - <span class="number">1</span>; j; j--)</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; n; k++)</span><br><span class="line">				<span class="keyword">if</span>((j &gt;&gt; k) &amp; <span class="number">1</span>)</span><br><span class="line">					dp[j] = <span class="built_in">max</span>(dp[j], dp[j ^ (<span class="number">1</span> &lt;&lt; k)] * arr[i][k] / <span class="number">100</span>);</span><br><span class="line">	cout &lt;&lt; fixed &lt;&lt; <span class="built_in">setprecision</span>(<span class="number">2</span>) &lt;&lt; dp[(<span class="number">1</span> &lt;&lt; n) - <span class="number">1</span>] * <span class="number">100</span> &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="mathcal-O-N2-N-solution"><a href="#mathcal-O-N2-N-solution" class="headerlink" title="$\mathcal{O}(N2^N)$ solution"></a>$\mathcal{O}(N2^N)$ solution</h3><p>注意到在枚舉到第$i$列時，我們只需要知道已經取$i$個數字的狀態(也就是位元表示中，1的數量剛好$i$個)，所以可以用__builtin_pop_count()預處理。<br/><br>這樣整個枚舉過程所有$2^N$的狀態只會被枚舉一次，複雜度$\mathcal{O}((N+2^N)N)=\mathcal{O}(N2^N)$。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">--------------              |   /</span></span><br><span class="line"><span class="comment">      |                     |  /</span></span><br><span class="line"><span class="comment">      |                     | /</span></span><br><span class="line"><span class="comment">      |             *       |/          |    |         ------            *</span></span><br><span class="line"><span class="comment">      |                     |           |    |        /      \</span></span><br><span class="line"><span class="comment">      |             |       |\          |    |       |       |\          |</span></span><br><span class="line"><span class="comment">   \  |             |       | \         |    |       |       | \         |</span></span><br><span class="line"><span class="comment">    \ |             |       |  \        |    |        \     /   \        |</span></span><br><span class="line"><span class="comment">     V              |       |   \        \__/|         -----     \       |</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EmiliaMyWife ios::sync_with_stdio(0); cin.tie(NULL);</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mem(i,j) memset(i,j,sizeof (i));</span></span><br><span class="line"><span class="keyword">using</span> ll = <span class="keyword">int64_t</span>;</span><br><span class="line"><span class="keyword">using</span> ull = <span class="keyword">uint64_t</span>;</span><br><span class="line"><span class="keyword">using</span> ld = <span class="keyword">long</span> <span class="keyword">double</span>;</span><br><span class="line"><span class="keyword">using</span> uint = <span class="keyword">uint32_t</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> EPS  = <span class="number">1e-8</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF     = <span class="number">0x3F3F3F3F</span>;</span><br><span class="line"><span class="keyword">const</span> ll LINF     = <span class="number">4611686018427387903</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MOD     = <span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="comment">/*-----------------------------------------------------------------------------------------------------*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	EmiliaMyWife</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">int</span> n;</span><br><span class="line">	cin &gt;&gt; n;</span><br><span class="line">	<span class="function">vector&lt;<span class="keyword">double</span>&gt; <span class="title">dp</span><span class="params">(<span class="number">1</span> &lt;&lt; n)</span></span>;</span><br><span class="line">	vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">arr</span>(n, vector&lt;<span class="keyword">int</span>&gt;(n)), <span class="built_in">has</span>(n);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++)</span><br><span class="line">			cin &gt;&gt; arr[i][j];</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; (<span class="number">1</span> &lt;&lt; n); i++)</span><br><span class="line">		has[__builtin_popcount(i) - <span class="number">1</span>].<span class="built_in">push_back</span>(i);</span><br><span class="line">	dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j : has[i])</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; n; k++)</span><br><span class="line">				<span class="keyword">if</span>((j &gt;&gt; k) &amp; <span class="number">1</span>)</span><br><span class="line">					dp[j] = <span class="built_in">max</span>(dp[j], dp[j ^ (<span class="number">1</span> &lt;&lt; k)] * arr[i][k] / <span class="number">100</span>);</span><br><span class="line">	cout &lt;&lt; fixed &lt;&lt; <span class="built_in">setprecision</span>(<span class="number">2</span>) &lt;&lt; dp[(<span class="number">1</span> &lt;&lt; n) - <span class="number">1</span>] * <span class="number">100</span> &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>TIOJ</tag>
        <tag>bitmask</tag>
        <tag>dp</tag>
      </tags>
  </entry>
  <entry>
    <title>manacher-algorithm</title>
    <url>/manacher-algorithm/</url>
    <content><![CDATA[<p>教學有空補<br>目前只有模板</p>
<span id="more"></span>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">manacher</span><span class="params">(string s)</span> </span>&#123; <span class="comment">//return max palindrome substring length in O(|S|)</span></span><br><span class="line">	<span class="keyword">int</span> n = <span class="number">2</span> * s.<span class="built_in">size</span>() + <span class="number">1</span>, ans = <span class="number">0</span>;</span><br><span class="line">	<span class="function">string <span class="title">t</span><span class="params">(n, <span class="number">0</span>)</span></span>;<span class="comment">//new string</span></span><br><span class="line">	<span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">len</span><span class="params">(n)</span></span>;<span class="comment">//len[i]: max length when mid at i</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">		<span class="keyword">if</span>(i &amp; <span class="number">1</span>)</span><br><span class="line">			t[i] = s[i / <span class="number">2</span>];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>, l = <span class="number">0</span>, r = <span class="number">-1</span>; i &lt; n; i++) &#123;</span><br><span class="line">		len[i] = (i &lt;= r ? <span class="built_in">min</span>(len[<span class="number">2</span> * l - i], r - i) : <span class="number">0</span>);</span><br><span class="line">		<span class="keyword">while</span>(i - len[i] &gt;= <span class="number">0</span> &amp;&amp; i + len[i] &lt; n &amp;&amp; t[i - len[i]] == t[i + len[i]])</span><br><span class="line">			len[i]++;</span><br><span class="line">		len[i]--;</span><br><span class="line">		ans = <span class="built_in">max</span>(ans, len[i]);</span><br><span class="line">		<span class="keyword">if</span>(i + len[i] &gt; r)</span><br><span class="line">			l = i, r = i + len[i];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>練習題</p>
<ul>
<li><a href="https://tioj.ck.tp.edu.tw/problems/1276">TIOJ-1276</a></li>
<li><a href="https://codeforces.com/problemset/problem/1326/D2">CF-1326D</a></li>
</ul>
]]></content>
      <tags>
        <tag>string</tag>
        <tag>manacher</tag>
        <tag>template</tag>
      </tags>
  </entry>
  <entry>
    <title>TIOJ-1915</title>
    <url>/TIOJ-1915/</url>
    <content><![CDATA[<p>定義一張圖$G$的代價為：<br>$$\max_{u\in G} |{v|v&gt;u\wedge (v, u)\text{ is adjancent}}|$$<br/><br>現在給你一張圖，求原圖代價與重新分配點編號後的最小代價。</p>
<span id="more"></span>
<p>$N\le 5\times 10^5, E\le 8\times 10^5$，無重邊，無自環，不保證連通。</p>
<hr>
<p>對於節點0來說，他所在的相鄰點數量就會是他自身的代價，而我們要讓他盡量小，且他相鄰的點都不會將他視為代價。<br>從0到$N-1$，不斷選擇當前度數最少的點，且將該點從圖上拔掉(相鄰點的度數都-1)。<br/><br>可以用heap維護此操作，時間複雜度$O((N+E)log(N+E))$。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">--------------              |   /</span></span><br><span class="line"><span class="comment">      |                     |  /</span></span><br><span class="line"><span class="comment">      |                     | /</span></span><br><span class="line"><span class="comment">      |             *       |/          |    |         ------            *</span></span><br><span class="line"><span class="comment">      |                     |           |    |        /      \</span></span><br><span class="line"><span class="comment">      |             |       |\          |    |       |       |\          |</span></span><br><span class="line"><span class="comment">   \  |             |       | \         |    |       |       | \         |</span></span><br><span class="line"><span class="comment">    \ |             |       |  \        |    |        \     /   \        |</span></span><br><span class="line"><span class="comment">     V              |       |   \        \__/|         -----     \       |</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EmiliaMyWife ios::sync_with_stdio(0); cin.tie(NULL);</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mem(i,j) memset(i,j,sizeof (i));</span></span><br><span class="line"><span class="keyword">using</span> ll = <span class="keyword">int64_t</span>;</span><br><span class="line"><span class="keyword">using</span> ull = <span class="keyword">uint64_t</span>;</span><br><span class="line"><span class="keyword">using</span> ld = <span class="keyword">long</span> <span class="keyword">double</span>;</span><br><span class="line"><span class="keyword">using</span> uint = <span class="keyword">uint32_t</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> EPS  = <span class="number">1e-8</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF     = <span class="number">0x3F3F3F3F</span>;</span><br><span class="line"><span class="keyword">const</span> ll LINF     = <span class="number">4611686018427387903</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MOD     = <span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="comment">/*-----------------------------------------------------------------------------------------------------*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	EmiliaMyWife</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> t;</span><br><span class="line">	cin &gt;&gt; t;</span><br><span class="line">	<span class="keyword">while</span>(t--) &#123;</span><br><span class="line">		<span class="keyword">int</span> n, m;</span><br><span class="line">		cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">		vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">edge</span>(n);</span><br><span class="line">		<span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">cnt</span><span class="params">(n)</span></span>;</span><br><span class="line">		<span class="function">vector&lt;<span class="keyword">bool</span>&gt; <span class="title">vis</span><span class="params">(n)</span></span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>, a, b; i &lt; m; i++)</span><br><span class="line">			cin &gt;&gt; a &gt;&gt; b, edge[a].<span class="built_in">push_back</span>(b), edge[b].<span class="built_in">push_back</span>(a), cnt[a]++, cnt[b]++;</span><br><span class="line">		<span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">		priority_queue&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;, vector&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt;, greater&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt;&gt; pq;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">			<span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> a : edge[i])</span><br><span class="line">				<span class="keyword">if</span>(a &gt; i)</span><br><span class="line">					res++;</span><br><span class="line">			ans = <span class="built_in">max</span>(ans, res);</span><br><span class="line">			pq.<span class="built_in">push</span>(&#123;cnt[i], i&#125;);</span><br><span class="line">		&#125;</span><br><span class="line">		cout &lt;&lt; ans &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">		ans = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">while</span>(!pq.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">			<span class="keyword">auto</span> [a, b] = pq.<span class="built_in">top</span>();</span><br><span class="line">			pq.<span class="built_in">pop</span>();</span><br><span class="line">			<span class="keyword">if</span>(vis[b])</span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">			vis[b] = <span class="number">1</span>;</span><br><span class="line">			ans = <span class="built_in">max</span>(ans, a);</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> x : edge[b]) &#123;</span><br><span class="line">				<span class="keyword">if</span>(!vis[x]) &#123;</span><br><span class="line">					cnt[x]--;</span><br><span class="line">					pq.<span class="built_in">push</span>(&#123;cnt[x], x&#125;);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		cout &lt;&lt; ans &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>這解跑得好慢orz，不知道有沒有常數小的寫法。</p>
]]></content>
      <tags>
        <tag>TIOJ</tag>
        <tag>greedy</tag>
        <tag>heap</tag>
      </tags>
  </entry>
  <entry>
    <title>TIOJ-2146</title>
    <url>/TIOJ-2146/</url>
    <content><![CDATA[<p>給定$N, M$，求一張滿足所有$M$筆條件(點$i$最後要到點$j$)且有$N$條縱線的<a href="https://zh.wikipedia.org/wiki/%E9%AC%BC%E8%85%B3%E5%9C%96#">鬼腳圖</a>最少需要幾條橫線。</p>
<span id="more"></span>
<p>$N\le 10^5, M\le N$</p>
<hr>
<p>這問題好難&gt;&lt; 問別人才會。<br>定義$p$數列為$p_i$代表$i$最後會走到$p_i$，無任何橫線時$p_i=i$。<br/><br>考慮以下greedy策略：由最底層不斷往上加橫線，此時在$(i, i+1)$間加一條橫線等價於交換$(p_i,p_{i+1})$。<br>這樣就能知道，如果要讓$p$變成題目要求，等價於將題目要求進行泡沫排序，所以至少要交換逆序數對次。<br>至於題目未指定的條件，則將$1\sim N$分別指定給他們，這樣逆序數對數量會最少。<br/><br>逆序數對可用BIT或Merge sort處理，時間複雜度$\mathcal{O}(NlogN)$。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">--------------              |   /</span></span><br><span class="line"><span class="comment">      |                     |  /</span></span><br><span class="line"><span class="comment">      |                     | /</span></span><br><span class="line"><span class="comment">      |             *       |/          |    |         ------            *</span></span><br><span class="line"><span class="comment">      |                     |           |    |        /      \</span></span><br><span class="line"><span class="comment">      |             |       |\          |    |       |       |\          |</span></span><br><span class="line"><span class="comment">   \  |             |       | \         |    |       |       | \         |</span></span><br><span class="line"><span class="comment">    \ |             |       |  \        |    |        \     /   \        |</span></span><br><span class="line"><span class="comment">     V              |       |   \        \__/|         -----     \       |</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EmiliaMyWife ios::sync_with_stdio(0); cin.tie(NULL);</span></span><br><span class="line"><span class="keyword">using</span> ll = <span class="keyword">int64_t</span>;</span><br><span class="line"><span class="comment">/*-----------------------------------------------------------------------------------------------------*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">5e5</span>+<span class="number">25</span>;</span><br><span class="line">ll bit[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mod</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(; p&lt;N; p+=p&amp;-p)</span><br><span class="line">		bit[p] += val;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">sum</span><span class="params">(<span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">	ll res = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(; p; p-=p&amp;-p)</span><br><span class="line">		res += bit[p];</span><br><span class="line">	<span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	EmiliaMyWife</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">int</span> n, m;</span><br><span class="line">	cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">	<span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">arr</span><span class="params">(n+<span class="number">1</span>)</span>, <span class="title">vis</span><span class="params">(n+<span class="number">1</span>)</span></span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>, a, b; i &lt;= m; i++)</span><br><span class="line">		cin &gt;&gt; a &gt;&gt; b, arr[a] = b, vis[b] = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">int</span> it = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">		<span class="keyword">if</span>(arr[i])</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		<span class="keyword">while</span>(vis[it])</span><br><span class="line">			it++;</span><br><span class="line">		arr[i] = it++;</span><br><span class="line">	&#125;</span><br><span class="line">	ll ans = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">		ans += <span class="built_in">sum</span>(n)-<span class="built_in">sum</span>(arr[i]);</span><br><span class="line">		<span class="built_in">mod</span>(arr[i], <span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; ans &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>TIOJ</tag>
        <tag>fenwick tree</tag>
      </tags>
  </entry>
  <entry>
    <title>TIOJ-1658</title>
    <url>/TIOJ-1658/</url>
    <content><![CDATA[<p>給$n, b$，畫出邊長為$n$的實心(b=1)或空心(b=0)三角形。</p>
<span id="more"></span>
<p>$n, b\le 20$</p>
<hr>
<blockquote>
<p>圖形去原題看範測</p>
</blockquote>
<p>畫圖形一直都是練習語法的題目中算困難的了。<br>基本上要看出規律:由上開始第$i$行由1個*和不等的*(如果實心)和1個*組成，而每行都會剛好有$2\times i - 1$個*。<br/><br>特判一下第一行跟最後一行就好</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">--------------              |   /</span></span><br><span class="line"><span class="comment">      |                     |  /</span></span><br><span class="line"><span class="comment">      |                     | /</span></span><br><span class="line"><span class="comment">      |             *       |/          |    |         ------            *</span></span><br><span class="line"><span class="comment">      |                     |           |    |        /      \</span></span><br><span class="line"><span class="comment">      |             |       |\          |    |       |       |\          |</span></span><br><span class="line"><span class="comment">   \  |             |       | \         |    |       |       | \         |</span></span><br><span class="line"><span class="comment">    \ |             |       |  \        |    |        \     /   \        |</span></span><br><span class="line"><span class="comment">     V              |       |   \        \__/|         -----     \       |</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n, b;</span><br><span class="line">	<span class="keyword">while</span>(cin &gt;&gt; n &gt;&gt; b) &#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n - i - <span class="number">1</span>; j++)</span><br><span class="line">				cout &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">			cout &lt;&lt; <span class="string">&#x27;*&#x27;</span>;</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; (i &lt;&lt; <span class="number">1</span>) - <span class="number">1</span>; j++)</span><br><span class="line">				cout &lt;&lt; (b||i==n<span class="number">-1</span> ? <span class="string">&#x27;*&#x27;</span> : <span class="string">&#x27; &#x27;</span>);</span><br><span class="line">			<span class="keyword">if</span>(i)</span><br><span class="line">				cout &lt;&lt; <span class="string">&#x27;*&#x27;</span>;</span><br><span class="line">			cout &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>TIOJ</tag>
        <tag>Syntax</tag>
      </tags>
  </entry>
  <entry>
    <title>TIOJ-2147</title>
    <url>/TIOJ-2147/</url>
    <content><![CDATA[<p>哈卡雜貨店裡，只有一排貨架，擺放著各式商品。然而裡頭的哈卡老闆有強迫症，他想要讓這個貨架的商品價格，從商品編號1~N，至少有K件商品價格是按序遞增的。哈卡是不會調降價錢的，哈卡也想把力氣省下來，哈卡決定以某件商品加一元的方式，直到貨架上的商品有至少K個按序遞增。<br>試問哈卡最少需要做幾次“加某件商品一元”這個動作，才能讓貨架上的N件商品至少有K件的價格按序遞增？<br>以上題敘的意思也就是：<br>給你一個長度為N的序列，你可以對任一項加一，求最少要加幾次才存在一個子序列長度為K，且值非嚴格遞增。(子序列是不用連續的)</p>
<span id="more"></span>
<p>$K\le N\le 200, a_i\le 10^9$</p>
<hr>
<p>這題子測資切得蠻好的 所以我應該會分開寫</p>
<h1 id="subtask1-N-K"><a href="#subtask1-N-K" class="headerlink" title="subtask1: $N=K$"></a>subtask1: $N=K$</h1><p>等價於要讓整個序列變得非嚴格遞增<br>就只要貪心的把當前項加到不小於前面的就好<br>$\mathcal{O}(N)$<br/></p>
<h1 id="subtask2-N-le-40"><a href="#subtask2-N-le-40" class="headerlink" title="subtask2: $N\le 40$"></a>subtask2: $N\le 40$</h1><p>這筆我不知道要幹嘛 跳過</p>
<h1 id="subtask3-a-i-le-200"><a href="#subtask3-a-i-le-200" class="headerlink" title="subtask3: $a_i\le 200$"></a>subtask3: $a_i\le 200$</h1><p>考慮$dp[K][C][N]$代表以第$N$個為最後一項，目前長度為$K$，且已經把$a_N$弄成$C$了<br/><br>這樣轉移式就是<br>$$dp[K][C][N]=\min_{A\le C, B&lt;N} dp[K-1][A][B]+C-a_N (\text{ if } C&gt;a_N)$$<br>只要透過適當轉移順序 順便紀錄點東西就能做到$\mathcal{O}(1)$轉移<br/><br>所以複雜度$\mathcal{O}(KNC)$<br/></p>
<h1 id="subtask-4-No-other-constraints"><a href="#subtask-4-No-other-constraints" class="headerlink" title="subtask 4: No other constraints"></a>subtask 4: No other constraints</h1><p>直接拿subtask3的dp 把序列給離散化後就能變回第三題的樣子 離散化複雜度$O(NlogN)$<br/><br>整體複雜度$\mathcal{O}(NlogN+KN^2)$</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">--------------              |   /</span></span><br><span class="line"><span class="comment">      |                     |  /</span></span><br><span class="line"><span class="comment">      |                     | /</span></span><br><span class="line"><span class="comment">      |             *       |/          |    |         ------            *</span></span><br><span class="line"><span class="comment">      |                     |           |    |        /      \</span></span><br><span class="line"><span class="comment">      |             |       |\          |    |       |       |\          |</span></span><br><span class="line"><span class="comment">   \  |             |       | \         |    |       |       | \         |</span></span><br><span class="line"><span class="comment">    \ |             |       |  \        |    |        \     /   \        |</span></span><br><span class="line"><span class="comment">     V              |       |   \        \__/|         -----     \       |</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EmiliaMyWife ios::sync_with_stdio(0); cin.tie(NULL);</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mem(i,j) memset(i,j,sizeof (i));</span></span><br><span class="line"><span class="keyword">using</span> ll = <span class="keyword">int64_t</span>;</span><br><span class="line"><span class="keyword">using</span> ull = <span class="keyword">uint64_t</span>;</span><br><span class="line"><span class="keyword">using</span> ld = <span class="keyword">long</span> <span class="keyword">double</span>;</span><br><span class="line"><span class="keyword">using</span> uint = <span class="keyword">uint32_t</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> EPS  = <span class="number">1e-8</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF     = <span class="number">0x3F3F3F3F</span>;</span><br><span class="line"><span class="keyword">const</span> ll LINF     = <span class="number">4611686018427387903</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MOD     = <span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="comment">/*-----------------------------------------------------------------------------------------------------*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">201</span>;</span><br><span class="line">ll dp[N][N][N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	EmiliaMyWife</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">int</span> n, k;</span><br><span class="line">	ll ans = LINF;</span><br><span class="line">	cin &gt;&gt; n &gt;&gt; k;</span><br><span class="line">	<span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">arr</span><span class="params">(n + <span class="number">1</span>)</span>, <span class="title">owo</span><span class="params">(n)</span></span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">		cin &gt;&gt; arr[i + <span class="number">1</span>], owo[i] = arr[i + <span class="number">1</span>];</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++)</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; N; j++)</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; N; k++)</span><br><span class="line">				dp[i][j][k] = LINF;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">sort</span>(owo.<span class="built_in">begin</span>(), owo.<span class="built_in">end</span>()); owo.<span class="built_in">erase</span>(<span class="built_in">unique</span>(owo.<span class="built_in">begin</span>(), owo.<span class="built_in">end</span>()), owo.<span class="built_in">end</span>());</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> len = <span class="number">1</span>; len &lt;= k; len++) &#123;</span><br><span class="line">		<span class="function">vector&lt;ll&gt; <span class="title">mn</span><span class="params">(n + <span class="number">1</span>, LINF)</span></span>;</span><br><span class="line">		<span class="keyword">if</span>(len == <span class="number">1</span>)</span><br><span class="line">			mn[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; owo.<span class="built_in">size</span>(); j++) &#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">				<span class="keyword">if</span>(owo[j] &gt;= arr[i])</span><br><span class="line">					dp[i][j][len] = mn[i - <span class="number">1</span>] + owo[j] - arr[i];</span><br><span class="line">				mn[i] = <span class="built_in">min</span>(&#123;mn[i], mn[i - <span class="number">1</span>], dp[i][j][len - <span class="number">1</span>]&#125;);</span><br><span class="line">				<span class="keyword">if</span>(len == k)</span><br><span class="line">					ans = <span class="built_in">min</span>(ans, dp[i][j][len]);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; ans &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>TIOJ</tag>
        <tag>dp</tag>
      </tags>
  </entry>
  <entry>
    <title>suffix-array</title>
    <url>/suffix-array/</url>
    <content><![CDATA[<h1 id="用途"><a href="#用途" class="headerlink" title="用途"></a>用途</h1><p>考慮”ababcad”<br>那麼就可以分成7個這樣的字串：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0 - &quot;ababcad&quot;</span><br><span class="line">1 - &quot;babcad&quot;</span><br><span class="line">2 - &quot;abcad&quot;</span><br><span class="line">3 - &quot;bcad&quot;</span><br><span class="line">4 - &quot;cad&quot;</span><br><span class="line">5 - &quot;ad&quot;</span><br><span class="line">6 - &quot;d&quot;</span><br></pre></td></tr></table></figure>
<p>然後再把這7個字串按照ASCII碼的順序排序，變成這樣：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0 - &quot;ababcad&quot;</span><br><span class="line">2 - &quot;abcad&quot;</span><br><span class="line">5 - &quot;ad&quot;</span><br><span class="line">1 - &quot;babcad&quot;</span><br><span class="line">3 - &quot;bcad&quot;</span><br><span class="line">4 - &quot;cad&quot;</span><br><span class="line">6 - &quot;d&quot;</span><br></pre></td></tr></table></figure>
<p>所以順序就是0251346</p>
<span id="more"></span>
<h1 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h1><p>考慮倍增<br>先把字串在後面補個極小字元(假設$)，更後面的就亂擺(方便起見就讓它變成環吧)，變成</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0 - &quot;ababcad$&quot;</span><br><span class="line">1 - &quot;babcad$a&quot;</span><br><span class="line">2 - &quot;abcad$ab&quot;</span><br><span class="line">3 - &quot;bcad$aba&quot;</span><br><span class="line">4 - &quot;cad$abab&quot;</span><br><span class="line">5 - &quot;ad$ababc&quot;</span><br><span class="line">6 - &quot;d$ababca&quot;</span><br><span class="line">7 - &quot;$ababcad&quot;</span><br></pre></td></tr></table></figure>
<p>可以發現大小不會變，因為有一個極小字元。<br>然後先取第一個字元</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0 - a</span><br><span class="line">1 - b</span><br><span class="line">2 - a</span><br><span class="line">3 - b</span><br><span class="line">4 - c</span><br><span class="line">5 - a</span><br><span class="line">6 - d</span><br><span class="line">7 - $</span><br></pre></td></tr></table></figure>
<p>直接用std::sort $\mathcal{O}(NlogN)$後再編號進rk陣列(可以想成離散化)。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">7 - $ rk[7]=0</span><br><span class="line">0 - a rk[0]=1</span><br><span class="line">2 - a rk[2]=1</span><br><span class="line">5 - a rk[5]=1</span><br><span class="line">1 - b rk[1]=2</span><br><span class="line">3 - b rk[3]=2</span><br><span class="line">4 - c rk[4]=3</span><br><span class="line">6 - d rk[5]=4</span><br></pre></td></tr></table></figure>
<p>之後要怎麼從長度$2^k$轉移成$2^{k+1}$倍呢?<br>把他們給變成一個pair(rk[$i$], rk[$i + 2^k$])。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">7 - $a rk[7]=0 (0, 1) // (rk[7], rk[0])</span><br><span class="line">0 - ab rk[0]=1 (1, 2)</span><br><span class="line">2 - ab rk[2]=1 (1, 2)</span><br><span class="line">5 - ab rk[5]=1 (1, 3)</span><br><span class="line">1 - ba rk[1]=2 (2, 1)</span><br><span class="line">3 - bc rk[3]=2 (2, 3)</span><br><span class="line">4 - ca rk[4]=3 (3, 1)</span><br><span class="line">6 - d$ rk[6]=3 (4, 0)</span><br></pre></td></tr></table></figure>
<p>然後使用std::sort排序他們。把排序的結果寫進rk</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">7 - $a rk[7]=0 (0, 1)</span><br><span class="line">0 - ab rk[0]=1 (1, 2)</span><br><span class="line">2 - ab rk[2]=1 (1, 2)</span><br><span class="line">5 - ad rk[5]=2 (1, 3)</span><br><span class="line">1 - ba rk[1]=3 (2, 1)</span><br><span class="line">3 - bc rk[3]=4 (2, 3)</span><br><span class="line">4 - ca rk[4]=5 (3, 1)</span><br><span class="line">6 - d$ rk[6]=6 (4, 0)</span><br></pre></td></tr></table></figure>
<p>再蓋pair</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">7 - $aba rk[7]=0 (0, 3) //(rk[7], rk[1])</span><br><span class="line">0 - abab rk[0]=1 (1, 1)</span><br><span class="line">2 - abca rk[2]=1 (1, 5)</span><br><span class="line">5 - ad$a rk[5]=2 (2, 0)</span><br><span class="line">1 - babc rk[1]=3 (3, 4)</span><br><span class="line">3 - bcad rk[3]=4 (4, 2)</span><br><span class="line">4 - cad$ rk[4]=5 (5, 6)</span><br><span class="line">6 - d$ab rk[6]=6 (6, 1)</span><br></pre></td></tr></table></figure>
<p>然後排序… 做logn次<br>最後得出的順序70251346，扣掉最左邊新加的，0251346即是答案。<br>複雜度:logn次中，每次排序都$\mathcal{O}(nlogn)$，所以是$\mathcal{O}(nlog^2n)$。</p>
<h1 id="優化"><a href="#優化" class="headerlink" title="優化"></a>優化</h1><ol>
<li>因為只是要對pair來sort，且pair的值域只有$[0,n]$，因此可以先排序右邊再排序左邊(radix sort)，複雜度$O(nlogn)$。</li>
<li>考慮到pair(rk[$i$], rk[$i+2^k$])中，rk[$i$]已經排序過了，所以可以改成pair(rk[$i-2^k$], rk[$i$])，這樣只需要排序左邊(counting sort)，常數優化。</li>
</ol>
<h1 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h1><p>回傳的tmp沒拔掉最左邊新加的，然後我直接拿<a href="https://tioj.ck.tp.edu.tw/problems/1497">TIOJ-1497</a>的code來用</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EmiliaMyWife ios::sync_with_stdio(0); cin.tie(NULL);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*-----------------------------------------------------------------------------------------------------*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">csort</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt; &amp;tmp, vector&lt;<span class="keyword">int</span>&gt; &amp;rk)</span> </span>&#123;<span class="comment">//counting sort</span></span><br><span class="line">	<span class="keyword">int</span> n = tmp.<span class="built_in">size</span>();</span><br><span class="line">	vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">has</span>(n);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> a : tmp)</span><br><span class="line">		has[rk[a]].<span class="built_in">push_back</span>(a);</span><br><span class="line">	<span class="keyword">int</span> it = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> &amp;a : has[i])</span><br><span class="line">			tmp[it++] = a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">solve</span><span class="params">(string &amp;s)</span> </span>&#123;</span><br><span class="line">	s.<span class="built_in">push_back</span>(<span class="number">0</span>);<span class="comment">//smallest character</span></span><br><span class="line">	<span class="keyword">int</span> n = s.<span class="built_in">size</span>(), k = __lg(n) + <span class="number">1</span>;</span><br><span class="line">	<span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">rk</span><span class="params">(n)</span>, <span class="title">tmp</span><span class="params">(n)</span>, <span class="title">nrk</span><span class="params">(n)</span></span>;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">		tmp[i] = i;</span><br><span class="line">	<span class="built_in">sort</span>(tmp.<span class="built_in">begin</span>(), tmp.<span class="built_in">end</span>(), [&amp;](<span class="keyword">auto</span> a, <span class="keyword">auto</span> b) &#123;</span><br><span class="line">		<span class="keyword">return</span> s[a] &lt; s[b];</span><br><span class="line">	&#125;);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>, cnt = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">		rk[tmp[i]] = cnt;</span><br><span class="line">		<span class="keyword">if</span>(i + <span class="number">1</span> &lt; n &amp;&amp; s[tmp[i]] != s[tmp[i + <span class="number">1</span>]])</span><br><span class="line">			cnt++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; k; j++) &#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">			tmp[i] = (tmp[i] - (<span class="number">1</span> &lt;&lt; j) % n + n) % n;</span><br><span class="line">		<span class="built_in">csort</span>(tmp, rk);</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>, cnt = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">			nrk[tmp[i]] = cnt;</span><br><span class="line">			<span class="keyword">auto</span> cur = <span class="built_in">make_pair</span>(rk[tmp[i]], rk[(tmp[i] + (<span class="number">1</span> &lt;&lt; j)) % n]);</span><br><span class="line">			<span class="keyword">auto</span> nxt = <span class="built_in">make_pair</span>(rk[tmp[i + <span class="number">1</span>]], rk[(tmp[i + <span class="number">1</span>] + (<span class="number">1</span> &lt;&lt; j)) % n]);</span><br><span class="line">			<span class="keyword">if</span>(i + <span class="number">1</span> &lt; n &amp;&amp; cur != nxt)</span><br><span class="line">				cnt++;</span><br><span class="line">		&#125;</span><br><span class="line">		rk = nrk;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> tmp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*-----------------------------------------------------------------------------------------------------*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	EmiliaMyWife</span><br><span class="line"></span><br><span class="line">	string s;</span><br><span class="line">	<span class="built_in">getline</span>(cin, s);</span><br><span class="line">	<span class="keyword">auto</span> w = <span class="built_in">solve</span>(s);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; s.<span class="built_in">size</span>(); i++)</span><br><span class="line">		cout &lt;&lt; w[i] &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="習題"><a href="#習題" class="headerlink" title="習題"></a>習題</h1><ul>
<li><a href="https://tioj.ck.tp.edu.tw/problems/1497">TIOJ-1497</a></li>
<li><a href="https://codeforces.com/edu/courses">CF EDU lesson 1</a></li>
</ul>
]]></content>
      <tags>
        <tag>string</tag>
        <tag>template</tag>
        <tag>suffix array</tag>
        <tag>tutorial</tag>
      </tags>
  </entry>
  <entry>
    <title>TIOJ-2008</title>
    <url>/TIOJ-2008/</url>
    <content><![CDATA[<p>有$N$個參賽者，每個參賽者有攻擊指數$a_i$和防禦指數$d_i$，每個參賽者可以往左或往右挑戰(可以往左往右一起來)，如果兩個指數中一個大於對手且另一個不小於對手(攻擊對攻擊，防禦對防禦)，那就會勝利。<br>如果勝利就能繼續往更左或更有挑戰，一路到沒有對手為止。<br>求最多勝場的參賽者的勝場數。<span id="more"></span><br><img src="https://tioj.ck.tp.edu.tw/pimgs/2008/1.png"><br><img src="https://tioj.ck.tp.edu.tw/pimgs/2008/2.png"><br>此時最大勝場數為8。</p>
<p>$1\le N\le 1.5\times 10^6, 0\le a_i,d_i\le 2\times 10^9$。</p>
<hr>
<p>如果b能贏a且c能贏b則c能贏a，此時b能贏的人數決不會比c多。因此符合單調性。<br>維護一個非嚴格遞減的stack，對於每個元素pop掉stack中能贏過他們的，stack的top即為該元素可以往左挑戰到的最左端。<br>做一次從左到右和從右到左的聯集，之後取最大值即是答案。<br>複雜度$\mathcal{O}(N)$。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">--------------              |   /</span></span><br><span class="line"><span class="comment">      |                     |  /</span></span><br><span class="line"><span class="comment">      |                     | /</span></span><br><span class="line"><span class="comment">      |             *       |/          |    |         ------            *</span></span><br><span class="line"><span class="comment">      |                     |           |    |        /      \</span></span><br><span class="line"><span class="comment">      |             |       |\          |    |       |       |\          |</span></span><br><span class="line"><span class="comment">   \  |             |       | \         |    |       |       | \         |</span></span><br><span class="line"><span class="comment">    \ |             |       |  \        |    |        \     /   \        |</span></span><br><span class="line"><span class="comment">     V              |       |   \        \__/|         -----     \       |</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EmiliaMyWife ios::sync_with_stdio(0); cin.tie(NULL);</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mem(i,j) memset(i,j,sizeof (i));</span></span><br><span class="line"><span class="keyword">using</span> ll = <span class="keyword">int64_t</span>;</span><br><span class="line"><span class="keyword">using</span> ull = <span class="keyword">uint64_t</span>;</span><br><span class="line"><span class="keyword">using</span> ld = <span class="keyword">long</span> <span class="keyword">double</span>;</span><br><span class="line"><span class="keyword">using</span> uint = <span class="keyword">uint32_t</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> EPS  = <span class="number">1e-8</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF     = <span class="number">0x3F3F3F3F</span>;</span><br><span class="line"><span class="keyword">const</span> ll LINF     = <span class="number">4611686018427387903</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MOD     = <span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="comment">/*-----------------------------------------------------------------------------------------------------*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	EmiliaMyWife</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> n;</span><br><span class="line">	cin &gt;&gt; n;</span><br><span class="line">	<span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">atk</span><span class="params">(n)</span>, <span class="title">def</span><span class="params">(n)</span>, <span class="title">ans</span><span class="params">(n)</span></span>;</span><br><span class="line">	<span class="keyword">auto</span> win = [&amp;] (<span class="keyword">int</span> a, <span class="keyword">int</span> b) &#123;<span class="comment">//a can win b ?</span></span><br><span class="line">		<span class="built_in"><span class="keyword">return</span></span> ((atk[a] == atk[b] &amp;&amp; def[a] &gt;= def[b]) || (atk[a] &gt; atk[b] &amp;&amp; def[a] &gt;= def[b]));</span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">		cin &gt;&gt; atk[i] &gt;&gt; def[i];</span><br><span class="line">	stack&lt;<span class="keyword">int</span>&gt; st;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">		<span class="keyword">while</span>(st.<span class="built_in">size</span>() &amp;&amp; <span class="built_in">win</span>(i, st.<span class="built_in">top</span>()))</span><br><span class="line">			st.<span class="built_in">pop</span>();</span><br><span class="line">		<span class="keyword">if</span>(st.<span class="built_in">empty</span>())</span><br><span class="line">			ans[i] += i;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			ans[i] += i - st.<span class="built_in">top</span>() - <span class="number">1</span>;</span><br><span class="line">		st.<span class="built_in">push</span>(i);</span><br><span class="line">	&#125;</span><br><span class="line">	st = stack&lt;<span class="keyword">int</span>&gt;();</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = n - <span class="number">1</span>; ~i; i--) &#123;</span><br><span class="line">		<span class="keyword">while</span>(st.<span class="built_in">size</span>() &amp;&amp; <span class="built_in">win</span>(i, st.<span class="built_in">top</span>()))</span><br><span class="line">			st.<span class="built_in">pop</span>();</span><br><span class="line">		<span class="keyword">if</span>(st.<span class="built_in">empty</span>())</span><br><span class="line">			ans[i] += n - i - <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			ans[i] += st.<span class="built_in">top</span>() - i - <span class="number">1</span>;</span><br><span class="line">		st.<span class="built_in">push</span>(i);</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; *<span class="built_in">max_element</span>(ans.<span class="built_in">begin</span>(), ans.<span class="built_in">end</span>()) &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>TIOJ</tag>
        <tag>stack</tag>
      </tags>
  </entry>
  <entry>
    <title>TIOJ-1241/1325</title>
    <url>/TIOJ-1241-1325/</url>
    <content><![CDATA[<p>從前，有個古老流傳的單人遊戲是這樣的<br>從1~n的整數中，你可以選擇把每個數當成兩種類別的其中一種：”倍數” 和 “因數”<br>被歸類為”因數”的數字沒有得分，但當然的，它是有用處的，看了下一句就知道；<br>被歸類為”倍數”的數字(假設是M)之得分，是所有被歸類為”因數”且整除M的數字的個數。<br>所以舉例來說, 假設1,2,5被歸為”因數” ，3,4,6,7,8,9,10被歸為”倍數”, 總得分就是1+2+2+1+2+1+3=12。</p>
<span id="more"></span>
<p>據說有人發明了”最強之無敗策略”，可以達到最佳的總分<br>這種神奇的策略, 就是”倍因的道”，或簡稱”倍因道”。</p>
<p>總之，希望你也懂得這個道<br>因為給定n，要請你回答最大可能得到的得分!</p>
<p>TIOJ-1241: $n\le 2000$ <br/><br>TIOJ-1325: $t, n\le 10^5$</p>
<hr>
<h1 id="1241"><a href="#1241" class="headerlink" title="1241"></a>1241</h1><p>一個困難版一個簡單版，先從1241開始。<br>對於每個數字，去計算它的因數中被歸類為”因數”的數量及倍數數量，如果倍數數量&gt;前者，那這樣直接把這個數字變成”因數”答案肯定會變好。<br>所以就有個$\mathcal{O}(NlogN)$的做法:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">--------------              |   /</span></span><br><span class="line"><span class="comment">      |                     |  /</span></span><br><span class="line"><span class="comment">      |                     | /</span></span><br><span class="line"><span class="comment">      |             *       |/          |    |         ------            *</span></span><br><span class="line"><span class="comment">      |                     |           |    |        /      \</span></span><br><span class="line"><span class="comment">      |             |       |\          |    |       |       |\          |</span></span><br><span class="line"><span class="comment">   \  |             |       | \         |    |       |       | \         |</span></span><br><span class="line"><span class="comment">    \ |             |       |  \        |    |        \     /   \        |</span></span><br><span class="line"><span class="comment">     V              |       |   \        \__/|         -----     \       |</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EmiliaMyWife ios::sync_with_stdio(0); cin.tie(NULL);</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mem(i,j) memset(i,j,sizeof (i));</span></span><br><span class="line"><span class="keyword">using</span> ll = <span class="keyword">int64_t</span>;</span><br><span class="line"><span class="keyword">using</span> ull = <span class="keyword">uint64_t</span>;</span><br><span class="line"><span class="keyword">using</span> ld = <span class="keyword">long</span> <span class="keyword">double</span>;</span><br><span class="line"><span class="keyword">using</span> uint = <span class="keyword">uint32_t</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> EPS  = <span class="number">1e-8</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF     = <span class="number">0x3F3F3F3F</span>;</span><br><span class="line"><span class="keyword">const</span> ll LINF     = <span class="number">4611686018427387903</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MOD     = <span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="comment">/*-----------------------------------------------------------------------------------------------------*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	EmiliaMyWife</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">int</span> t;</span><br><span class="line">	cin &gt;&gt; t;</span><br><span class="line">	<span class="keyword">while</span>(t--) &#123;</span><br><span class="line">		<span class="keyword">int</span> n;</span><br><span class="line">		cin &gt;&gt; n;</span><br><span class="line">		<span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">ans</span><span class="params">(n + <span class="number">1</span>)</span></span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">			<span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> j = i * <span class="number">2</span>; j &lt;= n; j+=i)</span><br><span class="line">				res++;</span><br><span class="line">			<span class="keyword">if</span>(res &gt;= ans[i]) &#123;</span><br><span class="line">				ans[i] = <span class="number">0</span>;</span><br><span class="line">				<span class="keyword">for</span>(<span class="keyword">int</span> j = i * <span class="number">2</span>; j &lt;= n; j+=i)</span><br><span class="line">					ans[j]++;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		cout &lt;&lt; <span class="built_in">accumulate</span>(ans.<span class="built_in">begin</span>(), ans.<span class="built_in">end</span>(), <span class="number">0</span>) &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="1325"><a href="#1325" class="headerlink" title="1325"></a>1325</h1><p>這題中複雜度$\mathcal{O}(TNlogN)$會太高，得往建表的方面想。<br/><br>去想想n變成n+1時會發生什麼情況?<br><strong>他的所有因數的倍數數量都會多一</strong><br>此時就能檢查1241的條件:倍數數量&gt;前者。<br>而把它變成”因數”會需要$\mathcal{O}(logN)$，最多只會有$N$個數字被變成因數。<br/><br>所以複雜度會變成$\mathcal{O}(NloN+N\sqrt N)$(用平方根其實沒那麼準確，因數數量有個更緊的上界(但我不知道是多少))。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">--------------              |   /</span></span><br><span class="line"><span class="comment">      |                     |  /</span></span><br><span class="line"><span class="comment">      |                     | /</span></span><br><span class="line"><span class="comment">      |             *       |/          |    |         ------            *</span></span><br><span class="line"><span class="comment">      |                     |           |    |        /      \</span></span><br><span class="line"><span class="comment">      |             |       |\          |    |       |       |\          |</span></span><br><span class="line"><span class="comment">   \  |             |       | \         |    |       |       | \         |</span></span><br><span class="line"><span class="comment">    \ |             |       |  \        |    |        \     /   \        |</span></span><br><span class="line"><span class="comment">     V              |       |   \        \__/|         -----     \       |</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EmiliaMyWife ios::sync_with_stdio(0); cin.tie(NULL);</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mem(i,j) memset(i,j,sizeof (i));</span></span><br><span class="line"><span class="keyword">using</span> ll = <span class="keyword">int64_t</span>;</span><br><span class="line"><span class="keyword">using</span> ull = <span class="keyword">uint64_t</span>;</span><br><span class="line"><span class="keyword">using</span> ld = <span class="keyword">long</span> <span class="keyword">double</span>;</span><br><span class="line"><span class="keyword">using</span> uint = <span class="keyword">uint32_t</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> EPS  = <span class="number">1e-8</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF     = <span class="number">0x3F3F3F3F</span>;</span><br><span class="line"><span class="keyword">const</span> ll LINF     = <span class="number">4611686018427387903</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MOD     = <span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="comment">/*-----------------------------------------------------------------------------------------------------*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span> + <span class="number">1</span>;</span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; fac[N];</span><br><span class="line"><span class="keyword">int</span> cnt[N], ans[N], res, out[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="function">EmiliaMyWife</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">	<span class="title">for</span><span class="params">(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; N; i++)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j = i * <span class="number">2</span>; j &lt; N; j+=i)</span><br><span class="line">			fac[j].<span class="built_in">push_back</span>(i);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; N; i++) &#123;</span><br><span class="line">		res += ans[i];</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> a : fac[i]) &#123;</span><br><span class="line">			<span class="keyword">if</span>(cnt[a] &lt; <span class="number">0</span>)</span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">			cnt[a]++;</span><br><span class="line">			<span class="keyword">if</span>(cnt[a] &gt;= ans[a]) &#123;</span><br><span class="line">				res -= ans[a];</span><br><span class="line">				res += cnt[a];</span><br><span class="line">				ans[a] = <span class="number">0</span>;</span><br><span class="line">				cnt[a] = <span class="number">-1</span>;</span><br><span class="line">				<span class="keyword">for</span>(<span class="keyword">int</span> j = a * <span class="number">2</span>; j &lt; N; j += a) &#123;</span><br><span class="line">					ans[j]++;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		out[i] = res;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> t, x;</span><br><span class="line">	cin &gt;&gt; t;</span><br><span class="line">	<span class="keyword">while</span>(t--)</span><br><span class="line">		cin &gt;&gt; x, cout &lt;&lt; out[x] &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>TIOJ</tag>
        <tag>math</tag>
      </tags>
  </entry>
  <entry>
    <title>TIOJ-1947</title>
    <url>/TIOJ-1947/</url>
    <content><![CDATA[<p>給一棵樹，找出樹重心(若以該點為根，所有不含根節點的子樹中點數最大的那個數量要最小)。</p>
<span id="more"></span>
<p>$N\le 10^6$<br>考慮樹dp，紀錄每個子樹的大小，該點的答案即為$max(\text{所有不含自己的子樹大小}, N-\text{當前子樹大小})$。<br>當前子樹大小即為所有不含自己子樹的大小+1(自己)，將這個值回傳即可。<br>\Lambda大法好/</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">--------------              |   /</span></span><br><span class="line"><span class="comment">      |                     |  /</span></span><br><span class="line"><span class="comment">      |                     | /</span></span><br><span class="line"><span class="comment">      |             *       |/          |    |         ------            *</span></span><br><span class="line"><span class="comment">      |                     |           |    |        /      \</span></span><br><span class="line"><span class="comment">      |             |       |\          |    |       |       |\          |</span></span><br><span class="line"><span class="comment">   \  |             |       | \         |    |       |       | \         |</span></span><br><span class="line"><span class="comment">    \ |             |       |  \        |    |        \     /   \        |</span></span><br><span class="line"><span class="comment">     V              |       |   \        \__/|         -----     \       |</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EmiliaMyWife ios::sync_with_stdio(0); cin.tie(NULL);</span></span><br><span class="line"><span class="comment">/*-----------------------------------------------------------------------------------------------------*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	EmiliaMyWife</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> n;</span><br><span class="line">	cin &gt;&gt; n;</span><br><span class="line">	vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">edge</span>(n);</span><br><span class="line">	<span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">ans</span><span class="params">(n)</span></span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>, a, b; i &lt; n; i++)</span><br><span class="line">		cin &gt;&gt; a &gt;&gt; b, edge[a].<span class="built_in">push_back</span>(b), edge[b].<span class="built_in">push_back</span>(a);</span><br><span class="line">	<span class="keyword">const</span> function&lt;<span class="built_in"><span class="keyword">int</span></span>(<span class="keyword">int</span>, <span class="keyword">int</span>)&gt; dfs = [&amp;](<span class="keyword">int</span> v, <span class="keyword">int</span> p) &#123;</span><br><span class="line">		<span class="keyword">int</span> res = <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> u : edge[v]) &#123;</span><br><span class="line">			<span class="keyword">if</span>(u == p)</span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">			<span class="keyword">int</span> w = <span class="built_in">dfs</span>(u, v);</span><br><span class="line">			ans[v] = <span class="built_in">max</span>(ans[v], w);</span><br><span class="line">			res += w;</span><br><span class="line">		&#125;</span><br><span class="line">		ans[v] = <span class="built_in">max</span>(ans[v], n - res);</span><br><span class="line">		<span class="keyword">return</span> res;</span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="built_in">dfs</span>(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">	cout &lt;&lt; *<span class="built_in">min_element</span>(ans.<span class="built_in">begin</span>(), ans.<span class="built_in">end</span>()) &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>TIOJ</tag>
        <tag>dp</tag>
      </tags>
  </entry>
  <entry>
    <title>TIOJ-2095</title>
    <url>/TIOJ-2095/</url>
    <content><![CDATA[<p>求$a^{b^c}\mod 880301(1\le a,b,c\le 10^9)$(880301是質數)。<br>有人寫了一個快速冪函數，不過爛了，求會出現問題的測資。<span id="more"></span></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">mypow</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> A,<span class="keyword">long</span> <span class="keyword">long</span> B,<span class="keyword">long</span> <span class="keyword">long</span> M)</span></span>&#123; <span class="comment">//calculate A^B % M</span></span><br><span class="line">    A%=M;</span><br><span class="line">    <span class="keyword">if</span>(M==<span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(B==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(A==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> mid=<span class="built_in">mypow</span>(A,B/<span class="number">2</span>,M);</span><br><span class="line">    <span class="keyword">if</span>(B%<span class="number">2</span>) <span class="keyword">return</span> mid*mid%M*A%M;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> mid*mid%M;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> a,b,c,p=<span class="number">880301</span>;</span><br><span class="line">    cin&gt;&gt;a&gt;&gt;b&gt;&gt;c;</span><br><span class="line">    cout&lt;&lt;<span class="built_in">mypow</span>(a,<span class="built_in">mypow</span>(b,c,p<span class="number">-1</span>),p)&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<p>很正常的快速冪函數，中間用了三個if到處特判有夠危險。<br>果然問題出在這裡，當A=0, B=0(雖然數學上未定義，但這裡是模數)，mypow會回傳1而非0。<br>但原問題的條件不允許輸出0。然而$b^c\mod p-1$這一項可以讓她變零。<br>所以輸出p p-1 1就好。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">--------------              |   /</span></span><br><span class="line"><span class="comment">      |                     |  /</span></span><br><span class="line"><span class="comment">      |                     | /</span></span><br><span class="line"><span class="comment">      |             *       |/          |    |         ------            *</span></span><br><span class="line"><span class="comment">      |                     |           |    |        /      \</span></span><br><span class="line"><span class="comment">      |             |       |\          |    |       |       |\          |</span></span><br><span class="line"><span class="comment">   \  |             |       | \         |    |       |       | \         |</span></span><br><span class="line"><span class="comment">    \ |             |       |  \        |    |        \     /   \        |</span></span><br><span class="line"><span class="comment">     V              |       |   \        \__/|         -----     \       |</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">/*-----------------------------------------------------------------------------------------------------*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;880301 880300 1\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>TIOJ</tag>
        <tag>Hack</tag>
      </tags>
  </entry>
  <entry>
    <title>TIOJ-2058</title>
    <url>/TIOJ-2058/</url>
    <content><![CDATA[<p>從前從前，在「單行道國」中有兩個人，John和Jon。他們兩個人是死對頭，而且都住在同一個小鎮$A$。<br>「單行道國」顧名思義，這個國家每一條路都是連接兩個小鎮的單行道，並且國家中總共有$N$個小鎮，從編號$0$到$N-1$。這個國家的交通其實相當發達，所以對於任意兩個小鎮$X,Y$，都存在路線可以從$X$走到$Y$。另外，有些小鎮之間可能會兩個方向的單行道各有一條；甚至在重要的小鎮之間可能會有很多條起終點一樣的單行道。當然，單行道國的政府也看上了他們國家交通發達這件事情，於是決定在每一條道路都蓋一個收費站，任何一個開車經過的人民都要收過路費。<br>某一天，John要到$B$鎮去旅遊。沒想到，在他收拾好一切行李準備出發的時候，他卻聽說兩天前Jon剛好也去了$B$鎮一趟！身為Jon的死對頭，John決定說什麼也不要和Jon走類似的路線。幸好John知道Jon是個非常節省的人，所以Jon從$A$鎮到$B$鎮時一定會挑選總過路費最少的路線前往。<br>因此，John算出了Jon從$A$鎮到$B$鎮時繳了多少過路費，並且決定自己從$A$鎮前往$B$鎮的時候繳的<strong>總過路費一定要跟Jon不一樣</strong>。在滿足這個前提之下，John會讓自己繳的總過路費愈少愈好（當然，這樣有可能是必須要繞路的，也就是說John走的路線可能會重複經過某個小鎮或重複經過某一條單行道）。你能幫John算出他繳的總過路費和Jon繳的總過路費差了多少錢嗎？</p>
<span id="more"></span>
<p>$T\le 20, N, M\le 10^5, K_i\le 10^9$。</p>
<hr>
<p>其實就是嚴格次短路徑辣.jpg。那要怎麼做呢?<br>只要不斷更新最短路徑的同時，把舊的最短路徑丟給次短路徑就好(或者只能更新次短路徑就更新)，就一般的dijkstra可解。<br>記得pq中最短和次短都要丟，這樣才能好好更新(我也不太知道原因，反正就是這樣(誤))。<br>複雜度$\mathcal{O}(ElogE)$。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">--------------              |   /</span></span><br><span class="line"><span class="comment">      |                     |  /</span></span><br><span class="line"><span class="comment">      |                     | /</span></span><br><span class="line"><span class="comment">      |             *       |/          |    |         ------            *</span></span><br><span class="line"><span class="comment">      |                     |           |    |        /      \</span></span><br><span class="line"><span class="comment">      |             |       |\          |    |       |       |\          |</span></span><br><span class="line"><span class="comment">   \  |             |       | \         |    |       |       | \         |</span></span><br><span class="line"><span class="comment">    \ |             |       |  \        |    |        \     /   \        |</span></span><br><span class="line"><span class="comment">     V              |       |   \        \__/|         -----     \       |</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EmiliaMyWife ios::sync_with_stdio(0); cin.tie(NULL);</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mem(i,j) memset(i,j,sizeof (i));</span></span><br><span class="line"><span class="keyword">using</span> ll = <span class="keyword">int64_t</span>;</span><br><span class="line"><span class="keyword">using</span> ull = <span class="keyword">uint64_t</span>;</span><br><span class="line"><span class="keyword">using</span> ld = <span class="keyword">long</span> <span class="keyword">double</span>;</span><br><span class="line"><span class="keyword">using</span> uint = <span class="keyword">uint32_t</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> EPS  = <span class="number">1e-8</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF     = <span class="number">0x3F3F3F3F</span>;</span><br><span class="line"><span class="keyword">const</span> ll LINF     = <span class="number">4611686018427387903</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MOD     = <span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="comment">/*-----------------------------------------------------------------------------------------------------*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	EmiliaMyWife</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> t;</span><br><span class="line">	cin &gt;&gt; t;</span><br><span class="line">	<span class="keyword">while</span>(t--) &#123;</span><br><span class="line">		<span class="keyword">int</span> s, t, n, m;</span><br><span class="line">		cin &gt;&gt; n &gt;&gt; m &gt;&gt; s &gt;&gt; t;</span><br><span class="line">		<span class="function">vector&lt;ll&gt; <span class="title">dis</span><span class="params">(n, LINF)</span>, <span class="title">dis2</span><span class="params">(n, LINF)</span></span>;</span><br><span class="line">		vector&lt;vector&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt;&gt; <span class="built_in">edge</span>(n);</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>, a, b, c; i &lt; m; i++)</span><br><span class="line">			cin &gt;&gt; a &gt;&gt; b &gt;&gt; c, edge[a].<span class="built_in">push_back</span>(&#123;b, c&#125;);</span><br><span class="line">		dis[s] = <span class="number">0</span>;</span><br><span class="line">		priority_queue&lt;pair&lt;ll, <span class="keyword">int</span>&gt;, vector&lt;pair&lt;ll, <span class="keyword">int</span>&gt;&gt;, greater&lt;pair&lt;ll, <span class="keyword">int</span>&gt;&gt;&gt; pq;</span><br><span class="line">		pq.<span class="built_in">push</span>(&#123;<span class="number">0</span>, s&#125;);</span><br><span class="line">		<span class="keyword">while</span>(!pq.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">			<span class="keyword">auto</span> [d, v] = pq.<span class="built_in">top</span>();</span><br><span class="line">			pq.<span class="built_in">pop</span>();</span><br><span class="line">			<span class="keyword">if</span>(dis2[v] &lt; d)</span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">auto</span> [u, c] : edge[v]) &#123;</span><br><span class="line">				ll xx = d + c;</span><br><span class="line">				<span class="keyword">if</span>(xx &lt; dis[u]) &#123;</span><br><span class="line">					<span class="built_in">swap</span>(dis[u], xx);</span><br><span class="line">					pq.<span class="built_in">push</span>(&#123;dis[u], u&#125;);</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">if</span>(xx &lt; dis2[u] &amp;&amp; xx != dis[u]) &#123;</span><br><span class="line">					dis2[u] = xx;</span><br><span class="line">					pq.<span class="built_in">push</span>(&#123;dis2[u], u&#125;);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		cout &lt;&lt; dis2[t] - dis[t] &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>TIOJ</tag>
        <tag>dijkstra</tag>
      </tags>
  </entry>
  <entry>
    <title>TIOJ-1706</title>
    <url>/TIOJ-1706/</url>
    <content><![CDATA[<p>遞給了你一張地圖，跟你解釋著：<br>這張地圖上面標示了許多連接城與城之間的雙向道路。每條道路上都有一座收費站。每<br>座收費站每個方向(沒錯，同一個收費站不同方向過路費也會不一樣)都有一個起始過路費C ，<br>在第一天時收費就是C元。但是還有一個費用變量P，每一天結束在下一天開始之前，<br>會把該方向過路費調整P元(正表示過路費調昇、負表示調降)。<br>也就是說，第T天的費用為C+(T-1)×P。<br>你們已經調查出了國王居住的城市跟皇后居住的城市，<br>而且知道國王一定會在[1,D](包含1 和 D)的某一天去拜訪皇后再在當日回到國王城市。<br>國王嗜錢如命，自然希望這一趟旅行過路費儘量少。<br>請你輸出國王選了最划算的日子拜訪皇后之下，所需要支付的總過路費。</p>
<span id="more"></span>
<p>$N, M\le 10^5, D\le 10^4, 0\le C_i+(D-1)P_i \le 10^4$。</p>
<hr>
<p>一個直覺地解就是枚舉每一天數，然後就能去計算最短路徑(起點做單點源，終點也做單點源，然後就能知道來回的距離)。<br>但是這樣會TLE，觀察到在第t天對於每一條路徑的過路費總和為<br>$$\sum^i_{i\in path} (c_i+(t-1)p_i)=\sum^i_{i\in path}c_i+(t-1)\sum^i_{i\in path}p_i$$<br>後面那項$p_i$總和如果是負數，那就最好在第一天就出門，否則t越大越好(在最後一天出門)。<br>因此只要枚舉第一天和最後一天取答案較小值。<br>複雜度$\mathcal{O}(ElogE)$</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">--------------              |   /</span></span><br><span class="line"><span class="comment">      |                     |  /</span></span><br><span class="line"><span class="comment">      |                     | /</span></span><br><span class="line"><span class="comment">      |             *       |/          |    |         ------            *</span></span><br><span class="line"><span class="comment">      |                     |           |    |        /      \</span></span><br><span class="line"><span class="comment">      |             |       |\          |    |       |       |\          |</span></span><br><span class="line"><span class="comment">   \  |             |       | \         |    |       |       | \         |</span></span><br><span class="line"><span class="comment">    \ |             |       |  \        |    |        \     /   \        |</span></span><br><span class="line"><span class="comment">     V              |       |   \        \__/|         -----     \       |</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EmiliaMyWife ios::sync_with_stdio(0); cin.tie(NULL);</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mem(i,j) memset(i,j,sizeof (i));</span></span><br><span class="line"><span class="keyword">using</span> ll = <span class="keyword">int64_t</span>;</span><br><span class="line"><span class="keyword">using</span> ull = <span class="keyword">uint64_t</span>;</span><br><span class="line"><span class="keyword">using</span> ld = <span class="keyword">long</span> <span class="keyword">double</span>;</span><br><span class="line"><span class="keyword">using</span> uint = <span class="keyword">uint32_t</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> EPS  = <span class="number">1e-8</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF     = <span class="number">0x3F3F3F3F</span>;</span><br><span class="line"><span class="keyword">const</span> ll LINF     = <span class="number">4611686018427387903</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MOD     = <span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="comment">/*-----------------------------------------------------------------------------------------------------*/</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edg</span> &#123;</span></span><br><span class="line">	<span class="keyword">int</span> v, c, p;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	EmiliaMyWife</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> n, m, a, b, d;</span><br><span class="line">	cin &gt;&gt; n &gt;&gt; m &gt;&gt; a &gt;&gt; b &gt;&gt; d;</span><br><span class="line">	vector&lt;vector&lt;edg&gt;&gt; <span class="built_in">edge</span>(n + <span class="number">1</span>);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>, x, y, a, b, c, p; i &lt; m; i++)</span><br><span class="line">		cin &gt;&gt; x &gt;&gt; y &gt;&gt; a &gt;&gt; b &gt;&gt; c &gt;&gt; p, edge[x].<span class="built_in">push_back</span>(&#123;y, a, b&#125;), edge[y].<span class="built_in">push_back</span>(&#123;x, c, p&#125;);</span><br><span class="line">	vector&lt;<span class="keyword">int</span>&gt; dis, dis2;</span><br><span class="line">	<span class="keyword">auto</span> dijkstra = [&amp;](<span class="keyword">int</span> a, vector&lt;<span class="keyword">int</span>&gt; &amp;dis, <span class="keyword">int</span> d) &#123;</span><br><span class="line">		dis = vector&lt;<span class="keyword">int</span>&gt;(n + <span class="number">1</span>, INF);</span><br><span class="line">		dis[a] = <span class="number">0</span>;</span><br><span class="line">		priority_queue&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;, vector&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt;, greater&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt;&gt; pq;</span><br><span class="line">		pq.<span class="built_in">push</span>(&#123;<span class="number">0</span>, a&#125;);</span><br><span class="line">		<span class="keyword">while</span>(!pq.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">			<span class="keyword">auto</span> [c, u] = pq.<span class="built_in">top</span>();</span><br><span class="line">			pq.<span class="built_in">pop</span>();</span><br><span class="line">			<span class="keyword">if</span>(dis[u] &lt; c)</span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">auto</span> &amp;x : edge[u]) &#123;</span><br><span class="line">				<span class="keyword">int</span> cost = x.c + x.p * d;</span><br><span class="line">				<span class="keyword">if</span>(c + cost &lt; dis[x.v]) &#123;</span><br><span class="line">					dis[x.v] = c + cost;</span><br><span class="line">					pq.<span class="built_in">push</span>(&#123;dis[x.v], x.v&#125;);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="built_in">dijkstra</span>(a, dis, <span class="number">0</span>), <span class="built_in">dijkstra</span>(b, dis2, <span class="number">0</span>);</span><br><span class="line">	<span class="keyword">int</span> ans = dis[b] + dis2[a];</span><br><span class="line">	<span class="built_in">dijkstra</span>(a, dis, d - <span class="number">1</span>), <span class="built_in">dijkstra</span>(b, dis2, d - <span class="number">1</span>);</span><br><span class="line">	cout &lt;&lt; <span class="built_in">min</span>(ans, dis[b] + dis2[a]) &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>TIOJ</tag>
        <tag>dijkstra</tag>
      </tags>
  </entry>
  <entry>
    <title>TIOJ-1099</title>
    <url>/TIOJ-1099/</url>
    <content><![CDATA[<p>在一個長寬高為$n$的三維空間中，每次在座標$(x, y, z)$可以跳到以下任一個:</p>
<ul>
<li>$(y, x, z)$</li>
<li>$(x, z, y)$</li>
<li>$(z, x, y)$</li>
<li>$(2y - x + 1, 2x - y - 1, z)$</li>
</ul>
<p>給定起始點$(x_1, y_1, z_1)$，問能不能跳到$(x_2, y_2, z_2)$</p>
<span id="more"></span>
<p>$n\le 3000$</p>
<hr>
<p>直觀下可以直接跑dfs，記錄三維的造訪狀態(走過的不要走)，這樣是$\mathcal{O}(N^3)$。<br>之後想了好久orz，還是去被暴雷後才知道怎麼做QQ</p>
<p><strong>如何更快?</strong><br>考慮$x+y+z=k$，前三種方式很顯然的移動後總和仍$=k$，至於第四種:<br>$$(2y - x + 1) + (2x - y - 1) + z = x + y + z = k$$<br>所以三個座標的總和為定值，此時狀態只需要紀錄兩個維度就好!!<br>複雜度$\mathcal{O}(N^2)$。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">--------------              |   /</span></span><br><span class="line"><span class="comment">      |                     |  /</span></span><br><span class="line"><span class="comment">      |                     | /</span></span><br><span class="line"><span class="comment">      |             *       |/          |    |         ------            *</span></span><br><span class="line"><span class="comment">      |                     |           |    |        /      \</span></span><br><span class="line"><span class="comment">      |             |       |\          |    |       |       |\          |</span></span><br><span class="line"><span class="comment">   \  |             |       | \         |    |       |       | \         |</span></span><br><span class="line"><span class="comment">    \ |             |       |  \        |    |        \     /   \        |</span></span><br><span class="line"><span class="comment">     V              |       |   \        \__/|         -----     \       |</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EmiliaMyWife ios::sync_with_stdio(0); cin.tie(NULL);</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mem(i,j) memset(i,j,sizeof (i));</span></span><br><span class="line"><span class="keyword">using</span> ll = <span class="keyword">int64_t</span>;</span><br><span class="line"><span class="keyword">using</span> ull = <span class="keyword">uint64_t</span>;</span><br><span class="line"><span class="keyword">using</span> ld = <span class="keyword">long</span> <span class="keyword">double</span>;</span><br><span class="line"><span class="keyword">using</span> uint = <span class="keyword">uint32_t</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> EPS  = <span class="number">1e-8</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF     = <span class="number">0x3F3F3F3F</span>;</span><br><span class="line"><span class="keyword">const</span> ll LINF     = <span class="number">4611686018427387903</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MOD     = <span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="comment">/*-----------------------------------------------------------------------------------------------------*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	EmiliaMyWife</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> n, a, b, c, d, e, f;</span><br><span class="line">	<span class="keyword">while</span>(cin &gt;&gt; n &gt;&gt; a &gt;&gt; b &gt;&gt; c &gt;&gt; d &gt;&gt; e &gt;&gt; f, n) &#123;</span><br><span class="line">		<span class="keyword">if</span>(a + b + c != d + e + f) &#123;</span><br><span class="line">			cout &lt;&lt; <span class="string">&quot;No\n&quot;</span>;</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		vector&lt;vector&lt;<span class="keyword">bool</span>&gt;&gt; <span class="built_in">ok</span>(n + <span class="number">1</span>, vector&lt;<span class="keyword">bool</span>&gt;(n + <span class="number">1</span>));</span><br><span class="line">		<span class="keyword">const</span> function&lt;<span class="built_in"><span class="keyword">void</span></span>(<span class="keyword">int</span>, <span class="keyword">int</span>, <span class="keyword">int</span>)&gt; dfs = [&amp;] (<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> z) &#123;</span><br><span class="line">			<span class="keyword">if</span>(x &lt; <span class="number">0</span> || y &lt; <span class="number">0</span> || z &lt; <span class="number">0</span> || x &gt; n || y &gt; n || z &gt; n)</span><br><span class="line">				<span class="keyword">return</span>;</span><br><span class="line">			<span class="keyword">if</span>(ok[x][y])</span><br><span class="line">				<span class="keyword">return</span>;</span><br><span class="line">			ok[x][y] = <span class="number">1</span>;</span><br><span class="line">			<span class="built_in">dfs</span>(y, x, z);</span><br><span class="line">			<span class="built_in">dfs</span>(x, z, y);</span><br><span class="line">			<span class="built_in">dfs</span>(z, y, x);</span><br><span class="line">			<span class="built_in">dfs</span>(<span class="number">2</span> * y - x + <span class="number">1</span>, <span class="number">2</span> * x - y - <span class="number">1</span>, z);</span><br><span class="line">		&#125;;</span><br><span class="line">		<span class="built_in">dfs</span>(a, b, c);</span><br><span class="line">		cout &lt;&lt; (ok[d][e] ? <span class="string">&quot;Yes&quot;</span> : <span class="string">&quot;No&quot;</span>) &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>TIOJ</tag>
        <tag>BackTrack</tag>
      </tags>
  </entry>
  <entry>
    <title>TIOJ-1494</title>
    <url>/TIOJ-1494/</url>
    <content><![CDATA[<p>定義一數列$F$為：<br>$F_1=1, F_2=2$。<br>$F_n=F_n-1+F_n-2$。<br>給定兩正整數$a, b$，求$gcd(F_a, F_b)$</p>
<span id="more"></span>
<p>$a, b\le 10^{18}$</p>
<hr>
<p>$F$其實就是費式數列，只是被位移了一格<br>先讓他變回正常的費式數列$f(f_1=1,f_2=1)$，此時$F_n=f_{n+1}$。<br>然後費式數列有個性質:<br>$$gcd(f_n, f_m)=f_{gcd(n, m)}$$<br>推導過程需要用蠻多其他定理的，<br>總之，這樣就等同於求數列某項，直接矩陣快速冪就可以了。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">--------------              |   /</span></span><br><span class="line"><span class="comment">      |                     |  /</span></span><br><span class="line"><span class="comment">      |                     | /</span></span><br><span class="line"><span class="comment">      |             *       |/          |    |         ------            *</span></span><br><span class="line"><span class="comment">      |                     |           |    |        /      \</span></span><br><span class="line"><span class="comment">      |             |       |\          |    |       |       |\          |</span></span><br><span class="line"><span class="comment">   \  |             |       | \         |    |       |       | \         |</span></span><br><span class="line"><span class="comment">    \ |             |       |  \        |    |        \     /   \        |</span></span><br><span class="line"><span class="comment">     V              |       |   \        \__/|         -----     \       |</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EmiliaMyWife ios::sync_with_stdio(0); cin.tie(NULL);</span></span><br><span class="line"><span class="keyword">using</span> ll = <span class="keyword">int64_t</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MOD     = <span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="comment">/*-----------------------------------------------------------------------------------------------------*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> mat = vector&lt;vector&lt;ll&gt;&gt;;</span><br><span class="line"></span><br><span class="line">mat <span class="keyword">operator</span>*(mat &amp;a, mat &amp;b) &#123;</span><br><span class="line">	<span class="function">mat <span class="title">res</span><span class="params">(<span class="number">2</span>, vector&lt;ll&gt;(<span class="number">2</span>))</span></span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++)</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">2</span>; j++)</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="number">2</span>; k++)</span><br><span class="line">				res[i][j] = (res[i][j] + a[i][k] * b[k][j]) % MOD;</span><br><span class="line">	<span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get</span><span class="params">(ll n)</span> </span>&#123;</span><br><span class="line">	mat a = &#123;&#123;<span class="number">1</span>, <span class="number">1</span>&#125;, &#123;<span class="number">1</span>, <span class="number">0</span>&#125;&#125;, res = &#123;&#123;<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, <span class="number">1</span>&#125;&#125;;</span><br><span class="line">	<span class="keyword">for</span>(; n; n&gt;&gt;=<span class="number">1</span>, a = a * a)</span><br><span class="line">		<span class="keyword">if</span>(n &amp; <span class="number">1</span>)</span><br><span class="line">			res = res * a;</span><br><span class="line">	<span class="keyword">return</span> res[<span class="number">1</span>][<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	EmiliaMyWife</span><br><span class="line"></span><br><span class="line">	ll n, m;</span><br><span class="line">	cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">	cout &lt;&lt; <span class="built_in">get</span>(__gcd(n + <span class="number">1</span>, m + <span class="number">1</span>)) &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>TIOJ</tag>
        <tag>math</tag>
      </tags>
  </entry>
  <entry>
    <title>TIOJ-1929</title>
    <url>/TIOJ-1929/</url>
    <content><![CDATA[<p>給定$M$組關係$(a, b), (1\le a, b\le N)$滿足$x_a\le x_b$。<br>構造一個數列$x$有$N$項，滿足：</p>
<ol>
<li>符合所有$M$組關係。</li>
<li>最大值為$k$。</li>
<li>$[1,k]$皆有在數列出現。</li>
</ol>
<p>並須最大化$k$。</p>
<span id="more"></span>
<p>$N, M\le 10^6$</p>
<hr>
<p>先建一個圖，每組關係$(a, b)$就連一條有向邊從$a$到$b$。<br>觀察可以發現對於同個scc中的每個點她的值都必須相同。</p>
<blockquote>
<p>$proof$</p>
<p>對於任意兩點$(u, v)$，都可以找到$x_u\le x_{s_1}\le x_{s_2}…\le x_v$及$x_v\le x_{t_1}\le x_{t_2}…\le x_u$。因為遞移律及三一律，$x_u=x_v$。</p>
</blockquote>
<p>之後拓樸排序就會是一組解!<br>這裡使用kosaraju來做scc縮點，複雜度$\mathcal{O}(N+M)$。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">--------------              |   /</span></span><br><span class="line"><span class="comment">      |                     |  /</span></span><br><span class="line"><span class="comment">      |                     | /</span></span><br><span class="line"><span class="comment">      |             *       |/          |    |         ------            *</span></span><br><span class="line"><span class="comment">      |                     |           |    |        /      \</span></span><br><span class="line"><span class="comment">      |             |       |\          |    |       |       |\          |</span></span><br><span class="line"><span class="comment">   \  |             |       | \         |    |       |       | \         |</span></span><br><span class="line"><span class="comment">    \ |             |       |  \        |    |        \     /   \        |</span></span><br><span class="line"><span class="comment">     V              |       |   \        \__/|         -----     \       |</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EmiliaMyWife ios::sync_with_stdio(0); cin.tie(NULL);</span></span><br><span class="line"><span class="comment">/*-----------------------------------------------------------------------------------------------------*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123; EmiliaMyWife</span><br><span class="line">	<span class="keyword">int</span> n, m, t = <span class="number">0</span>;</span><br><span class="line">	cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">	<span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">ans</span><span class="params">(n + <span class="number">1</span>)</span></span>;</span><br><span class="line">	stack&lt;<span class="keyword">int</span>&gt; st;</span><br><span class="line">	<span class="function">vector&lt;<span class="keyword">bool</span>&gt; <span class="title">vis</span><span class="params">(n + <span class="number">1</span>)</span></span>;</span><br><span class="line">	vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">edge</span>(n + <span class="number">1</span>), <span class="built_in">redge</span>(n + <span class="number">1</span>);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>, a, b; i &lt; m; i++) &#123;</span><br><span class="line">		cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line">		edge[a].<span class="built_in">push_back</span>(b);</span><br><span class="line">		redge[b].<span class="built_in">push_back</span>(a);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">const</span> function&lt;<span class="built_in"><span class="keyword">void</span></span>(<span class="keyword">int</span>)&gt; dfs = [&amp;] (<span class="keyword">int</span> u) &#123;</span><br><span class="line">		<span class="keyword">if</span>(vis[u])</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		vis[u] = <span class="literal">true</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> v : edge[u])</span><br><span class="line">			<span class="built_in">dfs</span>(v);</span><br><span class="line">		st.<span class="built_in">push</span>(u);</span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="keyword">const</span> function&lt;<span class="built_in"><span class="keyword">void</span></span>(<span class="keyword">int</span>, <span class="keyword">int</span>)&gt; dfs2 = [&amp;] (<span class="keyword">int</span> u, <span class="keyword">int</span> c) &#123;</span><br><span class="line">		<span class="keyword">if</span>(ans[u])</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		ans[u] = c;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> v : redge[u])</span><br><span class="line">			<span class="built_in">dfs2</span>(v, c);</span><br><span class="line">	&#125;;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">		<span class="built_in">dfs</span>(i);</span><br><span class="line">	<span class="keyword">while</span>(!st.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">		<span class="keyword">if</span>(!ans[st.<span class="built_in">top</span>()])</span><br><span class="line">			<span class="built_in">dfs2</span>(st.<span class="built_in">top</span>(), ++t);</span><br><span class="line">		st.<span class="built_in">pop</span>();</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	cout &lt;&lt; t &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">		cout &lt;&lt; ans[i] &lt;&lt; <span class="string">&quot; \n&quot;</span>[i == n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>TIOJ</tag>
        <tag>SCC</tag>
        <tag>Topological</tag>
      </tags>
  </entry>
  <entry>
    <title>KMP</title>
    <url>/KMP/</url>
    <content><![CDATA[<h1 id="這只是模板"><a href="#這只是模板" class="headerlink" title="這只是模板"></a>這只是模板</h1><span id="more"></span>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">kmp</span><span class="params">(string &amp;s)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n = s.<span class="built_in">size</span>();</span><br><span class="line">	<span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">dp</span><span class="params">(n)</span></span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>, j = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">		<span class="keyword">while</span>(j &amp;&amp; s[i] != s[j])</span><br><span class="line">			j = dp[j - <span class="number">1</span>];</span><br><span class="line">		<span class="keyword">if</span>(s[i] == s[j])</span><br><span class="line">			j++;</span><br><span class="line">		dp[i] = j;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> dp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="字串比對"><a href="#字串比對" class="headerlink" title="字串比對"></a>字串比對</h1><p>從$t$中找有幾個子字串==$s$：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">vector&lt;<span class="keyword">int</span>&gt; w = <span class="built_in">kmp</span>(s);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>, j =<span class="number">0</span>; i &lt; t.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">	<span class="keyword">while</span>(j &amp;&amp; t[i] != s[j])</span><br><span class="line">		j = w[j - <span class="number">1</span>];</span><br><span class="line">	<span class="keyword">if</span>(t[i] == s[j])</span><br><span class="line">		j++;</span><br><span class="line">	<span class="keyword">if</span>(j == s.<span class="built_in">size</span>())</span><br><span class="line">		cnt++, j = w[j - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; cnt &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br></pre></td></tr></table></figure>
<p>其他應用待補</p>
<h1 id="題目"><a href="#題目" class="headerlink" title="題目"></a>題目</h1><ul>
<li><a href="https://tioj.ck.tp.edu.tw/problems/1306">TIOJ-1306</a></li>
</ul>
]]></content>
      <tags>
        <tag>string</tag>
        <tag>template</tag>
      </tags>
  </entry>
  <entry>
    <title>TIOJ-1737</title>
    <url>/TIOJ-1737/</url>
    <content><![CDATA[<p>給$n$家公司的座標，需要配置$k(k\le \lfloor{\frac{n}{2}}\rfloor)$個電纜，每個電纜必須連接兩家不同公司且每家公司只能被最多一條電纜相連。<br>求可達到的最小電纜總長。</p>
<span id="more"></span>
<p>$2\le n\le 10^5, 0\le a_i&lt;a_{i+1}\le 10^9\ \forall 1\le i&lt;n$</p>
<hr>
<p>查了解才知道怎麼做，因為是APIO題可以查到很多解&gt;&lt;<br>首先觀察到每條電纜肯定是連相鄰的兩家公司，否則你總是可以將它拆成比較小的。<br>這樣就有一個很好想的dp，令$dp[n][k]$為考慮第前$n$個點且已經連$k$條的最小成本，則<br>$$dp[n][k] = min(dp[n - 1][k], dp[n - 2][k - 1] + (a[n]-a[n-1]))$$<br>這樣就是一個$\mathcal{O}(NK)$的解，可以撈到60分。</p>
<p>至於滿分解，可以考慮greedy，每次不斷取最短距離的兩家公司，取過的不取。<br>而範側很佛心地告訴你這會爛。<br>2 1 2 6，如果取1後只能取6，然而更佳解是取2+2。<br>想一下為什麼這個會爛?<br>因為我們取了1之後旁邊兩個就不能取了，且對於當前最短的那條，如果他不取，那他<strong>左右兩條肯定會取</strong>(否則就能取最短這條來達成更佳解)。<br>因此我們要設計一個「反悔」的機會。<br>考慮相鄰三條a b c(b &lt; a,c)，取了b，連一條權重為a+c-b的邊在左右，代表改變方案。<br>然後就用pq不斷維護最小值，而連邊操作會改變每個點的左右是誰，所以用一個雙向的Linked List維護。<br>複雜度$\mathcal{O}(N+KlogN)$</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">--------------              |   /</span></span><br><span class="line"><span class="comment">      |                     |  /</span></span><br><span class="line"><span class="comment">      |                     | /</span></span><br><span class="line"><span class="comment">      |             *       |/          |    |         ------            *</span></span><br><span class="line"><span class="comment">      |                     |           |    |        /      \</span></span><br><span class="line"><span class="comment">      |             |       |\          |    |       |       |\          |</span></span><br><span class="line"><span class="comment">   \  |             |       | \         |    |       |       | \         |</span></span><br><span class="line"><span class="comment">    \ |             |       |  \        |    |        \     /   \        |</span></span><br><span class="line"><span class="comment">     V              |       |   \        \__/|         -----     \       |</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EmiliaMyWife ios::sync_with_stdio(0); cin.tie(NULL);</span></span><br><span class="line"><span class="keyword">using</span> ll = <span class="keyword">int64_t</span>;</span><br><span class="line"><span class="comment">/*-----------------------------------------------------------------------------------------------------*/</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">seg</span> &#123;</span></span><br><span class="line">	<span class="keyword">int</span> a, b, dis;</span><br><span class="line">	<span class="keyword">friend</span> <span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(seg ca, seg cb) &#123; <span class="keyword">return</span> ca.dis &gt; cb.dis; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123; EmiliaMyWife</span><br><span class="line">	<span class="keyword">int</span> n, k;</span><br><span class="line">	ll ans = <span class="number">0</span>;</span><br><span class="line">	cin &gt;&gt; n &gt;&gt; k;</span><br><span class="line">	<span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">arr</span><span class="params">(n)</span>, <span class="title">nxt</span><span class="params">(n)</span>, <span class="title">prv</span><span class="params">(n)</span>, <span class="title">dis</span><span class="params">(n)</span></span>;</span><br><span class="line">	<span class="function">vector&lt;<span class="keyword">bool</span>&gt; <span class="title">use</span><span class="params">(n)</span></span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">		cin &gt;&gt; arr[i], nxt[i] = i + <span class="number">1</span>, prv[i] = i - <span class="number">1</span>;</span><br><span class="line">	priority_queue&lt;seg&gt; pq;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++)</span><br><span class="line">		pq.<span class="built_in">push</span>(&#123;i - <span class="number">1</span>, i, dis[i] = arr[i] - arr[i - <span class="number">1</span>]&#125;);</span><br><span class="line">	<span class="keyword">while</span>(k &gt; <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="keyword">auto</span> w = pq.<span class="built_in">top</span>();</span><br><span class="line">		pq.<span class="built_in">pop</span>();</span><br><span class="line">		<span class="keyword">if</span>(use[w.a] || use[w.b])</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		ans += w.dis;</span><br><span class="line">		k--;</span><br><span class="line">		use[w.a] = use[w.b] = <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">int</span> l = prv[w.a], r = nxt[w.b];</span><br><span class="line">		<span class="keyword">if</span>(l&lt;<span class="number">0</span> || r==n)</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		dis[r] = dis[r] + dis[w.a] - w.dis; </span><br><span class="line">		nxt[l] = r;</span><br><span class="line">		prv[r] = l;</span><br><span class="line">		pq.<span class="built_in">push</span>(&#123;l, r, dis[r]&#125;);</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; ans &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>TIOJ</tag>
        <tag>greedy</tag>
        <tag>heap</tag>
        <tag>Linked List</tag>
        <tag>APIO</tag>
      </tags>
  </entry>
  <entry>
    <title>CF-808G</title>
    <url>/CF-808G/</url>
    <content><![CDATA[<p>給字串$s, t$，<br>$s$由小寫字母跟?組成，如果把?都換成小寫字母，問最多能有幾個子字串與$t$相等?  </p>
<span id="more"></span>
<p>$1\le |s|, |t|\le 10^5, |s|\cdot |t|\le 10^7$</p>
<hr>
<p>首先看到測資第二個限制就能猜到這是個可以用$\mathcal{O}(|s||t|)$解決的問題。<br/><br>以下字串$s, t$的索引值為從0開始，其餘則為1，<br/><br>所以就直接定義dp[n][m]代表考慮s前$n$個字元，且這個前綴的最後$m$個字元與$t$的前$m$個字元相等，轉移式則為：<br>$$dp[n + 1][nxt(m, s[n])] = dp[n][m] + (m = t.size() ? 1 : 0)\ if\ s[n] \neq ?$$<br>$$dp[n + 1][nxt(m, c)] = dp[n][m] + (m = t.size() ? 1 : 0) \forall c = a..z\ Otherwise$$<br>其中$nxt(i, j)$為如果前$i$個字元再加上$j$這個字元的話，相同的前後綴會變成多少。<br/><br>可以發現我們能用kmp來計算這函數，原理跟kmp蓋表類似。<br>而在dp時直接計算會使得轉移複雜度退化成$\mathcal{O}(|t|)$，所以必須先蓋表，但蓋表過程也是$\mathcal{O}(|t|^2)$。<br/><br>可是可以用dp來優化他，定義kmp的failure function為$f$，則<br>$$nxt(m, c) = m+1\ if\ t[m] = c$$<br>$$nxt(m, c) = nxt(f(m-1), c)\ Otherwise$$<br>這樣就能$\mathcal{O}(|t|)$建$nxt$，讓dp能$\mathcal{O}(1)$轉移，整體複雜度$\mathcal{O}(|s||t|)$  <br/></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">--------------              |   /</span></span><br><span class="line"><span class="comment">      |                     |  /</span></span><br><span class="line"><span class="comment">      |                     | /</span></span><br><span class="line"><span class="comment">      |             *       |/          |    |         ------            *</span></span><br><span class="line"><span class="comment">      |                     |           |    |        /      \</span></span><br><span class="line"><span class="comment">      |             |       |\          |    |       |       |\          |</span></span><br><span class="line"><span class="comment">   \  |             |       | \         |    |       |       | \         |</span></span><br><span class="line"><span class="comment">    \ |             |       |  \        |    |        \     /   \        |</span></span><br><span class="line"><span class="comment">     V              |       |   \        \__/|         -----     \       |</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EmiliaMyWife ios::sync_with_stdio(0); cin.tie(NULL);</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF     = <span class="number">0x3F3F3F3F</span>;</span><br><span class="line"><span class="comment">/*-----------------------------------------------------------------------------------------------------*/</span></span><br><span class="line"></span><br><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">kmp</span><span class="params">(string &amp;t)</span> </span>&#123;</span><br><span class="line">	<span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">dp</span><span class="params">(t.size())</span></span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>, j = <span class="number">0</span>; i &lt; t.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">		<span class="keyword">while</span>(j &amp;&amp; t[j] != t[i])</span><br><span class="line">			j = dp[j - <span class="number">1</span>];</span><br><span class="line">		<span class="keyword">if</span>(t[j] == t[i])</span><br><span class="line">			j++;</span><br><span class="line">		dp[i] = j;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> dp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123; EmiliaMyWife</span><br><span class="line">	string s, t;</span><br><span class="line">	cin &gt;&gt; s &gt;&gt; t;</span><br><span class="line">	vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">dp</span>(s.<span class="built_in">size</span>() + <span class="number">1</span>, vector&lt;<span class="keyword">int</span>&gt;(t.<span class="built_in">size</span>() + <span class="number">1</span>, -INF)), <span class="built_in">nxt</span>(t.<span class="built_in">size</span>() + <span class="number">1</span>, vector&lt;<span class="keyword">int</span>&gt;(<span class="number">26</span>));</span><br><span class="line">	dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">auto</span> f = <span class="built_in">kmp</span>(t);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= t.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">26</span>; j++) &#123;</span><br><span class="line">			<span class="keyword">char</span> c = <span class="string">&#x27;a&#x27;</span> + j;</span><br><span class="line">			<span class="keyword">if</span>(i &lt; t.<span class="built_in">size</span>() &amp;&amp; t[i] == c)</span><br><span class="line">				nxt[i][j] = i + <span class="number">1</span>;</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span>(i)</span><br><span class="line">				nxt[i][j] = nxt[f[i - <span class="number">1</span>]][j];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">		dp[i][t.<span class="built_in">size</span>()]++;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= t.<span class="built_in">size</span>(); j++) &#123;</span><br><span class="line">			<span class="keyword">if</span>(s[i] == <span class="string">&#x27;?&#x27;</span>)</span><br><span class="line">				<span class="keyword">for</span>(<span class="keyword">int</span> c = <span class="number">0</span>; c &lt; <span class="number">26</span>; c++)</span><br><span class="line">					dp[i + <span class="number">1</span>][nxt[j][c]] = <span class="built_in">max</span>(dp[i + <span class="number">1</span>][nxt[j][c]], dp[i][j]);</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">				dp[i + <span class="number">1</span>][nxt[j][s[i] - <span class="string">&#x27;a&#x27;</span>]] = <span class="built_in">max</span>(dp[i + <span class="number">1</span>][nxt[j][s[i] - <span class="string">&#x27;a&#x27;</span>]], dp[i][j]);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	dp[s.<span class="built_in">size</span>()][t.<span class="built_in">size</span>()]++;</span><br><span class="line">	cout &lt;&lt; *<span class="built_in">max_element</span>(dp[s.<span class="built_in">size</span>()].<span class="built_in">begin</span>(), dp[s.<span class="built_in">size</span>()].<span class="built_in">end</span>()) &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>Codeforces</tag>
        <tag>string</tag>
      </tags>
  </entry>
  <entry>
    <title>109學年度北二區資訊學科能力競賽</title>
    <url>/109%E5%AD%B8%E5%B9%B4%E5%BA%A6%E5%8C%97%E4%BA%8C%E5%8D%80%E8%B3%87%E8%A8%8A%E5%AD%B8%E7%A7%91%E8%83%BD%E5%8A%9B%E7%AB%B6%E8%B3%BD/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>這次打得跟去年燒雞比起來好多了&gt;&lt;<br>以下題目可能會有雷</p>
<span id="more"></span>
<h1 id="題目"><a href="#題目" class="headerlink" title="題目"></a>題目</h1><h2 id="上午場-三小時-5題-每題20分"><a href="#上午場-三小時-5題-每題20分" class="headerlink" title="上午場(三小時 5題 每題20分)"></a>上午場(三小時 5題 每題20分)</h2><p>分數100/100</p>
<h3 id="pA-20-20"><a href="#pA-20-20" class="headerlink" title="pA 20/20"></a>pA 20/20</h3><blockquote>
<p>給兩個int範圍內的整數$a, b$，求有多少位元是$a$沒有$b$有的?</p>
</blockquote>
<p>基本上就考位元運算，<br>差不多這樣就能拿滿20。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123; EmiliaMyWife</span><br><span class="line">	<span class="keyword">int</span> a, b, c = <span class="number">0</span>;</span><br><span class="line">	cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">40</span>; i++)</span><br><span class="line">		<span class="keyword">if</span>(!(a &gt;&gt; i &amp; <span class="number">1</span>) &amp;&amp; (b &gt;&gt; i &amp; <span class="number">1</span>))</span><br><span class="line">			c++;</span><br><span class="line">	cout &lt;&lt; c &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="pB-20-20"><a href="#pB-20-20" class="headerlink" title="pB 20/20"></a>pB 20/20</h3><blockquote>
<p>給一個數字$N$，<br>對於一個tuple$(n1, n2, n3, n4, n5)$ $(1 \le n_1 &lt; n_2 &lt; n_3 &lt; n_4 &lt; n_5\le 30)$<br>定義以下數字:<br>a1=…<br>a2=…<br>a3=…<br>a4=…<br>a5=…<br>…代表運算細節，我忘了，不過只是拿那五個n來加減乘除。<br>求滿足a1+a2+a3+a4+a5=N的tuple數量的三次方<br>但如果數量為0，請輸出$N$乘三加上五</p>
</blockquote>
<p>巢狀迴圈…</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123; EmiliaMyWife</span><br><span class="line">	<span class="keyword">int</span> n, c = <span class="number">0</span>;</span><br><span class="line">	cin &gt;&gt; n;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> n1 = <span class="number">1</span>; n1 &lt;= <span class="number">30</span>; n1++) &#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> n2 = n1 + <span class="number">1</span>; n2 &lt;= <span class="number">30</span>; n2++) &#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> n3 = n2 + <span class="number">1</span>; n3 &lt;= <span class="number">30</span>; n3++) &#123;</span><br><span class="line">				<span class="keyword">for</span>(<span class="keyword">int</span> n4 = n3 + <span class="number">1</span>; n4 &lt;= <span class="number">30</span>; n4++) &#123;</span><br><span class="line">					<span class="keyword">for</span>(<span class="keyword">int</span> n5 = n4 + <span class="number">1</span>; n5 &lt;= <span class="number">30</span>; n5++) &#123;</span><br><span class="line">						<span class="keyword">int</span> a1 = ...;</span><br><span class="line">						<span class="keyword">int</span> a2 = ...;</span><br><span class="line">						<span class="keyword">int</span> a3 = ...;</span><br><span class="line">						<span class="keyword">int</span> a4 = ...;</span><br><span class="line">						<span class="keyword">int</span> a5 = ...;</span><br><span class="line">						<span class="keyword">if</span>(a1 + a2 + a3 + a4 + a5 == n)</span><br><span class="line">							c++;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(c)</span><br><span class="line">		cout &lt;&lt; c * c * c &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		cout &lt;&lt; n * <span class="number">3</span> + <span class="number">5</span> &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="pC-20-20"><a href="#pC-20-20" class="headerlink" title="pC 20/20"></a>pC 20/20</h3><blockquote>
<p>給一個凸多邊形上的$n$個頂點(不一定照順序)，再給$a, b$，求$max(ax+by), (x, y)\in \mathbb{Z}, (x,y)$在多邊形內，且還要輸出(x, y)。<br>$n\le 20, -10^5\le x_i,y_i\le 10^5$</p>
</blockquote>
<p>這題我是唬爛過去的，基本就是可以發現最佳解一定在凸包的最外圍(邊上or點上)，所以就直接模擬每個方向爬行(超級唬爛)。<br>聽到比較好的做法是枚舉x找上下兩點，更新答案。<br>p.s.直接代入所有頂點可以拿12分www</p>
<h3 id="pD-20-20"><a href="#pD-20-20" class="headerlink" title="pD 20/20"></a>pD 20/20</h3><p>原題目好多廢話(? 看不太懂<br>但總之就是：</p>
<blockquote>
<p>給四條長度不超過18的有序且無重複序列，序列中每個數字為1到25的整數。<br>然後給$n, h$。<br>問有多少序列滿足長度為$n$且為至少$h$條序列的子序列。</p>
</blockquote>
<p>因為數字只有25種，所以直接$2^{25}$爆搜，可以先把序列用位元存起來加快檢查速度。</p>
<h3 id="pE-20-20"><a href="#pE-20-20" class="headerlink" title="pE 20/20"></a>pE 20/20</h3><blockquote>
<p>給一個只有加和乘的數學算式(字串長度不超過1500，所以數字為int範圍內的正整數)，問答案的後五位數為多少。</p>
</blockquote>
<p>我是直接把字串輸入進來再手動切割，用stack存最後的數字來處理乘法，過程不斷%$10^5$，後來才知道可以直接交給cin，輸入好難ww。<br/><br>不過我一開始打錯字，變成%$10^4$，丟上去拿了16分，後來發現後改成$10^5$，結果變8分，把bug找出來後再丟還是8分，此時我覺得很怪，所以把修正bug後的版本再改成%$10^4$，然後AC…<br/><br>用提問系統跟他們反映這件事也只得到no comment，出來後的確有很多人被這題給卡爛，雖然後來有rejudge，但損失不輕。我也算運氣真好(X</p>
<h2 id="下午場-2小時-3題-1題20分"><a href="#下午場-2小時-3題-1題20分" class="headerlink" title="下午場(2小時 3題 1題20分)"></a>下午場(2小時 3題 1題20分)</h2><p>得分36/60，整個大燒雞。</p>
<h3 id="pA-12-20"><a href="#pA-12-20" class="headerlink" title="pA 12/20"></a>pA 12/20</h3><blockquote>
<p>給一個最高次為100的多項式函數，再給定$x, M(M &lt; 10)$，求$f(x)$的後$M$位(係數，x皆在int範圍)。<br>不足$M$位的地方要補0，<strong>如果函數值為負，那就得輸出負的值，但要把負號拿掉</strong>。<br>比如:答案為302，$M=2$，則輸出02。 答案為-205，$M=2$，則輸出05(不是95!)。</p>
</blockquote>
<p>因為我不會判斷正負數，所以只輸出正的然後拿12分。<br>原本以為要大數，出來後聽到一個做法是從高次往低次做，當前數字太大就可斷言正負，整個orz。</p>
<h3 id="pB-20-20-1"><a href="#pB-20-20-1" class="headerlink" title="pB 20/20"></a>pB 20/20</h3><blockquote>
<p>有$n$個消毒劑，消毒劑剛噴灑時會有係數$x$，且過了$t$時間後係數會變為$x-t$，給：<br/><br>每個消毒劑的噴灑時間和係數。<br>$y$，代表當前時間為第一次噴灑後過$y$時間。<br>問當前時間下所有消毒劑的係數總和為多少。</p>
</blockquote>
<p>數字範圍都沒給，不過其實直接$\mathcal{O}(n)$照做然後就能過了(?<br/><br>有個小陷阱就是第一次噴灑的時間不一定是0，所以不能直接拿$y$做，但是範測卻剛好都是0。</p>
<h3 id="pC-4-20"><a href="#pC-4-20" class="headerlink" title="pC 4/20"></a>pC 4/20</h3><blockquote>
<p>考慮某RSA加密，過程如下：<br>先選定兩個質數$p, q$，令$N=pq$。<br/><br>再找出兩個整數$e, d$，滿足$ed\equiv 1\mod (p-1)(q-1)$<br/><br>之後會有公開金鑰$N, e$，私密金鑰$N, d$。<br/><br>如果要加密的訊息為$m$，加密後為$c$，則有以下關係式<br>$$c=m^e\mod N$$<br>$$m=c^d\mod N$$<br>解密時，如果我們留著$p,q$，且定義$m_p=c^d\mod p, m_q=c^d\mod q$，那就可以利用中國剩餘定理解出$m$。<br/><br>而今天我們的$mp, mq$其中一個是錯誤的，想當然算出來的$m’$也會是錯誤的，給定$N, m’, e, c$，請還原出$p, q$。<br/><br>$N$為64位元範圍內的正整數。</p>
</blockquote>
<p>沒想法，我直接用根號對$N$做質因數分解拿4分，後來去問AC的人，她居然是用<a href="https://en.wikipedia.org/wiki/Pollard%27s_rho_algorithm">Pollard’s rho</a>對$N$做質因數分解ww。<br>結果還是討論不出要怎麼正常使用另外三個數字，甚至不知道題目說的中國剩餘定理要怎麼做。</p>
<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>最後是以136/160，rank 5收尾。<br>雖然我覺得一整個就是運氣ww(我沒被pE的錯誤測資卡到，且pC的唬爛作法直接過)。<br>題目部分是真的很糟糕，根本沒考什麼演算法或資結，就只是數學和爆搜，然後下午的第一三題變成決勝點= =; 怪題。<br>雖然去年燒雞燒超慘，但那題目寫起來才好玩QQ<br>但至少高中的競賽之旅應該…算踏上正軌了吧(?</p>
]]></content>
      <tags>
        <tag>Competitive Programming</tag>
        <tag>experience</tag>
      </tags>
  </entry>
  <entry>
    <title>TIOJ-1383</title>
    <url>/TIOJ-1383/</url>
    <content><![CDATA[<p>給一張$n$個節點的無向圖，再給$m$組$(a,b)$，代表$a$跟$b$之間有一條邊，問該圖是否為一棵合法二元搜索樹。</p>
<span id="more"></span>
<p>$1\le n\le 1000, 1\le m\le \frac{n(n-1)}{2}$</p>
<hr>
<p>分兩步驟，先確定她是一棵樹，再確認他是不是二元搜索樹。<br>樹只要滿足兩個條件:邊數==點數-1且任一一點dfs會遍歷所有點，但這裡的邊數要扣掉重邊，以題目敘述來說重邊要算同一條。<br>二元搜索樹有個性質:中序遍歷產生的序列會是排序好的，所以只要枚舉所有點當根來遍歷看看，稍微處理子節點數量超過兩個或者無法分成左右節點的情況就好。<br>複雜度$\mathcal{O}(n^2)$</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">--------------              |   /</span></span><br><span class="line"><span class="comment">      |                     |  /</span></span><br><span class="line"><span class="comment">      |                     | /</span></span><br><span class="line"><span class="comment">      |             *       |/          |    |         ------            *</span></span><br><span class="line"><span class="comment">      |                     |           |    |        /      \</span></span><br><span class="line"><span class="comment">      |             |       |\          |    |       |       |\          |</span></span><br><span class="line"><span class="comment">   \  |             |       | \         |    |       |       | \         |</span></span><br><span class="line"><span class="comment">    \ |             |       |  \        |    |        \     /   \        |</span></span><br><span class="line"><span class="comment">     V              |       |   \        \__/|         -----     \       |</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EmiliaMyWife ios::sync_with_stdio(0); cin.tie(NULL);</span></span><br><span class="line"><span class="keyword">using</span> ll = <span class="keyword">int64_t</span>;</span><br><span class="line"><span class="keyword">using</span> ull = <span class="keyword">uint64_t</span>;</span><br><span class="line"><span class="keyword">using</span> ld = <span class="keyword">long</span> <span class="keyword">double</span>;</span><br><span class="line"><span class="keyword">using</span> uint = <span class="keyword">uint32_t</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> EPS  = <span class="number">1e-8</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF     = <span class="number">0x3F3F3F3F</span>;</span><br><span class="line"><span class="keyword">const</span> ll LINF     = <span class="number">4611686018427387903</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MOD     = <span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="comment">/*-----------------------------------------------------------------------------------------------------*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">no</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;NO\n&quot;</span>; <span class="built_in">exit</span>(<span class="number">0</span>); &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123; EmiliaMyWife</span><br><span class="line">	<span class="keyword">int</span> n, m;</span><br><span class="line">	cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">	vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">edge</span>(n + <span class="number">1</span>);</span><br><span class="line">	<span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">arr</span><span class="params">(n + <span class="number">1</span>)</span></span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">		cin &gt;&gt; arr[i];</span><br><span class="line">	set&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; has;</span><br><span class="line">	<span class="keyword">int</span> w = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>, a, b; i &lt; m; i++) &#123;</span><br><span class="line">		cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line">		<span class="keyword">if</span>(a &gt; b)</span><br><span class="line">			<span class="built_in">swap</span>(a, b);</span><br><span class="line">		<span class="keyword">if</span>(has.<span class="built_in">count</span>(&#123;a, b&#125;))</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		w++;</span><br><span class="line">		has.<span class="built_in">insert</span>(&#123;a, b&#125;);</span><br><span class="line">		edge[a].<span class="built_in">push_back</span>(b);</span><br><span class="line">		edge[b].<span class="built_in">push_back</span>(a);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(w != n - <span class="number">1</span>)</span><br><span class="line">		<span class="built_in">no</span>();</span><br><span class="line">	<span class="function">vector&lt;<span class="keyword">bool</span>&gt; <span class="title">vis</span><span class="params">(n + <span class="number">1</span>)</span></span>;</span><br><span class="line">	<span class="keyword">const</span> function&lt;<span class="built_in"><span class="keyword">void</span></span>(<span class="keyword">int</span>)&gt; dfs = [&amp;] (<span class="keyword">int</span> u) &#123;</span><br><span class="line">		<span class="keyword">if</span>(vis[u])</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		vis[u] = <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> v : edge[u])</span><br><span class="line">			<span class="built_in">dfs</span>(v);</span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="built_in">dfs</span>(<span class="number">1</span>);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">		<span class="keyword">if</span>(!vis[i])</span><br><span class="line">			<span class="built_in">no</span>();</span><br><span class="line">	<span class="comment">//Make sure is a tree</span></span><br><span class="line">	</span><br><span class="line">	vector&lt;<span class="keyword">int</span>&gt; owo;</span><br><span class="line">	<span class="keyword">const</span> function&lt;<span class="built_in"><span class="keyword">bool</span></span>(<span class="keyword">int</span>, <span class="keyword">int</span>)&gt; bst = [&amp;] (<span class="keyword">int</span> u, <span class="keyword">int</span> p) &#123;</span><br><span class="line">		<span class="keyword">int</span> l = <span class="number">0</span>, r = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> v : edge[u]) &#123;</span><br><span class="line">			<span class="keyword">if</span>(v == p)</span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">			<span class="keyword">if</span>(arr[v] &gt;= arr[u]) &#123;</span><br><span class="line">				<span class="keyword">if</span>(r)</span><br><span class="line">					<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">				r = v;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="keyword">if</span>(l)</span><br><span class="line">					<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">				l = v;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">bool</span> ok = <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">if</span>(l)</span><br><span class="line">			ok &amp;= <span class="built_in">bst</span>(l, u);</span><br><span class="line">		owo.<span class="built_in">push_back</span>(arr[u]);</span><br><span class="line">		<span class="keyword">if</span>(r)</span><br><span class="line">			ok &amp;= <span class="built_in">bst</span>(r, u);</span><br><span class="line">		<span class="keyword">return</span> ok;</span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="keyword">bool</span> ok = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">		owo.<span class="built_in">clear</span>();</span><br><span class="line">		ok |= (<span class="built_in">bst</span>(i, i) &amp;&amp; <span class="built_in">is_sorted</span>(owo.<span class="built_in">begin</span>(), owo.<span class="built_in">end</span>()));</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(!ok)</span><br><span class="line">		<span class="built_in">no</span>();</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;YES\n&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>TIOJ</tag>
      </tags>
  </entry>
  <entry>
    <title>TIOJ-1106</title>
    <url>/TIOJ-1106/</url>
    <content><![CDATA[<p>給字串，代表一棵樹的euler tour，(代表進入一個子樹，)代表離開這個子樹，*代表來到一個葉節點。<br>求出這個樹的</p>
<ul>
<li>最大深度</li>
<li>葉節點數量</li>
<li>最多分枝的分枝數量</li>
</ul>
<span id="more"></span>
<p>$|s|\le 10^5$</p>
<hr>
<p>原本以為這是噁心實作題，實際寫了才發現蓋樹的code很短。<br>實作上，紀錄it代表目前走到字串的哪裡，t代表接下來的節點的編號。<br>接下來就直接dfs就好。<br>複雜度$\mathcal{O}(|s|)$</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EmiliaMyWife ios::sync_with_stdio(0); cin.tie(NULL);</span></span><br><span class="line"><span class="keyword">using</span> ll = <span class="keyword">int64_t</span>;</span><br><span class="line"><span class="comment">/*-----------------------------------------------------------------------------------------------------*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123; EmiliaMyWife</span><br><span class="line">	string s;</span><br><span class="line">	vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">edge</span>(<span class="number">100001</span>);</span><br><span class="line">	<span class="keyword">int</span> it, t, mx, dep, le;</span><br><span class="line">	<span class="keyword">const</span> function&lt;<span class="built_in"><span class="keyword">void</span></span>(<span class="keyword">int</span>)&gt; build = [&amp;] (<span class="keyword">int</span> u) &#123;</span><br><span class="line">		<span class="keyword">if</span>(s[it] == <span class="string">&#x27;*&#x27;</span>) &#123;</span><br><span class="line">			it++;</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		it++;</span><br><span class="line">		<span class="keyword">while</span>(s[it] != <span class="string">&#x27;)&#x27;</span>) &#123;</span><br><span class="line">			edge[u].<span class="built_in">push_back</span>(t);</span><br><span class="line">			<span class="built_in">build</span>(t++);</span><br><span class="line">		&#125;</span><br><span class="line">		it++;</span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="keyword">const</span> function&lt;<span class="built_in"><span class="keyword">void</span></span>(<span class="keyword">int</span>, <span class="keyword">int</span>)&gt; dfs = [&amp;] (<span class="keyword">int</span> u, <span class="keyword">int</span> d) &#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> v : edge[u])</span><br><span class="line">			<span class="built_in">dfs</span>(v, d + <span class="number">1</span>);</span><br><span class="line">		mx = max&lt;<span class="keyword">int</span>&gt;(mx, edge[u].<span class="built_in">size</span>());</span><br><span class="line">		<span class="keyword">if</span>(edge[u].<span class="built_in">empty</span>())</span><br><span class="line">			le++;</span><br><span class="line">		dep = <span class="built_in">max</span>(dep, d);</span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="keyword">while</span>(cin &gt;&gt; s) &#123;</span><br><span class="line">		it = <span class="number">0</span>, t = <span class="number">1</span>, mx = dep = le = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); i++)</span><br><span class="line">			edge[i].<span class="built_in">clear</span>();</span><br><span class="line">		<span class="built_in">build</span>(<span class="number">0</span>);</span><br><span class="line">		<span class="built_in">dfs</span>(<span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">		cout &lt;&lt; le &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; dep &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; mx &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>TIOJ</tag>
      </tags>
  </entry>
  <entry>
    <title>TIOJ-1922</title>
    <url>/TIOJ-1922/</url>
    <content><![CDATA[<p>給一個長度為$N$的序列<br/><br>$Q$筆詢問，每次給定$L,R$，定義$cnt_x$為$[L, R)$中$x$的出現次數<br/><br>回答$\sum cnt_x^2\times x$。<br/></p>
<span id="more"></span>
<p>$1\le N\le 4\times 10^4, 1\le Q\le 4\times 10^5$</p>
<hr>
<p>第一次看到這題完全沒想法@@，被捏了才知道。<br>因為需要的參數為出現次數，所以可以直接砸墨隊。<br>然後就是很標準的墨隊實作了。<br>複雜度的部分，原本我是取每塊大小為$\sqrt{N}$，這樣複雜度是$\mathcal{O}(Q\sqrt N)$，這題$Q$比$N$大很多，會吃TLE吃到爽。<br/><br>每塊大小改取$\frac{Q}{\sqrt N}$，複雜度變為$\mathcal{O}(N\sqrt Q)$，就能好好ac了(不過用vector還是會tle幾筆，得改成一般陣列)。<br/></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EmiliaMyWife ios::sync_with_stdio(0); cin.tie(NULL);</span></span><br><span class="line"><span class="comment">/*-----------------------------------------------------------------------------------------------------*/</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">query</span> &#123;</span></span><br><span class="line">	<span class="keyword">int</span> l, r, b, id;</span><br><span class="line">	<span class="keyword">friend</span> <span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(<span class="keyword">const</span> query &amp;a, <span class="keyword">const</span> query &amp;b) &#123;</span><br><span class="line">		<span class="keyword">return</span> a.b == b.b ? ((a.r &gt; b.r) ^ (a.b &amp; <span class="number">1</span>)) : a.b &lt; b.b;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">4e4</span> + <span class="number">25</span>, Q = <span class="number">4e5</span> + <span class="number">25</span>;</span><br><span class="line"><span class="keyword">int</span> arr[N], ans[Q], cnt[N], v[N];</span><br><span class="line">query que[Q];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123; EmiliaMyWife</span><br><span class="line">	<span class="keyword">int</span> n, q;</span><br><span class="line">	cin &gt;&gt; n &gt;&gt; q;</span><br><span class="line">	<span class="keyword">int</span> sz = <span class="built_in"><span class="keyword">int</span></span>(n / <span class="built_in">sqrt</span>(q)) + <span class="number">1</span>, cur = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">auto</span> get = [&amp;] (<span class="keyword">int</span> x) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1LL</span> * cnt[x] * cnt[x] % MOD * v[x] % MOD;</span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="keyword">auto</span> add = [&amp;] (<span class="keyword">int</span> x) &#123;</span><br><span class="line">		cur = (cur - <span class="built_in">get</span>(x) + MOD) % MOD;</span><br><span class="line">		cnt[x]++;</span><br><span class="line">		cur = (cur + <span class="built_in">get</span>(x)) % MOD;</span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="keyword">auto</span> sub = [&amp;] (<span class="keyword">int</span> x) &#123;</span><br><span class="line">		cur = (cur - <span class="built_in">get</span>(x) + MOD) % MOD;</span><br><span class="line">		cnt[x]--;</span><br><span class="line">		cur = (cur + <span class="built_in">get</span>(x)) % MOD;</span><br><span class="line">	&#125;;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">		cin &gt;&gt; arr[i], v[i] = arr[i];</span><br><span class="line">	<span class="built_in">sort</span>(v, v + n);</span><br><span class="line">	<span class="keyword">auto</span> v_end = <span class="built_in">unique</span>(v, v + n);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">auto</span> &amp;x : arr)</span><br><span class="line">		x = <span class="built_in">lower_bound</span>(v, v_end, x) - v;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; q; i++) &#123;</span><br><span class="line">		cin &gt;&gt; que[i].l &gt;&gt; que[i].r;</span><br><span class="line">		que[i].r--;</span><br><span class="line">		que[i].b = que[i].l / sz;</span><br><span class="line">		que[i].id = i;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> l = <span class="number">0</span>, r = <span class="number">-1</span>;</span><br><span class="line">	<span class="built_in">sort</span>(que, que + q);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; q; i++) &#123;</span><br><span class="line">		<span class="keyword">const</span> <span class="keyword">auto</span> &amp;x = que[i];</span><br><span class="line">		<span class="keyword">while</span>(r &lt; x.r)</span><br><span class="line">			<span class="built_in">add</span>(arr[++r]);</span><br><span class="line">		<span class="keyword">while</span>(l &gt; x.l)</span><br><span class="line">			<span class="built_in">add</span>(arr[--l]);</span><br><span class="line">		<span class="keyword">while</span>(r &gt; x.r)</span><br><span class="line">			<span class="built_in">sub</span>(arr[r--]);</span><br><span class="line">		<span class="keyword">while</span>(l &lt; x.l)</span><br><span class="line">			<span class="built_in">sub</span>(arr[l++]);</span><br><span class="line">		ans[x.id] = cur;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; q; i++)</span><br><span class="line">		cout &lt;&lt; ans[i] &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>TIOJ</tag>
        <tag>Mo</tag>
      </tags>
  </entry>
  <entry>
    <title>TIOJ-1976</title>
    <url>/TIOJ-1976/</url>
    <content><![CDATA[<p>給你$N$個線段$[l, r](1\le l\le r\le M)$，每條線段都有權重$w$。<br/><br>可以選擇一段區間$[s, t](s, t\in \mathbb{Z})$，並且價值為所有與這段區間有交集的權重總和。<br/><br>輸出最大可能價值。</p>
<span id="more"></span>
<p>$1\le N\le 10^5, 0\le M\le 10^9, -1000\le w\le 1000$</p>
<hr>
<p>子題中有其中一筆是l=r，可以讓人聯想到最大區間和問題。<br>不過我還是沒想法，所以只能問人QQ。<br>後來得知的作法是:枚舉最大連續和的右界$t$，注意到如果右界進入某條線段，那當前總和就要加上他的權重。<br/><br>如果右界離開了某個線段，他就會變成<strong>可能被選到</strong>的線段(因為如果左界$s$超過那條線段的$r$就會選到那條線段)。<br/><br>所以可以用一個線段樹，只要離開某條線段就把區間[0, r](1 indexed)給加上他的權重。<br>左界就是線段樹詢問RMQ問[0, i]的最大值。<br>然而座標範圍很大，必須離散化，如果單單只存左右端點就會爛掉(範測2就是反例)。<br>所以我的做法是把左端點+1和右端點+1都給放到離散後的座標軸。<br>複雜度$\mathcal{O}(NlogN)$</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EmiliaMyWife ios::sync_with_stdio(0); cin.tie(NULL);</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF     = <span class="number">0x3F3F3F3F</span>;</span><br><span class="line"><span class="comment">/*--------------------------------------------------------------------------------------*/</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">line</span> &#123;</span></span><br><span class="line">	<span class="keyword">int</span> l, r, c;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">4e5</span> + <span class="number">25</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">segtree</span> &#123;</span></span><br><span class="line">	<span class="keyword">int</span> arr[N &lt;&lt; <span class="number">1</span>], tag[N], n;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> _n)</span> </span>&#123; n = _n; &#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">upd</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">		arr[p] += v;</span><br><span class="line">		<span class="keyword">if</span>(p &lt; n)</span><br><span class="line">			tag[p] += v;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> h = __lg(p); ~h; h--) &#123;</span><br><span class="line">			<span class="keyword">int</span> i = p &gt;&gt; h;</span><br><span class="line">			<span class="keyword">if</span>(!tag[i &gt;&gt; <span class="number">1</span>])</span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">			<span class="built_in">upd</span>(i, tag[i &gt;&gt; <span class="number">1</span>]);</span><br><span class="line">			<span class="built_in">upd</span>(i ^ <span class="number">1</span>, tag[i &gt;&gt; <span class="number">1</span>]);</span><br><span class="line">			tag[i &gt;&gt; <span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">pull</span><span class="params">(<span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">for</span>(; p &gt; <span class="number">1</span>; p &gt;&gt;= <span class="number">1</span>)</span><br><span class="line">			arr[p &gt;&gt; <span class="number">1</span>] = <span class="built_in">max</span>(arr[p], arr[p ^ <span class="number">1</span>]) + tag[p &gt;&gt; <span class="number">1</span>];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">edt</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> tl = l + n, tr = r + n - <span class="number">1</span>;</span><br><span class="line">		<span class="built_in">push</span>(tl);</span><br><span class="line">		<span class="built_in">push</span>(tr);</span><br><span class="line">		<span class="keyword">for</span>(l += n, r += n; l &lt; r; l &gt;&gt;= <span class="number">1</span>, r &gt;&gt;= <span class="number">1</span>) &#123;</span><br><span class="line">			<span class="keyword">if</span>(l &amp; <span class="number">1</span>)</span><br><span class="line">				<span class="built_in">upd</span>(l++, v);</span><br><span class="line">			<span class="keyword">if</span>(r &amp; <span class="number">1</span>)</span><br><span class="line">				<span class="built_in">upd</span>(--r, v);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">pull</span>(tl);</span><br><span class="line">		<span class="built_in">pull</span>(tr);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">que</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">		<span class="built_in">push</span>(l += n);</span><br><span class="line">		<span class="built_in">push</span>((r += n) - <span class="number">1</span>);</span><br><span class="line">		<span class="keyword">int</span> res = -INF;</span><br><span class="line">		<span class="keyword">for</span>(; l &lt; r; l &gt;&gt;= <span class="number">1</span>, r &gt;&gt;= <span class="number">1</span>) &#123;</span><br><span class="line">			<span class="keyword">if</span>(l &amp; <span class="number">1</span>)</span><br><span class="line">				res = <span class="built_in">max</span>(res, arr[l++]);</span><br><span class="line">			<span class="keyword">if</span>(r &amp; <span class="number">1</span>)</span><br><span class="line">				res = <span class="built_in">max</span>(res, arr[--r]);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> res;</span><br><span class="line">	&#125;</span><br><span class="line">&#125; tree;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123; EmiliaMyWife</span><br><span class="line">	<span class="keyword">int</span> n;</span><br><span class="line">	cin &gt;&gt; n;</span><br><span class="line">	<span class="function">vector&lt;line&gt; <span class="title">arr</span><span class="params">(n)</span></span>;</span><br><span class="line">	vector&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">		cin &gt;&gt; arr[i].l &gt;&gt; arr[i].r &gt;&gt; arr[i].c;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">		v.<span class="built_in">push_back</span>(arr[i].l);</span><br><span class="line">		v.<span class="built_in">push_back</span>(arr[i].r);</span><br><span class="line">		v.<span class="built_in">push_back</span>(arr[i].l + <span class="number">1</span>);</span><br><span class="line">		v.<span class="built_in">push_back</span>(arr[i].r + <span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">sort</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>());</span><br><span class="line">	v.<span class="built_in">resize</span>(<span class="built_in">unique</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>()) - v.<span class="built_in">begin</span>());</span><br><span class="line">	<span class="keyword">int</span> m = v.<span class="built_in">size</span>();</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">		arr[i].l = <span class="built_in">lower_bound</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), arr[i].l) - v.<span class="built_in">begin</span>();</span><br><span class="line">		arr[i].r = <span class="built_in">lower_bound</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), arr[i].r) - v.<span class="built_in">begin</span>();</span><br><span class="line">	&#125;</span><br><span class="line">	vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">enter</span>(m), <span class="built_in">left</span>(m + <span class="number">1</span>);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">		enter[arr[i].l].<span class="built_in">push_back</span>(arr[i].c);</span><br><span class="line">		left[arr[i].r + <span class="number">1</span>].<span class="built_in">push_back</span>(arr[i].c);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> ans = <span class="number">0</span>, sum = <span class="number">0</span>;</span><br><span class="line">	tree.<span class="built_in">init</span>(m + <span class="number">1</span>);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> v : enter[i])</span><br><span class="line">			sum += v;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> v : left[i]) &#123;</span><br><span class="line">			sum -= v;</span><br><span class="line">			tree.<span class="built_in">edt</span>(<span class="number">0</span>, i, v);</span><br><span class="line">		&#125;</span><br><span class="line">		ans = <span class="built_in">max</span>(ans, sum + tree.<span class="built_in">que</span>(<span class="number">0</span>, i + <span class="number">1</span>));</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; ans &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>TIOJ</tag>
        <tag>segment tree</tag>
      </tags>
  </entry>
  <entry>
    <title>TIOJ-2044</title>
    <url>/TIOJ-2044/</url>
    <content><![CDATA[<p>給一個$n\times m$的矩陣。<br/><br>問該矩陣是否滿足每一條由左上到右下的對角線的數字都一樣。<br><strong>記憶體上限為1M</strong></p>
<span id="more"></span>
<p>$1\le N\times M\le 10^6$</p>
<hr>
<p>乍看之下非常簡單的一題。<br>然而1M的記憶體上限甚至連開$10^6$的int陣列都會TLE。<br/><br>那該怎麼辦呢?</p>
<p>實際上你會發現，我們只是要比對這一列的第二項到最後一項是不是跟上一列的第一項到倒數第二項一樣。<br>既然要比對，又要省空間–rolling hash!<br>就能做到時間複雜度$\mathcal{O}(NM)$，空間複雜度$\mathcal{O}(1)$。<br/><br>因為很怕被卡常，所以寫了輸入優化，但我猜沒有優化單用printf scanf應該是可以的(?</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">char</span> c = <span class="built_in">getchar</span>();</span><br><span class="line">	<span class="keyword">while</span>(c &gt; <span class="string">&#x27;9&#x27;</span> || c &lt; <span class="string">&#x27;0&#x27;</span>)</span><br><span class="line">		c = <span class="built_in">getchar</span>();</span><br><span class="line">	<span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>(c &lt;= <span class="string">&#x27;9&#x27;</span> &amp;&amp; c &gt;= <span class="string">&#x27;0&#x27;</span>) &#123;</span><br><span class="line">		res = res * <span class="number">10</span> + (c ^ <span class="number">48</span>);</span><br><span class="line">		c = <span class="built_in">getchar</span>();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">int</span> C = <span class="number">1e9</span> + <span class="number">151</span>, MOD = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> t = <span class="built_in">read</span>();</span><br><span class="line">	<span class="keyword">while</span>(t--) &#123;</span><br><span class="line">		<span class="keyword">int</span> n = <span class="built_in">read</span>(), m = <span class="built_in">read</span>();</span><br><span class="line">		<span class="keyword">bool</span> ok = <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">long</span> <span class="keyword">long</span> prv;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">			<span class="keyword">long</span> <span class="keyword">long</span> cur = <span class="number">0</span>, xcur = <span class="number">0</span>;</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>, w; j &lt; m; j++) &#123;</span><br><span class="line">				w = <span class="built_in">read</span>();</span><br><span class="line">				<span class="keyword">if</span>(j)</span><br><span class="line">				 cur = (cur * C + w) % MOD;</span><br><span class="line">				<span class="keyword">if</span>(j &lt; m - <span class="number">1</span>)</span><br><span class="line">					xcur = (xcur * C + w) % MOD;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span>(i)</span><br><span class="line">				ok &amp;= prv == cur;</span><br><span class="line">			prv = xcur;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">puts</span>(ok ? <span class="string">&quot;Yes&quot;</span> : <span class="string">&quot;No&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>TIOJ</tag>
        <tag>Hash</tag>
        <tag>NPSC</tag>
      </tags>
  </entry>
  <entry>
    <title>TIOJ-1393</title>
    <url>/TIOJ-1393/</url>
    <content><![CDATA[<p>給一棵$N$個節點的樹，將最少點塗色，使得每個沒被塗色的點都至少跟一個塗色的點相鄰。<br/></p>
<span id="more"></span>
<p>$N\le 10000$</p>
<hr>
<p>這題有個專有名詞叫樹上最少獨立集。<br>可以考慮dp，令dp[i]<br>[0]: 該點塗色。<br>[1]: 該點不塗色，且子節點至少有一個有塗色。<br>[2]: 該點不塗色，且子節點也都不塗。<br>令節點1為根，答案就會是min(dp[1][0], dp[1][1])，dp[1][2]為不符合要求的，所以不能當答案。<br>接著是轉移，令v為i的所有子節點<br>$$dp[i][0]=1+\sum \min^2_{x=0}dp[v][x]$$<br>$$dp[i][2]=\sum dp[v][1]$$<br>剩下1的轉移，理想情況下<br>$$dp[i][1]=\sum min(dp[v][1], dp[v][0])$$<br>然而要考慮dp[v][0]的轉移數量，如果全部的轉移來源都是dp[v][1]，那就得使其中一個變成dp[v][0]，詳細看code(#<br>時間複雜度$\mathcal{O}(N)$</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">--------------              |   /</span></span><br><span class="line"><span class="comment">      |                     |  /</span></span><br><span class="line"><span class="comment">      |                     | /</span></span><br><span class="line"><span class="comment">      |             *       |/          |    |         ------            *</span></span><br><span class="line"><span class="comment">      |                     |           |    |        /      \</span></span><br><span class="line"><span class="comment">      |             |       |\          |    |       |       |\          |</span></span><br><span class="line"><span class="comment">   \  |             |       | \         |    |       |       | \         |</span></span><br><span class="line"><span class="comment">    \ |             |       |  \        |    |        \     /   \        |</span></span><br><span class="line"><span class="comment">     V              |       |   \        \__/|         -----     \       |</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EmiliaMyWife ios::sync_with_stdio(0); cin.tie(NULL);</span></span><br><span class="line"><span class="keyword">using</span> ll = <span class="keyword">int64_t</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF     = <span class="number">0x3F3F3F3F</span>;</span><br><span class="line"><span class="comment">/*--------------------------------------------------------------------------------------*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123; EmiliaMyWife</span><br><span class="line">	<span class="keyword">int</span> n;</span><br><span class="line">	<span class="keyword">while</span>(cin &gt;&gt; n) &#123;</span><br><span class="line">		vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">edge</span>(n + <span class="number">1</span>);</span><br><span class="line">		vector&lt;array&lt;ll, 3&gt;&gt; <span class="built_in">dp</span>(n + <span class="number">1</span>);</span><br><span class="line">		<span class="comment">//0: black</span></span><br><span class="line">		<span class="comment">//1: white and at least one son is black</span></span><br><span class="line">		<span class="comment">//2: white and sons are all white</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>, a, b; i &lt; n; i++) &#123;</span><br><span class="line">			cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line">			edge[a].<span class="built_in">push_back</span>(b);</span><br><span class="line">			edge[b].<span class="built_in">push_back</span>(a);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">const</span> function&lt;<span class="built_in"><span class="keyword">void</span></span>(<span class="keyword">int</span>, <span class="keyword">int</span>)&gt; dfs = [&amp;] (<span class="keyword">int</span> u, <span class="keyword">int</span> p) &#123;</span><br><span class="line">			dp[u][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">			ll res = INF, cnt = <span class="number">0</span>;</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> v : edge[u]) &#123;</span><br><span class="line">				<span class="keyword">if</span>(v == p)</span><br><span class="line">					<span class="keyword">continue</span>;</span><br><span class="line">				<span class="built_in">dfs</span>(v, u);</span><br><span class="line">				dp[u][<span class="number">0</span>] += *<span class="built_in">min_element</span>(dp[v].<span class="built_in">begin</span>(), dp[v].<span class="built_in">end</span>());</span><br><span class="line">				dp[u][<span class="number">1</span>] += dp[v][<span class="number">1</span>];</span><br><span class="line">				dp[u][<span class="number">2</span>] += dp[v][<span class="number">1</span>];</span><br><span class="line">				<span class="keyword">if</span>(dp[v][<span class="number">0</span>] &lt;= dp[v][<span class="number">1</span>])</span><br><span class="line">					cnt++, dp[u][<span class="number">1</span>] += dp[v][<span class="number">0</span>] - dp[v][<span class="number">1</span>];</span><br><span class="line">				<span class="keyword">else</span></span><br><span class="line">					res = <span class="built_in">min</span>(res, dp[v][<span class="number">0</span>] - dp[v][<span class="number">1</span>]);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span>(!cnt)</span><br><span class="line">				dp[u][<span class="number">1</span>] += res;</span><br><span class="line">		&#125;;</span><br><span class="line">		<span class="built_in">dfs</span>(<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">		cout &lt;&lt; <span class="built_in">min</span>(dp[<span class="number">1</span>][<span class="number">0</span>], dp[<span class="number">1</span>][<span class="number">1</span>]) &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>TIOJ</tag>
        <tag>dp</tag>
        <tag>tree</tag>
      </tags>
  </entry>
  <entry>
    <title>2020NPSC</title>
    <url>/2020NPSC/</url>
    <content><![CDATA[<p><a href="https://drive.google.com/drive/u/1/folders/11LeZDxxybdHfWfH3wWemd8cD4QCtQhNO">code與題本與記分板</a><br>這裡是比賽過程OuO</p>
<span id="more"></span>
<h1 id="初賽"><a href="#初賽" class="headerlink" title="初賽"></a>初賽</h1><p>其實我有點沒印象了 燒雞</p>
<h2 id="第一小時"><a href="#第一小時" class="headerlink" title="第一小時"></a>第一小時</h2><p>剛開賽時我的肚子開始作痛<br>然後我就去廁所蹲了十幾分鐘QQ<br>出來後發現隊友把pB做掉了 電死<br>這時看計分板大家都只有pB 所以只好先把題目開完<br>由於我負責的部分是後半段的題目<br>pG題目好長所以我直接跳過 pF看了還沒什麼想法 pE一臉墨隊但我不會做<br>想到這裡就發現得燒雞了@@ 記分板情況是pB很多人過 pG只有wiwiho那隊過了<br>此時隊友丟給我pA 然後claim各種怪公式解 可是我看起來就很像數論分塊然後差分= =; 但由於還是得推式子很麻煩 所以先丟到旁邊<br>後來發現有人pA過了 可是我還沒推出式子 所以決定去認真看pG<br>看完發現是用map之類的維護他們的線段 應該算是經典手法吧XD<br>原本想了個比較複雜的維護方法 幸好隊友幫我矯正回來了 感謝&gt;&lt;<br>之後就開始寫 然後學弟在寫pC</p>
<h2 id="第二小時"><a href="#第二小時" class="headerlink" title="第二小時"></a>第二小時</h2><p>實作能力燒雞@@<br>pG寫出一堆BUG 一直亂改亂改<br>到了一小時半才過<br>submit前發現可以用stack就好 map還會多帶一個log<br>但是秉持著<del>log只是常數</del>的精神 先丟一次看看 幸好有過<br>此時的記分板是pB最多 pG次多 pCpApF各有幾個過<br>因為還是不想推式子所以先去想F<br>然後學弟就說pC他寫不出來 我就接手了<br>發現只是維護狀態的bfs 但是有向量旋轉欸@@<br>原本一直在紙上畫各種例子找規律看向量會怎麼轉<br>結果隊友就用了翻轉矩陣得出逆時針90度是(-y, x)，所以就開始寫了</p>
<h2 id="第三小時"><a href="#第三小時" class="headerlink" title="第三小時"></a>第三小時</h2><p>實作能力還是在燒雞 也是一堆bug<br>後來終於過了範測 也一發 開心&gt;&lt;<br>此時記分板也已經不少人寫出pApF了<br>於是就交錯一直想<br>pF想到離線照v排序然後維護每個點往後k個的數量<br>可是我不會找有沒有出現c OAO</p>
<h2 id="第四小時"><a href="#第四小時" class="headerlink" title="第四小時"></a>第四小時</h2><p>pF想不出來 於是只好回去看A<br>花了快十分鐘終於把式子弄出來了<br>寫出來發現是爛的QQ<br>結果是沒有處理到首相<br>然後還是爛 亂改亂改<br>也不確認複雜度就丟了<br>不過一發AC 神奇<br>結束前8分鐘過了 超刺激</p>
<h2 id="summary"><a href="#summary" class="headerlink" title="summary"></a>summary</h2><p>初賽寫太慢了@@<br>一整個不滿意 雖然有進決賽就好<br>後來發現pF我想的是對的 而找出有沒有出現c只需要維護最大最小直 超合理orzzz<br>pE的確是墨隊 但是好像得搭配treap吧<br>pD沒看 期望值超難</p>
<h1 id="決賽"><a href="#決賽" class="headerlink" title="決賽"></a>決賽</h1><p>決賽在台大!!<br>又可以去台北玩了 開心<br>決賽是五個小時 很少打五個小時 也算是種學習吧!</p>
<h2 id="測機"><a href="#測機" class="headerlink" title="測機"></a>測機</h2><p>測測看vimrc要打多久 結果比我想得久超多<br>又因為超緊張 且鍵盤不習慣 導致一直打錯字之類的<br>後來覺得把整串打完太花時間 所以括號補上的map就沒打了<br>測機的互動二分搜題還一直wa 結果是我在戳 笑死</p>
<h2 id="第一小時-1"><a href="#第一小時-1" class="headerlink" title="第一小時"></a>第一小時</h2><p>開場先去打vimrc<br>結果發現他沒重製<br>所以就把括號補上那串也打完 然後打default code<br>看記分板已經有人開出pBpC了<br>隊友看完pB發現是greedy水堤<br>結果我沒注意n=1<br>WA一次後還以為是STL在雷我 改一改上傳又吃WA<br>de好久bug才想到N=1 雷<br>pB超慢 penalty又超多 我超級荒<br>後來去看C<br>發現他也是維護線段然後雙指針就好<br>寫完後測範測有過 就submit了<br>結果直接WA 心態更不穩<br>發現一堆bug 修完後隊友丟個測資又爛掉 為啥這範測這麼容易過啊 QQ<br>WA兩次後先去看F<br>F給了很噁心的隨機生測資的code<br>然後隊友在想共點的Case怎麼做<br>我是想到維護各個共點的時間點 但我發現記分板好多人都寫超快@@ 應該不會是這樣<br>後來想到共點之後的時間只會讓共點變少 到最後交點數量應該會是n(n-1)<br>隊友還不相信(雖然我也不太相信 畢竟用猜的)<br>不過我決定信信看自己 就說我先砸砸看 WA了再說(超級霸氣XDD)</p>
<h2 id="第二小時-1"><a href="#第二小時-1" class="headerlink" title="第二小時"></a>第二小時</h2><p>pF過了~~ 有夠梗<br>後來去修pC 在把一些地方改一下也過了<br>但是penalty還是真的太高 一直WA<br>記分板目前是大家都寫ABCF<br>去看了pA 亂claim greedy的塗法<br>就過了 其實我也不知道是不是假解<br>我甚至沒發現他是仙人掌圖@@<br>之後看大家燒雞 我就只好先撿看來比較可做的pDE<br>然後發現pG是密碼學 就丟給打ctf的學弟(超級慚愧 這題根本跟密碼學無關QQ)</p>
<h2 id="第三小時-1"><a href="#第三小時-1" class="headerlink" title="第三小時"></a>第三小時</h2><p>pE只想到trie然後壓常<br>所以就寫完後一直壓 但過不了<br>之後看到有人pE過了 所以我在想有其他做法</p>
<h2 id="第四小時-1"><a href="#第四小時-1" class="headerlink" title="第四小時"></a>第四小時</h2><p>想不到QQ<br>記分板大家都是做E或砸DG<br>所以我也去想了一下DG<br>才發現G跟密碼學根本無關</p>
<h2 id="第五小時"><a href="#第五小時" class="headerlink" title="第五小時"></a>第五小時</h2><p>燒雞<br>每題都沒什麼想法<br>五小時的比賽果然超累<br>看了pH 果然難 感覺就是防破台 所以也沒特別去想<br>pD想到邊數應該只會有根號種<br>pG想到應該是有環<br>但都跟正解還是差太多了<br>之後就這樣結束ㄌ@@</p>
<h2 id="summary-1"><a href="#summary-1" class="headerlink" title="summary"></a>summary</h2><p>pE是hash 但我沒想過可以這樣用 學到了新東西<br>pDpG都是噁噁的東西 其實我也沒很懂<br>pH果然是防破台(雖然DG就已經滅台了) 超噁的資結題 賽中根本寫不完吧</p>
<h1 id="summary-2"><a href="#summary-2" class="headerlink" title="summary"></a>summary</h1><p>今年NPSC能進決賽已經很開心了<br>去年甚至初賽就燒雞<br>做題速度的確不夠快<br>邊界case真的要多注意點<br>其實從npsc開始我才覺得高中的競賽之路有在走了(區賽是剛起步 npsc是正在走(? )<br>希望之後也能好好走下去&gt;&lt;</p>
]]></content>
      <tags>
        <tag>experience</tag>
        <tag>NPSC</tag>
      </tags>
  </entry>
  <entry>
    <title>TIOJ-1171</title>
    <url>/TIOJ-1171/</url>
    <content><![CDATA[<p>給一棵$N$個節點的樹(每條邊有權重$L_i$)，每個節點都是白色，以及$Q$筆操作。<br/><br>1 x – 將點$x$塗成黑色<br/><br>2 x – 詢問點$x$到所有黑點的總和<br/></p>
<span id="more"></span>
<p>$1\le N\le 10^5, 1\le Q\le 10^6, 1\le L_i\le 10^7$</p>
<hr>
<p>重心剖分的經典題<br>將點$x$到其他點的路徑以$x$到該點的LCA分類，可以發現那些LCA正好會是$x$在重心樹上的祖先。<br/><br>令$sum_{u, v}$為重心樹上$u$為根節點的子樹裡黑點到$v$的總和，$cnt_u$為子樹內黑點的數量，$d_{u, v}$為$u$到$v$的距離<br/><br>若詢問的點為$x$，且令$q$為$p$在重心樹上的父節點($p$為$x$在重心樹上的所有祖先)，可以推出式子:<br>$$\sum (sum_{q, q} - sum_{p, q}) + (cnt_q - cnt_p) \times d_{x, q})$$<br>基本上就是不斷計算以$q$當根的答案，但還要扣掉自己所在的子樹($p$)的答案<br/><br>修改時可以很輕鬆地計算$sum_{q, q}$和$cnt_q$。<br/><br>而$d_{u, v}$可以在重心剖分時時暴力跑dfs。<br/><br>最麻煩的是$sum_{p, q}$，因為重心樹上的父子關係不等於原圖，所以$sum_{p, q}=sum_{p, p} + d_{p, q}\times cnt_p$這式子是不成立的。<br/><br>解決方法就是注意到$p$總是$q$的子節點(在重心樹上)，所以可以令$no_p = sum_{p, q}$，在將$x$塗色時時同時將$no_p$加上$d_{x, q}$就好。<br/><br>複雜度$\mathcal{O}((N+Q)logN)$。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">--------------              |   /</span></span><br><span class="line"><span class="comment">      |                     |  /</span></span><br><span class="line"><span class="comment">      |                     | /</span></span><br><span class="line"><span class="comment">      |             *       |/          |    |         ------            *</span></span><br><span class="line"><span class="comment">      |                     |           |    |        /      \</span></span><br><span class="line"><span class="comment">      |             |       |\          |    |       |       |\          |</span></span><br><span class="line"><span class="comment">   \  |             |       | \         |    |       |       | \         |</span></span><br><span class="line"><span class="comment">    \ |             |       |  \        |    |        \     /   \        |</span></span><br><span class="line"><span class="comment">     V              |       |   \        \__/|         -----     \       |</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EmiliaMyWife ios::sync_with_stdio(0); cin.tie(NULL);</span></span><br><span class="line"><span class="keyword">using</span> ll = <span class="keyword">int64_t</span>;</span><br><span class="line"><span class="keyword">using</span> ull = <span class="keyword">uint64_t</span>;</span><br><span class="line"><span class="keyword">using</span> ld = <span class="keyword">long</span> <span class="keyword">double</span>;</span><br><span class="line"><span class="keyword">using</span> uint = <span class="keyword">uint32_t</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> EPS  = <span class="number">1e-8</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF     = <span class="number">0x3F3F3F3F</span>;</span><br><span class="line"><span class="keyword">const</span> ll LINF     = <span class="number">4611686018427387903</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MOD     = <span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="comment">/*--------------------------------------------------------------------------------------*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span> + <span class="number">25</span>;</span><br><span class="line"></span><br><span class="line">vector&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; edge[N];</span><br><span class="line"><span class="keyword">int</span> pa[N], sz[N], cnt[N];</span><br><span class="line">ll dis[N], no[N];</span><br><span class="line">vector&lt;ll&gt; pa_dis[N];</span><br><span class="line"><span class="keyword">bool</span> vis[N], has[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> p)</span> </span>&#123; <span class="comment">// 重心剖分前紀錄子樹size</span></span><br><span class="line">	sz[u] = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">const</span> <span class="keyword">auto</span> &amp;w : edge[u])</span><br><span class="line">		<span class="keyword">if</span>(w.first != p &amp;&amp; !vis[w.first]) &#123;</span><br><span class="line">			<span class="built_in">dfs</span>(w.first, u);</span><br><span class="line">			sz[u] += sz[w.first];</span><br><span class="line">		&#125;</span><br><span class="line">	<span class="keyword">return</span> sz[u];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">centroid</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> p, <span class="keyword">int</span> n)</span> </span>&#123; <span class="comment">// 尋找重心</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">const</span> <span class="keyword">auto</span> &amp;w : edge[u])</span><br><span class="line">		<span class="keyword">if</span>(!vis[w.first] &amp;&amp; w.first != p &amp;&amp; sz[w.first] &gt; n / <span class="number">2</span>)</span><br><span class="line">			<span class="keyword">return</span> <span class="built_in">centroid</span>(w.first, u, n);</span><br><span class="line">	<span class="keyword">return</span> u;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">caldis</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> p, ll d)</span> </span>&#123; <span class="comment">// 計算對於每個點他到重心樹上的所有父節點的距離</span></span><br><span class="line">	pa_dis[u].<span class="built_in">push_back</span>(d);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">const</span> <span class="keyword">auto</span> &amp;w : edge[u])</span><br><span class="line">		<span class="keyword">if</span>(!vis[w.first] &amp;&amp; w.first != p)</span><br><span class="line">			<span class="built_in">caldis</span>(w.first, u, d + w.second);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cd</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> p)</span> </span>&#123; <span class="comment">// 重心剖分</span></span><br><span class="line">	<span class="keyword">int</span> n = <span class="built_in">dfs</span>(u, u);</span><br><span class="line">	u = <span class="built_in">centroid</span>(u, u, n);</span><br><span class="line">	vis[u] = <span class="number">1</span>;</span><br><span class="line">	pa[u] = p;</span><br><span class="line">	<span class="built_in">caldis</span>(u, u, <span class="number">0</span>);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">const</span> <span class="keyword">auto</span> &amp;w : edge[u]) &#123;</span><br><span class="line">		<span class="keyword">if</span>(vis[w.first])</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		<span class="built_in">cd</span>(w.first, u);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">edt</span><span class="params">(<span class="keyword">int</span> u)</span> </span>&#123; <span class="comment">// 修改</span></span><br><span class="line">	<span class="keyword">int</span> x = u;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> h = <span class="number">0</span>; ~u; u = pa[u], h++) &#123;</span><br><span class="line">		cnt[u]++;</span><br><span class="line">		dis[u] += pa_dis[x][h];</span><br><span class="line">		<span class="keyword">if</span>(h &lt; pa_dis[x].<span class="built_in">size</span>())</span><br><span class="line">			no[u] += pa_dis[x][h + <span class="number">1</span>]; <span class="comment">// no[u]代表在以u為根的子樹在以pa[u]為根的貢獻</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">query</span><span class="params">(<span class="keyword">int</span> u)</span> </span>&#123;</span><br><span class="line">	ll res = <span class="number">0</span>, curd = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> curcnt = <span class="number">0</span>, x = u;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> h = <span class="number">0</span>; ~u; u = pa[u], h++) &#123;</span><br><span class="line">		res += (dis[u] - curd) + (cnt[u] - curcnt) * pa_dis[x][h];</span><br><span class="line">		</span><br><span class="line">		curcnt = cnt[u];</span><br><span class="line">		curd = no[u];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123; EmiliaMyWife</span><br><span class="line">	<span class="keyword">int</span> n, q;</span><br><span class="line">	cin &gt;&gt; n &gt;&gt; q;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>, a, b, c; i &lt; n; i++) &#123;</span><br><span class="line">		cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;</span><br><span class="line">		edge[a].<span class="built_in">push_back</span>(&#123;b, c&#125;);</span><br><span class="line">		edge[b].<span class="built_in">push_back</span>(&#123;a, c&#125;);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">cd</span>(<span class="number">0</span>, <span class="number">-1</span>);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">		<span class="built_in">reverse</span>(pa_dis[i].<span class="built_in">begin</span>(), pa_dis[i].<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> t, x;</span><br><span class="line">	<span class="keyword">while</span>(q--) &#123;</span><br><span class="line">		cin &gt;&gt; t &gt;&gt; x;</span><br><span class="line">		<span class="keyword">if</span>(t == <span class="number">1</span>) &#123;</span><br><span class="line">			<span class="keyword">if</span>(has[x])</span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">			has[x] = <span class="number">1</span>;</span><br><span class="line">			<span class="built_in">edt</span>(x);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			cout &lt;&lt; <span class="built_in">query</span>(x) &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>TIOJ</tag>
        <tag>tree</tag>
        <tag>centroid decomposition</tag>
      </tags>
  </entry>
  <entry>
    <title>TIOJ-1069</title>
    <url>/TIOJ-1069/</url>
    <content><![CDATA[<p>給$n$個事件，每個事件發生在$t$時間點，座標$(x, y)$，<br/><br>對於每個事件，可以多派遣一個人去解決，或者讓已經去解決某個事件的人走過來(如果從事件$i$走到事件$j$，必須滿足$t_i&gt;t_j$且$|t_i-t_j|\ge |x_i-x_j|+|y_i-y_j|$)。<br/><br>問最少需要派遣幾個人才能完成所有事件。</p>
<span id="more"></span>
<p>$1\le n\le 1000, 0\le x,y\le 1000, 0\le t&lt; 1440$</p>
<hr>
<p>這題好棒!!<br>完全沒想到可以這樣做。</p>
<p>首先考慮建有向圖，如果可以從事件$i$走到事件$j$，就建一條$i\to j$的邊，這樣問題就變成在有向圖上找最少路徑覆蓋整張圖。<br/><br>然而這樣還不可做QQ，我們再把有向圖的入度出度拆成兩個點，每條$i\to j$的邊改成$i_{out}\to j_{in}$，可以發現這張圖會是二分圖(入度出度不會連邊)。<br/><br>而在圖上每多一條匹配，象徵意義就是完成事件$i$的人接著去做事件$j$，換句話說，就是可以少派遣一個人!<br/><br>所以答案會是n-匹配數，其中二分圖最大匹配我們使用匈牙利演算法。<br>複雜度$\mathcal{O}(VE)$。(理論上$E$是可以到$V^2$的，而$V=N\le 1000$，但是還是能過，匈牙利真神奇)</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">--------------              |   /</span></span><br><span class="line"><span class="comment">      |                     |  /</span></span><br><span class="line"><span class="comment">      |                     | /</span></span><br><span class="line"><span class="comment">      |             *       |/          |    |         ------            *</span></span><br><span class="line"><span class="comment">      |                     |           |    |        /      \</span></span><br><span class="line"><span class="comment">      |             |       |\          |    |       |       |\          |</span></span><br><span class="line"><span class="comment">   \  |             |       | \         |    |       |       | \         |</span></span><br><span class="line"><span class="comment">    \ |             |       |  \        |    |        \     /   \        |</span></span><br><span class="line"><span class="comment">     V              |       |   \        \__/|         -----     \       |</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EmiliaMyWife ios::sync_with_stdio(0); cin.tie(NULL);</span></span><br><span class="line"><span class="comment">/*--------------------------------------------------------------------------------------*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123; EmiliaMyWife</span><br><span class="line">	<span class="keyword">int</span> t;</span><br><span class="line">	cin &gt;&gt; t;</span><br><span class="line">	<span class="keyword">while</span>(t--) &#123;</span><br><span class="line">		<span class="keyword">int</span> n, ans;</span><br><span class="line">		cin &gt;&gt; n;</span><br><span class="line">		ans = n;</span><br><span class="line">		<span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">t</span><span class="params">(n)</span>, <span class="title">x</span><span class="params">(n)</span>, <span class="title">y</span><span class="params">(n)</span></span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">			cin &gt;&gt; t[i] &gt;&gt; x[i] &gt;&gt; y[i];</span><br><span class="line">		<span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">ais</span><span class="params">(n, <span class="number">-1</span>)</span>, <span class="title">bis</span><span class="params">(n, <span class="number">-1</span>)</span></span>;</span><br><span class="line">		vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">edge</span>(n);</span><br><span class="line">		<span class="function">vector&lt;<span class="keyword">bool</span>&gt; <span class="title">vis</span><span class="params">(n)</span></span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++)</span><br><span class="line">				<span class="keyword">if</span>(t[i] &lt; t[j] &amp;&amp; <span class="built_in">abs</span>(x[i] - x[j]) + <span class="built_in">abs</span>(y[i] - y[j]) &lt;= t[j] - t[i]) &#123;</span><br><span class="line">					edge[i].<span class="built_in">push_back</span>(j);</span><br><span class="line">					<span class="keyword">if</span>(!~ais[i] &amp;&amp; !~bis[j])</span><br><span class="line">						ais[bis[j] = i] = j, ans--;</span><br><span class="line">				&#125;</span><br><span class="line">		function&lt;<span class="built_in"><span class="keyword">bool</span></span>(<span class="keyword">int</span>)&gt; dfs = [&amp;] (<span class="keyword">int</span> u) &#123;</span><br><span class="line">			vis[u] = <span class="literal">true</span>;</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> v : edge[u])</span><br><span class="line">				<span class="keyword">if</span>(!~bis[v] || (!vis[bis[v]] &amp;&amp; <span class="built_in">dfs</span>(bis[v])))</span><br><span class="line">					<span class="keyword">return</span> ais[bis[v] = u] = v, <span class="literal">true</span>;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">		&#125;;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">			<span class="keyword">if</span>(!~ais[i] &amp;&amp; (<span class="built_in">fill</span>(vis.<span class="built_in">begin</span>(), vis.<span class="built_in">end</span>(), <span class="literal">false</span>), <span class="built_in">dfs</span>(i)))</span><br><span class="line">				ans--;</span><br><span class="line">		cout &lt;&lt; ans &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>TIOJ</tag>
        <tag>bipartite graph matching</tag>
      </tags>
  </entry>
  <entry>
    <title>TIOJ-1537</title>
    <url>/TIOJ-1537/</url>
    <content><![CDATA[<p>$n$筆測資<br/><br>給一個數字$L$，輸出所有集合，滿足集合內數字總和為$L$，集合內的數字皆為正整數，且集合大小大於一。<br/><br>輸出由數字小到數字大，且每個集合按照輸出的字典序排。</p>
<span id="more"></span>
<p>$1\le L\le 25, 1\le n\le 100$</p>
<hr>
<p>這似乎是某種經典問題，好像是整數拆分ㄅ。<br>只要遞迴爆搜就好。<br>但根據題目要求得把答案全部存起來，排序，再把重複的拿掉。<br>那如何實作才能避免這樣呢?<br>其實觀察到如果要根據答案輸出的話，所有數字都不可比前一個數字大(否則違反由小到大)，且越前面的數字會越多越小的數字(字典序)。<br>所以只要在遞迴時紀錄最後一項的答案，從那一個數字開始枚舉到當前所剩數字，終止條件為當前所剩數字等於0。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">--------------              |   /</span></span><br><span class="line"><span class="comment">      |                     |  /</span></span><br><span class="line"><span class="comment">      |                     | /</span></span><br><span class="line"><span class="comment">      |             *       |/          |    |         ------            *</span></span><br><span class="line"><span class="comment">      |                     |           |    |        /      \</span></span><br><span class="line"><span class="comment">      |             |       |\          |    |       |       |\          |</span></span><br><span class="line"><span class="comment">   \  |             |       | \         |    |       |       | \         |</span></span><br><span class="line"><span class="comment">    \ |             |       |  \        |    |        \     /   \        |</span></span><br><span class="line"><span class="comment">     V              |       |   \        \__/|         -----     \       |</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EmiliaMyWife ios::sync_with_stdio(0); cin.tie(NULL);</span></span><br><span class="line"><span class="keyword">using</span> ll = <span class="keyword">int64_t</span>;</span><br><span class="line"><span class="keyword">using</span> ull = <span class="keyword">uint64_t</span>;</span><br><span class="line"><span class="keyword">using</span> ld = <span class="keyword">long</span> <span class="keyword">double</span>;</span><br><span class="line"><span class="keyword">using</span> uint = <span class="keyword">uint32_t</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> EPS  = <span class="number">1e-8</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF     = <span class="number">0x3F3F3F3F</span>;</span><br><span class="line"><span class="keyword">const</span> ll LINF     = <span class="number">4611686018427387903</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MOD     = <span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="comment">/*--------------------------------------------------------------------------------------*/</span></span><br><span class="line"></span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> bg)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(!n) &#123;</span><br><span class="line">		<span class="keyword">if</span>(ans.<span class="built_in">size</span>() &lt;= <span class="number">1</span>)</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; ans.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">			cout &lt;&lt; ans[i];</span><br><span class="line">			<span class="keyword">if</span>(i + <span class="number">1</span> &lt; ans.<span class="built_in">size</span>())</span><br><span class="line">				cout &lt;&lt; <span class="string">&quot;, &quot;</span>;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">				cout &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = bg; i &lt;= n; i++) &#123;</span><br><span class="line">		ans.<span class="built_in">push_back</span>(i);</span><br><span class="line">		<span class="built_in">solve</span>(n - i, i);</span><br><span class="line">		ans.<span class="built_in">pop_back</span>();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123; EmiliaMyWife</span><br><span class="line">	<span class="keyword">int</span> t;</span><br><span class="line">	cin &gt;&gt; t;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= t; i++) &#123;</span><br><span class="line">		<span class="keyword">int</span> n;</span><br><span class="line">		cin &gt;&gt; n;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Plank &quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;:\n&quot;</span>;</span><br><span class="line">		<span class="built_in">solve</span>(n, <span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>TIOJ</tag>
      </tags>
  </entry>
  <entry>
    <title>TIOJ-1912</title>
    <url>/TIOJ-1912/</url>
    <content><![CDATA[<p>給一個有$n$位的正整數$s$，再給一個根$R$。<br/><br>把整數各位數加起來，得到新整數，再把那個新整數的各個位數加起來…直到該整數只剩一位。<br>插入單個數字到該整數中，使得最後那一位整數剛好等於根。<br>由小到大輸出所有可能的結果，且忽略最小及最大。</p>
<span id="more"></span>
<p>$2\le n\le 29, 0\le R\le 9$</p>
<hr>
<p>其實就是一個實作題，只要枚舉$n+1$個空格，再枚舉10個數字，然後檢查。<br/><br>因為$30\times 9=270$，所以只要不超過3次操作就能讓數字變到剩一位。<br/><br>但是可能會有重複的(ex. $s=333$，且再插入3，不管插在哪都是一樣的)。<br/><br>只要排序後再unique就好了。<br>複雜度似乎是$\mathcal{O}(n^3)$或$\mathcal{O}(n^2logn)$，不過在這題複雜度其實沒有很重要就是了。<br/><br>實作上，使用accumulate函式可以很漂亮的解決操作過程&gt;&lt;</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">--------------              |   /</span></span><br><span class="line"><span class="comment">      |                     |  /</span></span><br><span class="line"><span class="comment">      |                     | /</span></span><br><span class="line"><span class="comment">      |             *       |/          |    |         ------            *</span></span><br><span class="line"><span class="comment">      |                     |           |    |        /      \</span></span><br><span class="line"><span class="comment">      |             |       |\          |    |       |       |\          |</span></span><br><span class="line"><span class="comment">   \  |             |       | \         |    |       |       | \         |</span></span><br><span class="line"><span class="comment">    \ |             |       |  \        |    |        \     /   \        |</span></span><br><span class="line"><span class="comment">     V              |       |   \        \__/|         -----     \       |</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EmiliaMyWife ios::sync_with_stdio(0); cin.tie(NULL);</span></span><br><span class="line"><span class="keyword">using</span> ll = <span class="keyword">int64_t</span>;</span><br><span class="line"><span class="keyword">using</span> ull = <span class="keyword">uint64_t</span>;</span><br><span class="line"><span class="keyword">using</span> ld = <span class="keyword">long</span> <span class="keyword">double</span>;</span><br><span class="line"><span class="keyword">using</span> uint = <span class="keyword">uint32_t</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> EPS  = <span class="number">1e-8</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF     = <span class="number">0x3F3F3F3F</span>;</span><br><span class="line"><span class="keyword">const</span> ll LINF     = <span class="number">4611686018427387903</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MOD     = <span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="comment">/*--------------------------------------------------------------------------------------*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123; EmiliaMyWife</span><br><span class="line">	string s;</span><br><span class="line">	<span class="keyword">int</span> n, k;</span><br><span class="line">	cin &gt;&gt; n &gt;&gt; k &gt;&gt; s;</span><br><span class="line">	n--;</span><br><span class="line">	<span class="keyword">auto</span> proc = [&amp;] (<span class="keyword">const</span> string &amp;s) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">accumulate</span>(s.<span class="built_in">begin</span>(), s.<span class="built_in">end</span>(), <span class="number">0</span>, [&amp;] (<span class="keyword">int</span> a, <span class="keyword">char</span> c) &#123; <span class="keyword">return</span> a + (c ^ <span class="number">48</span>); &#125;);</span><br><span class="line">	&#125;;</span><br><span class="line">	vector&lt;string&gt; ans;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; i++) &#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">char</span> c = <span class="string">&#x27;0&#x27;</span>; c &lt;= <span class="string">&#x27;9&#x27;</span>; c++) &#123;</span><br><span class="line">			string owo = (i ? s.<span class="built_in">substr</span>(<span class="number">0</span>, i) : <span class="string">&quot;&quot;</span>) + c + (i &lt; n ? s.<span class="built_in">substr</span>(i, n - i) : <span class="string">&quot;&quot;</span>);</span><br><span class="line">			<span class="keyword">int</span> w = <span class="built_in">proc</span>(owo);</span><br><span class="line">			<span class="keyword">while</span>(w &gt; <span class="number">9</span>)</span><br><span class="line">				w = <span class="built_in">proc</span>(<span class="built_in">to_string</span>(w));</span><br><span class="line">			<span class="keyword">if</span>(w == k)</span><br><span class="line">				ans.<span class="built_in">push_back</span>(owo);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">sort</span>(ans.<span class="built_in">begin</span>(), ans.<span class="built_in">end</span>()); ans.<span class="built_in">erase</span>(<span class="built_in">unique</span>(ans.<span class="built_in">begin</span>(), ans.<span class="built_in">end</span>()), ans.<span class="built_in">end</span>());</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i + <span class="number">1</span> &lt; ans.<span class="built_in">size</span>(); i++)</span><br><span class="line">		cout &lt;&lt; ans[i] &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>TIOJ</tag>
      </tags>
  </entry>
  <entry>
    <title>TIOJ-2048</title>
    <url>/TIOJ-2048/</url>
    <content><![CDATA[<p>給一長度為$N$的序列，求最大不連續和(也就是取一段子序列(subsequence)滿足子序列不連續，且和為最大)。</p>
<span id="more"></span>
<p>$3\le N\le 10^6, |a_i|\le 10^9$</p>
<hr>
<p>因為還得紀錄是否連續，所以dp勢必無法只靠一維。<br>我在想有沒有只需要dp[N][2]的做法，但我想不到QQ，如果有人會還請指教。<br>我想到的作法是定義:<br>$dp[N][0]$為前面<strong>取過了</strong>，但這格不取。<br>$dp[N][1]$為以$N$為結尾的最大連續子數列(subarray)。<br/><br>$dp[N][2]$為考慮前$N$項的最大不連續和。<br/><br>預設都是$-\infty$。<br/><br>根據定義可以知道<br>$$dp[N][0]=\max (dp[N-1][0], dp[N-1][1])$$<br>$$dp[N][1]=\max (dp[N-1][1], 0) + a_N$$<br>$$dp[N][2]=\max (dp[N-1][0]+a_N, dp[N-1][2]+\max (0, a_N))$$<br>這樣複雜度就會是好好的$\mathcal{O}(N)$</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">--------------              |   /</span></span><br><span class="line"><span class="comment">      |                     |  /</span></span><br><span class="line"><span class="comment">      |                     | /</span></span><br><span class="line"><span class="comment">      |             *       |/          |    |         ------            *</span></span><br><span class="line"><span class="comment">      |                     |           |    |        /      \</span></span><br><span class="line"><span class="comment">      |             |       |\          |    |       |       |\          |</span></span><br><span class="line"><span class="comment">   \  |             |       | \         |    |       |       | \         |</span></span><br><span class="line"><span class="comment">    \ |             |       |  \        |    |        \     /   \        |</span></span><br><span class="line"><span class="comment">     V              |       |   \        \__/|         -----     \       |</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EmiliaMyWife ios::sync_with_stdio(0); cin.tie(NULL);</span></span><br><span class="line"><span class="keyword">using</span> ll = <span class="keyword">int64_t</span>;</span><br><span class="line"><span class="keyword">const</span> ll LINF     = <span class="number">4611686018427387903</span>;</span><br><span class="line"><span class="comment">/*--------------------------------------------------------------------------------------*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123; EmiliaMyWife</span><br><span class="line">	<span class="keyword">int</span> n;</span><br><span class="line">	cin &gt;&gt; n;</span><br><span class="line">	<span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">arr</span><span class="params">(n + <span class="number">1</span>)</span></span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">		cin &gt;&gt; arr[i];</span><br><span class="line">	vector&lt;array&lt;ll, 3&gt;&gt; <span class="built_in">dp</span>(n + <span class="number">1</span>, &#123;-LINF, -LINF, -LINF&#125;);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">		dp[i][<span class="number">0</span>] = <span class="built_in">max</span>(dp[i - <span class="number">1</span>][<span class="number">0</span>], dp[i - <span class="number">1</span>][<span class="number">1</span>]);</span><br><span class="line">		dp[i][<span class="number">1</span>] = max&lt;ll&gt;(dp[i - <span class="number">1</span>][<span class="number">1</span>], <span class="number">0</span>) + arr[i];</span><br><span class="line">		dp[i][<span class="number">2</span>] = <span class="built_in">max</span>(dp[i - <span class="number">1</span>][<span class="number">0</span>] + arr[i], dp[i - <span class="number">1</span>][<span class="number">2</span>] + <span class="built_in">max</span>(<span class="number">0</span>, arr[i]));</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; dp[n][<span class="number">2</span>] &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>TIOJ</tag>
        <tag>NPSC</tag>
        <tag>DP</tag>
      </tags>
  </entry>
  <entry>
    <title>TIOJ-1458</title>
    <url>/TIOJ-1458/</url>
    <content><![CDATA[<p>蜜蜂跟學妹很喜歡寫情書，在這資訊發達的時代，他們的情書當然不是傳統的輸信，而是用E-Mail傳送的。但蜜蜂很害羞，他不希望他的情書被駭客攔截，因此他決定把內容加密。他跟學妹發明了一種加密方法，他們要加密的文字只有大寫英文字母以及空白字元，首先將每個字元編號，空白編成0，A編成1，B編成2，…，Z編成26。再將編號轉為二進位後，以下圖的方式填入一個RxC的矩陣中：</p>
<span id="more"></span>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0 → 0 → 0 → 1</span><br><span class="line">　　　　　　　↓</span><br><span class="line">0 → 1 → 0　 0</span><br><span class="line">↑　　　　↓　↓</span><br><span class="line">0 　 0 ← 1 　0</span><br><span class="line">↑　　　　　　↓</span><br><span class="line">1 ← 0 ← 1 ← 0</span><br></pre></td></tr></table></figure>

<p>B = 00010, E = 00101, E = 00101</p>
<p>結尾不夠的部分就直接補0，範例中R=4且C=4，要編碼的字串為“BEE”，產生矩陣後，再一列一列的將數字接起來得到最後的編碼結果，因此“BEE”最後會得到的編碼字串是0001010000101010<br>$R, C\le 20, 5\times \sum |S|\le R\times C$</p>
<hr>
<p>首先是輸入，使用getline前要先cin.ignore()，我不太清楚哪裡爛掉，反正遇到輸入卡bug就先ignore(?<br>然後用一個字串把每個字元的二進位給接起來，並且補0，這樣就能直接用那個字串來填格子。<br>至於填格子的順序，我還沒想到一個好的迴圈可以處理他。<br>所以我是觀察到他會是先走右邊，不能的話就往下，不能的話就往左，再來往上…<br>所以就紀錄目前的方向，當不能走時(超出邊界or走過了)就順時針換個方向試試看。<br>然後把每行分別輸出就是答案。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">--------------              |   /</span></span><br><span class="line"><span class="comment">      |                     |  /</span></span><br><span class="line"><span class="comment">      |                     | /</span></span><br><span class="line"><span class="comment">      |             *       |/          |    |         ------            *</span></span><br><span class="line"><span class="comment">      |                     |           |    |        /      \</span></span><br><span class="line"><span class="comment">      |             |       |\          |    |       |       |\          |</span></span><br><span class="line"><span class="comment">   \  |             |       | \         |    |       |       | \         |</span></span><br><span class="line"><span class="comment">    \ |             |       |  \        |    |        \     /   \        |</span></span><br><span class="line"><span class="comment">     V              |       |   \        \__/|         -----     \       |</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EmiliaMyWife ios::sync_with_stdio(0); cin.tie(NULL);</span></span><br><span class="line"><span class="comment">/*--------------------------------------------------------------------------------------*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> d[<span class="number">4</span>][<span class="number">2</span>] = &#123;&#123;<span class="number">0</span>, <span class="number">1</span>&#125;, &#123;<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, <span class="number">-1</span>&#125;, &#123;<span class="number">-1</span>, <span class="number">0</span>&#125;&#125;; <span class="comment">//Right, Down, Left, Up</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123; EmiliaMyWife</span><br><span class="line">	<span class="keyword">int</span> t;</span><br><span class="line">	cin &gt;&gt; t;</span><br><span class="line">	<span class="keyword">auto</span> proc = [&amp;] (<span class="keyword">int</span> x) &#123;</span><br><span class="line">		string <span class="built_in">s</span>(<span class="number">5</span>, <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">4</span>; ~i; i--)</span><br><span class="line">			<span class="keyword">if</span>(x &gt;&gt; i &amp; <span class="number">1</span>)</span><br><span class="line">				s[<span class="number">4</span> - i] = <span class="string">&#x27;1&#x27;</span>;</span><br><span class="line">		<span class="keyword">return</span> s;</span><br><span class="line">	&#125;;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> tc = <span class="number">1</span>; tc &lt;= t; tc++) &#123;</span><br><span class="line">		cout &lt;&lt; tc &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">int</span> r, c;</span><br><span class="line">		<span class="keyword">auto</span> check = [&amp;] (<span class="keyword">int</span> x, <span class="keyword">int</span> y) &#123; <span class="keyword">return</span> x&gt;=<span class="number">0</span>&amp;&amp;x&lt;r&amp;&amp;y&gt;=<span class="number">0</span>&amp;&amp;y&lt;c; &#125;;</span><br><span class="line">		string s;</span><br><span class="line">		cin &gt;&gt; r &gt;&gt; c;</span><br><span class="line">		</span><br><span class="line">		cin.<span class="built_in">ignore</span>();</span><br><span class="line">		<span class="built_in">getline</span>(cin, s);</span><br><span class="line">		</span><br><span class="line">		string owo;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">char</span> c : s) &#123;</span><br><span class="line">			<span class="keyword">if</span>(c == <span class="string">&#x27; &#x27;</span>)</span><br><span class="line">				owo += <span class="built_in">proc</span>(<span class="number">0</span>);</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">				owo += <span class="built_in">proc</span>(c - <span class="string">&#x27;a&#x27;</span> + <span class="number">1</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">while</span>(owo.<span class="built_in">size</span>() &lt; r * c)</span><br><span class="line">			owo.<span class="built_in">push_back</span>(<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">		</span><br><span class="line">		<span class="function">vector&lt;string&gt; <span class="title">arr</span><span class="params">(r, string(c, <span class="string">&#x27;0&#x27;</span>))</span></span>;</span><br><span class="line">		vector&lt;vector&lt;<span class="keyword">bool</span>&gt;&gt; <span class="built_in">vis</span>(r, vector&lt;<span class="keyword">bool</span>&gt;(c));</span><br><span class="line">		<span class="keyword">int</span> x = <span class="number">0</span>, y = <span class="number">-1</span>, it = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">char</span> c : owo) &#123;</span><br><span class="line">			<span class="keyword">while</span>(!<span class="built_in">check</span>(x + d[it][<span class="number">0</span>], y + d[it][<span class="number">1</span>]) || vis[x + d[it][<span class="number">0</span>]][y + d[it][<span class="number">1</span>]])</span><br><span class="line">				it = (it + <span class="number">1</span>) % <span class="number">4</span>;</span><br><span class="line">			x += d[it][<span class="number">0</span>];</span><br><span class="line">			y += d[it][<span class="number">1</span>];</span><br><span class="line">			arr[x][y] = c;</span><br><span class="line">			vis[x][y] = <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">const</span> <span class="keyword">auto</span> &amp;w : arr)</span><br><span class="line">			cout &lt;&lt; w;</span><br><span class="line">		cout &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>TIOJ</tag>
      </tags>
  </entry>
  <entry>
    <title>TIOJ-1461</title>
    <url>/TIOJ-1461/</url>
    <content><![CDATA[<p>neko最近迷上了洛克人。但是他的技術很差，每次玩紅白機的洛克人2都會卡在空氣人這關，不管試了多少次就是過不了。於是neko只好上網搜尋攻略，網路上能找到的所有技巧他都試過了，什麼暫停連打之類的，還是一直打不贏。<br>最後，neko在google上找到了一篇文章，只要把文章中的密碼解開，用這個密碼登入某網站，裡面就會出現所有武器道具全滿的密技使用方法。聰明的neko也觀察出了密碼的解法：</p>
<p>這篇文章包含兩個部份，前半段是n個由小寫字母組成的英文單字，後半段是一個數列A1, A2, …, Am 。將所有單字接成一個很長的字串，這個字串的第A1, A2, …, Am個字母拼成的單字就是網站的密碼。</p>
<span id="more"></span>
<p>例如文章前半為 the quick brown fox jumps over the lazy dog<br>數列是 30, 6, 10, 19, 30, 13<br>答案就是字串”thequickbrownfoxjumpsoverthelazydog”的第30, 6, 10, 19, 30, 13個字母”airman”<br>(註：字串index由1開始)</p>
<p>由於文章非常長，neko希望你能幫他寫一個簡單的程式算出他要的密碼。<br>$n\le 10^4, m\le 100, a_i\le \sum |s|$</p>
<hr>
<p>就只是個實作題(?<br>直接使用string的+運算子把字串接起來，輸入index的同時輸出s[index-1]。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">--------------              |   /</span></span><br><span class="line"><span class="comment">      |                     |  /</span></span><br><span class="line"><span class="comment">      |                     | /</span></span><br><span class="line"><span class="comment">      |             *       |/          |    |         ------            *</span></span><br><span class="line"><span class="comment">      |                     |           |    |        /      \</span></span><br><span class="line"><span class="comment">      |             |       |\          |    |       |       |\          |</span></span><br><span class="line"><span class="comment">   \  |             |       | \         |    |       |       | \         |</span></span><br><span class="line"><span class="comment">    \ |             |       |  \        |    |        \     /   \        |</span></span><br><span class="line"><span class="comment">     V              |       |   \        \__/|         -----     \       |</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EmiliaMyWife ios::sync_with_stdio(0); cin.tie(NULL);</span></span><br><span class="line"><span class="keyword">using</span> ll = <span class="keyword">int64_t</span>;</span><br><span class="line"><span class="comment">/*--------------------------------------------------------------------------------------*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123; EmiliaMyWife</span><br><span class="line">	<span class="keyword">int</span> n, m;</span><br><span class="line">	<span class="keyword">while</span>(cin &gt;&gt; n &gt;&gt; m, n + m) &#123;</span><br><span class="line">		string owo, s;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">			cin &gt;&gt; s;</span><br><span class="line">			owo += s;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>, x; i &lt; m; i++)</span><br><span class="line">			cin &gt;&gt; x, cout &lt;&lt; owo[x - <span class="number">1</span>];</span><br><span class="line">		cout &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>TIOJ</tag>
      </tags>
  </entry>
  <entry>
    <title>TIOJ-1916</title>
    <url>/TIOJ-1916/</url>
    <content><![CDATA[<p>多筆測資，給一個$N\times N$的矩陣，每格有數字$a_{i,j}$，還有$Q$筆詢問。<br/><br>對於每筆詢問，給定一個子矩陣範圍，輸出該子矩陣內的絕對多數或告知不存在。<br>絕對多數的定義是出現次數嚴格大於子矩陣大小的一半。</p>
<span id="more"></span>
<p>$N\le 2000, \sum N^2\le 1.25\times 10^7, \sum Q\le 70, a_{i, j}\le 10^9$</p>
<hr>
<p>首先觀察到Q很小，雖然$N$真的很大，不過$\mathcal{O}(QN^2)$的複雜度其實是可行的。<br/><br>所以對於每筆詢問，我們可以暴力跑遍一次子矩陣。<br>然而空間很緊，就算離散化再額外開個$4\times 10^6$的陣列都會MLE。<br>不過有個很經典的手段可以用$\mathcal{O}(1)$的空間找出絕對多數。<br/><br>想像在一個擂台上，台上站著一個元素，這時加進一個新元素，如果該元素跟擂台上的元素一樣，就把血量給+1，否則血量-1。<br>如果血量已經歸零就下台，加進的那個元素上來，同時hp設為1。如果存在絕對多數，那最後站在擂台上的元素肯定會是絕對多數。<br>至於不存在絕對多數呢?既然已經知道了”可能的答案”，就再遍歷一次，計算那個答案的出現次數是否嚴格大於子矩陣大小的一半。<br>複雜度$\mathcal{O}(Q\sum N^2)$，空間複雜度$\mathcal{O}(N^2)$。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">--------------              |   /</span></span><br><span class="line"><span class="comment">      |                     |  /</span></span><br><span class="line"><span class="comment">      |                     | /</span></span><br><span class="line"><span class="comment">      |             *       |/          |    |         ------            *</span></span><br><span class="line"><span class="comment">      |                     |           |    |        /      \</span></span><br><span class="line"><span class="comment">      |             |       |\          |    |       |       |\          |</span></span><br><span class="line"><span class="comment">   \  |             |       | \         |    |       |       | \         |</span></span><br><span class="line"><span class="comment">    \ |             |       |  \        |    |        \     /   \        |</span></span><br><span class="line"><span class="comment">     V              |       |   \        \__/|         -----     \       |</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EmiliaMyWife ios::sync_with_stdio(0); cin.tie(NULL);</span></span><br><span class="line"><span class="keyword">using</span> ll = <span class="keyword">int64_t</span>;</span><br><span class="line"><span class="keyword">using</span> ull = <span class="keyword">uint64_t</span>;</span><br><span class="line"><span class="keyword">using</span> ld = <span class="keyword">long</span> <span class="keyword">double</span>;</span><br><span class="line"><span class="keyword">using</span> uint = <span class="keyword">uint32_t</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> EPS  = <span class="number">1e-8</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF     = <span class="number">0x3F3F3F3F</span>;</span><br><span class="line"><span class="keyword">const</span> ll LINF     = <span class="number">4611686018427387903</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MOD     = <span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="comment">/*--------------------------------------------------------------------------------------*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> arr[<span class="number">2000</span>][<span class="number">2000</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123; EmiliaMyWife</span><br><span class="line">	<span class="keyword">int</span> n;</span><br><span class="line">	<span class="keyword">while</span>(cin &gt;&gt; n, n) &#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++)</span><br><span class="line">				cin &gt;&gt; arr[i][j];</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">int</span> q;</span><br><span class="line">		cin &gt;&gt; q;</span><br><span class="line">		<span class="keyword">while</span>(q--) &#123;</span><br><span class="line">			<span class="keyword">int</span> r1, r2, c1, c2;</span><br><span class="line">			cin &gt;&gt; r1 &gt;&gt; r2 &gt;&gt; c1 &gt;&gt; c2;</span><br><span class="line">			r2++; c2++;</span><br><span class="line">			</span><br><span class="line">			<span class="keyword">int</span> cur = <span class="number">0</span>, hp = <span class="number">0</span>;</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> i = r1; i &lt; r2; i++)</span><br><span class="line">				<span class="keyword">for</span>(<span class="keyword">int</span> j = c1; j &lt; c2; j++) &#123;</span><br><span class="line">					<span class="keyword">if</span>(cur == arr[i][j])</span><br><span class="line">						hp++;</span><br><span class="line">					<span class="keyword">else</span> &#123;</span><br><span class="line">						<span class="keyword">if</span>(hp)</span><br><span class="line">							hp--;</span><br><span class="line">						<span class="keyword">else</span></span><br><span class="line">							cur = arr[i][j], hp = <span class="number">1</span>;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			<span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> i = r1; i &lt; r2; i++)</span><br><span class="line">				<span class="keyword">for</span>(<span class="keyword">int</span> j = c1; j &lt; c2; j++)</span><br><span class="line">					cnt += arr[i][j] == cur;</span><br><span class="line">			<span class="keyword">if</span>(cnt &gt; (r2 - r1) * (c2 - c1) / <span class="number">2</span>)</span><br><span class="line">				cout &lt;&lt; cur &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">				cout &lt;&lt; <span class="string">&quot;-1\n&quot;</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>TIOJ</tag>
      </tags>
  </entry>
  <entry>
    <title>TIOJ-1607</title>
    <url>/TIOJ-1607/</url>
    <content><![CDATA[<p>在寬度為n的照片中，總共有多少種不同的山稜線呢 ?</p>
<p>為了簡化問題，一段長度為n的山稜線將由許多寬度為1的片段構成。<br>同時在每個片段當中，山稜線不是45度斜向上就是45度斜向下。<br>當然，相鄰兩個片段的山稜線必須連續，而且山稜線的兩端必須貼齊地平線。<br>此外，山稜線的任何一部分都不能低於地平線(即照片底端)。</p>
<p>舉例來說，以下就是一個合法的山稜線：</p>
<span id="more"></span>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">　　　　　　　　／＼　　　　　　　　　　 ／＼</span><br><span class="line">　／＼　　　　／　　＼／＼　　／＼／＼／　   ＼</span><br><span class="line">／　　＼／＼／　　　　　　＼／　　　　　　　   ＼</span><br></pre></td></tr></table></figure>
<p>因為答案可能很大，所以你只要輸出山稜線數量除以1,000,000,007的餘數即可。<br>T筆測資，<br>$n\le 10^6, T\le 10^5$</p>
<hr>
<p>如果把往上45度想成左括號，往下45度想成右括號。<br>可以發現合法的山稜線肯定會是一組合法的括號匹配。<br>因此問題就是: 給定$n$，問有$\frac{n}{2}$組括號會有幾種括號匹配?<br/><br>而$n$組括號的括號匹配正是卡特蘭數$C_n$，我們有<br>$$C_n=\frac{1}{n+1}{2N\choose N}$$<br>只要預處理階乘配合模逆元計算就好。<br>複雜度$\mathcal{O}(TlogMOD+N)$。(MOD=1e9+7)</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">--------------              |   /</span></span><br><span class="line"><span class="comment">      |                     |  /</span></span><br><span class="line"><span class="comment">      |                     | /</span></span><br><span class="line"><span class="comment">      |             *       |/          |    |         ------            *</span></span><br><span class="line"><span class="comment">      |                     |           |    |        /      \</span></span><br><span class="line"><span class="comment">      |             |       |\          |    |       |       |\          |</span></span><br><span class="line"><span class="comment">   \  |             |       | \         |    |       |       | \         |</span></span><br><span class="line"><span class="comment">    \ |             |       |  \        |    |        \     /   \        |</span></span><br><span class="line"><span class="comment">     V              |       |   \        \__/|         -----     \       |</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EmiliaMyWife ios::sync_with_stdio(0); cin.tie(NULL);</span></span><br><span class="line"><span class="keyword">using</span> ll = <span class="keyword">int64_t</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MOD     = <span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="comment">/*--------------------------------------------------------------------------------------*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e6</span> + <span class="number">25</span>;</span><br><span class="line">ll frac[N];</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">mpow</span><span class="params">(ll a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">	ll res = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(; b; b &gt;&gt;= <span class="number">1</span>, a = a * a % MOD)</span><br><span class="line">		<span class="keyword">if</span>(b &amp; <span class="number">1</span>)</span><br><span class="line">			res = res * a % MOD;</span><br><span class="line">	<span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">c</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> frac[n] * <span class="built_in">mpow</span>(frac[m], MOD - <span class="number">2</span>) % MOD * <span class="built_in">mpow</span>(frac[n - m], MOD - <span class="number">2</span>) % MOD;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123; EmiliaMyWife</span><br><span class="line">	frac[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; N; i++)</span><br><span class="line">		frac[i] = frac[i - <span class="number">1</span>] * i % MOD;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> t;</span><br><span class="line">	cin &gt;&gt; t;</span><br><span class="line">	<span class="keyword">while</span>(t--) &#123;</span><br><span class="line">		<span class="keyword">int</span> n;</span><br><span class="line">		cin &gt;&gt; n;</span><br><span class="line">		cout &lt;&lt; <span class="built_in">c</span>(n, n / <span class="number">2</span>) * <span class="built_in">mpow</span>(n / <span class="number">2</span> + <span class="number">1</span>, MOD - <span class="number">2</span>) % MOD &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>TIOJ</tag>
        <tag>math</tag>
      </tags>
  </entry>
  <entry>
    <title>2020-NHSPC</title>
    <url>/2020-NHSPC/</url>
    <content><![CDATA[<p>燒雞&gt;&lt; QQ</p>
<span id="more"></span>

<h1 id="賽前"><a href="#賽前" class="headerlink" title="賽前"></a>賽前</h1><p>這次的目標是二等獎OAO，希望保底三等，如果連三等都沒有我應該會很想自SA吧(X <strong>(對 現在真的蠻想自SA的)</strong><br>前一天在台北玩超高興，<br>室友感覺也還不錯，<br>就等比賽表現!</p>
<h1 id="賽中"><a href="#賽中" class="headerlink" title="賽中"></a>賽中</h1><h2 id="第一小時"><a href="#第一小時" class="headerlink" title="第一小時"></a>第一小時</h2><p>這次我的策略是先把題目全部看完，判斷哪些題目有初步想法。<br>看完後大概過了半小時，首先發現今年沒有閱讀測驗，還有題目變9題，超多。第一個想法大概:<br>pA用deque單調隊列亂做背包。<br>pB直接dag上dp。<br>pC題目有點難懂，但我猜不難。<br>pD是構造題，應該是貪心但還沒想法。<br>pE的子題只要爆搜就好，滿分還沒想法。<br>pF不會QQ，我猜在四個端點會有最佳解，等等用個n^2的做法喇看看，正解似乎可以離散化加掃描線，但斜的掃描線沒做過。<br>pG是什麼怪題，一臉防破台，或者是我有性質沒觀察出來吧，連子題都不會。<br>pH又是構造，師大啥時那麼認真會寫checker了。因為題號頗後面先暫時不花時間想。<br>pI一個01枚舉的直接爆搜有解，下一個subtask應該是dp或建圖。<br>然後就把pA給快速寫掉，pB也很快就亮綠燈了。<br>然而pC理解題目花點時間，的確不難，然而實作出低能bug花了不少時間。</p>
<h2 id="第二小時"><a href="#第二小時" class="headerlink" title="第二小時"></a>第二小時</h2><p>pC在發現bug後又發現我的作法可能會TLE@@，不過總之先丟丟看，然後就亮綠色了，看來師大judge蠻快的owo。<br>pD想了一下還是沒啥想法，後來就去想E了。<br>pE想觀察圖論性質但都沒進展，為了避免燒雞就先撈n^2，結果一直0分，wa了三次還四次後我就跳題了。<br>F丟了個四個端點的n^2直接吃WA，我直接傻掉，明明看起來超合理的@@。此時為了避免心態爆炸就去吃點東西。<br>pG想了五分鐘連subtask都完全不會，我就知道大概要放了。<br>HI感覺會防破台，所以我又回來看pE了，一直debug然後上傳，最後終於撈到21分，謝天謝地@@。<br>於是就去想想看pD。</p>
<h2 id="第三小時"><a href="#第三小時" class="headerlink" title="第三小時"></a>第三小時</h2><p>D想了15分鐘左右，大概有了用pq照做的想法，不過我不是很確定要遞增排序還是遞減，不過我想就都試試看。<br>結果為了自訂義pq的comparator弄超久，我不會STL @@。<br>後來終於編譯成功後範測也是好的，丟丟看他就亮綠燈了，開心。<br>之後就去看看GHI，I有點猜到應該是dp，只是轉移式不太好推。<br>就claim一個H的做法是分成很多塊，每塊都用隔板隔起來，這樣每塊的方法數都能單獨計算。<br>把組合數搞出來後想說能不能用greedy來湊數字，寫了很久。</p>
<h2 id="第四小時"><a href="#第四小時" class="headerlink" title="第四小時"></a>第四小時</h2><p>終於把H的東西生出來了，結果拿0分，我就知道不可以在這題繼續花時間了。<br>後來就是EFGI交替想，其中每輪想的時間長度是E&gt;F&gt;I&gt;G，但EF還是都沒想法。<br>I想說先把轉移式寫出來拿到暴力分再想想看優化。<br>花了點時間推，還一直出bug(有時是轉移式推爛，有時是實作問題)。</p>
<h2 id="第五小時"><a href="#第五小時" class="headerlink" title="第五小時"></a>第五小時</h2><p>pI終於感覺好好的了，丟上去果然拿到暴力分，心態回來了一點點。<br>但一時之間想不到怎麼優化。<br>心態加成下，去看了pE想到可以用bitset來壓常，尤其先前pC發現judge其實很快頗有信心，順手卡了pragma之類的，果然就被我唬爛掉了www(後來才知道連官解都是bitset)。<br>但去看F後還是沒有四端點外的想法，換個寫法丟上去還是0分，大概可以確定自己想法真的是爛的。<br>後來想到pI有某些單調性，決定把時間砸在這上面，不過實在頗難想，邊寫邊想還是寫很久，最後比賽結束，526收尾。</p>
<h1 id="賽後"><a href="#賽後" class="headerlink" title="賽後"></a>賽後</h1><p>結束當下就知道自己打爛了，尤其看到大家在互問每個都600以上，不過我想說我應該可以三等獎尾差不多吧。但還是很sad。<br>出來後看計分板，發現大家都有寫出pF，然後我居然是四等一，當下心態直接大爆炸，什麼都不想做，連專題演講都一直打音G想讓自己好過點。(但並沒有)<br>但後來去吃東西打機台後心情就回穩不少，雖然現在想到還是會sad。<br>但心態調適的確好了不少，大概是燒雞失敗習慣了吧。<br>不是很想放棄競程，我還想繼續拚拚看，所以明年初選再會QQ。</p>
]]></content>
      <tags>
        <tag>Competitive Programming</tag>
        <tag>experience</tag>
      </tags>
  </entry>
  <entry>
    <title>TIOJ-1428</title>
    <url>/TIOJ-1428/</url>
    <content><![CDATA[<p>給一張$n$個點與$m$條邊的有向圖，再給一個數字$L$。<br/><br>$Q$筆詢問，每筆詢問從$a$走到$b$且恰好經過$L$條邊(可重複)的路徑有幾條</p>
<span id="more"></span>
<p>$n\le 150, m\le 10^6, Q\le 20000, L\le 10^9$</p>
<hr>
<p>首先我們定義dp狀態，dp[L][a][b]為從$a$到$b$且恰好經過$L$條邊的路徑數量。<br/><br>而我們有以下轉移式:<br>$$dp[M+N][a][b] = \sum_{k=0}^{n-1}dp[M][a][k]\times dp[N][k][b]$$<br>可以理解成考慮剛好走到$M$步的每個中繼點，接下來一定得花$N$步走到終點。<br/></p>
<p>如果用矩陣的方式表示dp，令$dp[M]=A^M$，則:<br>$$A^{M+N}[a][b] = \sum_{k=0}^{n-1}A^M[a][k]\times A^N[k][b]$$<br>你會發現他剛好就是矩陣乘法的定義! 所以我們可以再寫成這樣:<br>$$A^{M+N}=A^M\times A^N$$<br>至於$A^1$呢? 不難發現他剛好就是這張圖的鄰接矩陣(每條邊代表著一條剛好經過一條邊的路徑)。<br/><br>所以把輸入轉成鄰接矩陣之後，我們就能使用矩陣快速冪來快速計算出$A^L$，然後就能$\mathcal{O}(1)$回答每筆詢問了。<br/><br>複雜度$\mathcal{O}(n^3\log L+Q)$。<br/><br>使用struct可以讓code變整齊&gt;&lt; 然後這題我WA超久才發現他的mod是$10^9+9$而不是$10^9+7$…</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">--------------              |   /</span></span><br><span class="line"><span class="comment">      |                     |  /</span></span><br><span class="line"><span class="comment">      |                     | /</span></span><br><span class="line"><span class="comment">      |             *       |/          |    |         ------            *</span></span><br><span class="line"><span class="comment">      |                     |           |    |        /      \</span></span><br><span class="line"><span class="comment">      |             |       |\          |    |       |       |\          |</span></span><br><span class="line"><span class="comment">   \  |             |       | \         |    |       |       | \         |</span></span><br><span class="line"><span class="comment">    \ |             |       |  \        |    |        \     /   \        |</span></span><br><span class="line"><span class="comment">     V              |       |   \        \__/|         -----     \       |</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EmiliaMyWife ios::sync_with_stdio(0); cin.tie(NULL);</span></span><br><span class="line"><span class="comment">/*--------------------------------------------------------------------------------------*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MOD = <span class="number">1e9</span> + <span class="number">9</span>;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mat</span> &#123;</span></span><br><span class="line">	<span class="keyword">int</span> arr[<span class="number">150</span>][<span class="number">150</span>];</span><br><span class="line">	<span class="built_in">mat</span>() &#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++)</span><br><span class="line">				arr[i][j] = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	mat <span class="keyword">operator</span>*(mat &amp;b) &#123;</span><br><span class="line">		mat c;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++)</span><br><span class="line">				<span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; n; k++)</span><br><span class="line">					c.arr[i][j] = (c.arr[i][j] + <span class="number">1LL</span> * arr[i][k] * b.arr[k][j]) % MOD;</span><br><span class="line">		<span class="keyword">return</span> c;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123; EmiliaMyWife</span><br><span class="line">	<span class="keyword">int</span> m, q, l;</span><br><span class="line">	cin &gt;&gt; n &gt;&gt; m &gt;&gt; q &gt;&gt; l;</span><br><span class="line">	</span><br><span class="line">	mat res, owo;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">		res.arr[i][i] = <span class="number">1</span>;</span><br><span class="line">	<span class="comment">//初始化為單位矩陣</span></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>, a, b; i &lt; m; i++) &#123;</span><br><span class="line">		cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line">		owo.arr[a][b]++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//鄰接矩陣</span></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span>(; l; owo = owo * owo, l &gt;&gt;= <span class="number">1</span>)</span><br><span class="line">		<span class="keyword">if</span>(l &amp; <span class="number">1</span>)</span><br><span class="line">			res = res * owo;</span><br><span class="line">	<span class="comment">//矩陣快速冪</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span>(q--) &#123;</span><br><span class="line">		<span class="keyword">int</span> a, b;</span><br><span class="line">		cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line">		cout &lt;&lt; res.arr[a][b] &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>TIOJ</tag>
        <tag>graph</tag>
      </tags>
  </entry>
  <entry>
    <title>TIOJ-1555</title>
    <url>/TIOJ-1555/</url>
    <content><![CDATA[<p>給一個$n\times m$的01矩陣，問有幾個正方形子矩陣滿足該子矩陣內的數字全都是1，並且輸出最長的邊長。</p>
<span id="more"></span>
<p>$n, m\le 5000$</p>
<hr>
<p>這題有個十分重要的轉換手法，對於每一列我們維護一個長度為m的陣列a，a[i]代表第i行往上有幾個連續的0。<br>這個手段在<a href="https://www.jikuai.codes/2020/05/03/TIOJ-1063">TIOJ-1063</a>也有用到。<br>接下來對每個(i,j)去計算以(i,j)為右下角可用出的正方形最大邊長(可以發現任何它短的邊長的正方形也都能放)。<br>如果要用長度為$x$的正方形，那必須滿足<br>$$\min_{k=j-x+1}^{j}(a[k])\ge x$$<br>由於隨著x變大，min只會越來越小，因此可以二分搜x，做到$\mathcal{O}(nmlogm)$。<br/><br>如果我們改成考慮可以放出最大正方形的左界$l(l=j-x+1)$，然後就會發現隨著$j$增加，$l$只增不減(因為$j$增加也會使得min越來越小)。<br/><br>所以可以使用雙指標，並且維護一個遞減的單調隊列來做RMQ(因為查詢的範圍只會越來越右邊)。<br>這樣就能做到$\mathcal{O}(nm)$。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">--------------              |   /</span></span><br><span class="line"><span class="comment">      |                     |  /</span></span><br><span class="line"><span class="comment">      |                     | /</span></span><br><span class="line"><span class="comment">      |             *       |/          |    |         ------            *</span></span><br><span class="line"><span class="comment">      |                     |           |    |        /      \</span></span><br><span class="line"><span class="comment">      |             |       |\          |    |       |       |\          |</span></span><br><span class="line"><span class="comment">   \  |             |       | \         |    |       |       | \         |</span></span><br><span class="line"><span class="comment">    \ |             |       |  \        |    |        \     /   \        |</span></span><br><span class="line"><span class="comment">     V              |       |   \        \__/|         -----     \       |</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EmiliaMyWife ios::sync_with_stdio(0); cin.tie(NULL);</span></span><br><span class="line"><span class="keyword">using</span> ll = <span class="keyword">int64_t</span>;</span><br><span class="line"><span class="keyword">using</span> ull = <span class="keyword">uint64_t</span>;</span><br><span class="line"><span class="keyword">using</span> ld = <span class="keyword">long</span> <span class="keyword">double</span>;</span><br><span class="line"><span class="keyword">using</span> uint = <span class="keyword">uint32_t</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> EPS  = <span class="number">1e-8</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF     = <span class="number">0x3F3F3F3F</span>;</span><br><span class="line"><span class="keyword">const</span> ll LINF     = <span class="number">4611686018427387903</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MOD     = <span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="comment">/*--------------------------------------------------------------------------------------*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123; EmiliaMyWife</span><br><span class="line">	<span class="keyword">int</span> n, m;</span><br><span class="line">	cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">	<span class="function">vector&lt;string&gt; <span class="title">arr</span><span class="params">(n)</span></span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">		cin &gt;&gt; arr[i];</span><br><span class="line">	<span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">owo</span><span class="params">(m)</span></span>;</span><br><span class="line">	deque&lt;<span class="keyword">int</span>&gt; line;</span><br><span class="line">	</span><br><span class="line">	ll ans = <span class="number">0</span>, mx = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m; j++) &#123;</span><br><span class="line">			<span class="keyword">if</span>(arr[i][j] &amp; <span class="number">1</span>)</span><br><span class="line">				owo[j] = <span class="number">0</span>;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">				owo[j]++;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>, it = <span class="number">0</span>; j &lt; m; j++) &#123;</span><br><span class="line">			<span class="keyword">while</span>(!line.<span class="built_in">empty</span>() &amp;&amp; owo[line.<span class="built_in">back</span>()] &gt; owo[j])</span><br><span class="line">				line.<span class="built_in">pop_back</span>();</span><br><span class="line">			line.<span class="built_in">push_back</span>(j);</span><br><span class="line">			<span class="keyword">while</span>(!line.<span class="built_in">empty</span>() &amp;&amp; owo[line.<span class="built_in">front</span>()] &lt; j - it + <span class="number">1</span>) &#123;</span><br><span class="line">				it++;</span><br><span class="line">				<span class="keyword">if</span>(line.<span class="built_in">front</span>() &lt; it)</span><br><span class="line">					line.<span class="built_in">pop_front</span>();</span><br><span class="line">			&#125;</span><br><span class="line">			ans += j - it + <span class="number">1</span>;</span><br><span class="line">			mx = max&lt;ll&gt;(mx, j - it + <span class="number">1</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		line.<span class="built_in">clear</span>();</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; ans &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; mx &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>TIOJ</tag>
        <tag>monotonic queue</tag>
      </tags>
  </entry>
  <entry>
    <title>TIOJ-1768</title>
    <url>/TIOJ-1768/</url>
    <content><![CDATA[<p>傳說中，P教授擁有一個蹺蹺板，叫作P-蹺蹺板。P-蹺蹺板是個長直且質量可忽略的板子，上面有$N$個等距的座位，編號為$0$到$N-1$，每個座位都只能坐一個人。特別的是，P-蹺蹺板的支點並不是固定的，使用者可以將支點架在任何一個座位的<strong>正下方</strong>。<br/><br>如果支點左右的力矩相同，那麼蹺蹺板將會平衡。例如若$N=5$    ，五個座位上面的重量依序為$2,1,5,3,1$，若將支點架在$2$號座位下方，則左邊力矩$\ =2\times 2 + 1\times 1 = 3\times 1 + 1\times 2=\ $右邊力矩，故蹺蹺板會平衡。<br/></p>
<span id="more"></span>
<p>有一天，P教授叫了$N$個人過來，請他們依序坐在P-蹺蹺板上，嘗試保持平衡。然而，由於每個人的體重不盡相同，而且支點沒辦法架在坐位之間，要找到平衡十分困難。<br/><br>這時， P教授用他多年玩蹺蹺板的經驗，一眼看出了他們現在坐的順序有一個性質：至少存在一個$0\leq x&lt;\max(1,\lfloor{\frac{N}{2}}\rfloor)$，使得如果把最前面$x$個人和最後面$x$個人交換，那麼一定可以找到一個支點使得蹺蹺板平衡。所謂把最前面個人和最後面個人交換，指的是鏡像交換，例如若$x=2$，代表把座位編號為$0$和$N-1$上面的人交換、座位編號為$1$和$N-2$上面的人交換；若$x=0$，代表完全不交換。<br/></p>
<p>P教授把這個性質告訴了這$N$個人，決定考驗他們能不能將蹺蹺板平衡。給你每個位置目前坐的人的體重，你能幫助他們找到正確的交換方式與支點的位置嗎？<br/></p>
<p>每個人的體重為$a_i$<br/><br>$N\le 2\times 10^7, a_i\le 20000$</p>
<hr>
<p>這題的$N$還真大(汗<br/><br>先來整理一下式子吧。<br>假設我們把支點設在$t$，令$\sum a_i=S$。題目告訴我們左力矩=右力矩，把他們搬到同一邊，左力矩-右力矩=0，爆開他:<br>$$(\sum_{i=0}^{t}(t-i)a_i)-(\sum_{i=t+1}^{n-1}(i-t)a_i)=0$$<br>$$(\sum_{i=0}^{t}(t-i)a_i)+(\sum_{i=t+1}^{n-1}(t-i)a_i)=0$$<br>$$\sum_{i=0}^{n-1}(t-i)a_i=0$$<br>$$\sum_{i=0}^{n-1}t\times a_i=\sum_{i=0}^{n-1}i\times a_i$$<br>令等號右邊那陀為$res$<br>$$tS=res$$<br>$$t=\frac{res}{S}$$<br>多麼美妙的等式!<br>所以我們可以枚舉每個$x$，而因為交換是鏡像的，所以從$x$到$x+1$只需要交換兩項，也就只需要修改$res$四次，為常數時間。<br/><br>一旦存在$x$滿足$res$可以被$S$整除，那就有答案了!<br/><br>時間複雜度$\mathcal{O}(N)$</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">--------------              |   /</span></span><br><span class="line"><span class="comment">      |                     |  /</span></span><br><span class="line"><span class="comment">      |                     | /</span></span><br><span class="line"><span class="comment">      |             *       |/          |    |         ------            *</span></span><br><span class="line"><span class="comment">      |                     |           |    |        /      \</span></span><br><span class="line"><span class="comment">      |             |       |\          |    |       |       |\          |</span></span><br><span class="line"><span class="comment">   \  |             |       | \         |    |       |       | \         |</span></span><br><span class="line"><span class="comment">    \ |             |       |  \        |    |        \     /   \        |</span></span><br><span class="line"><span class="comment">     V              |       |   \        \__/|         -----     \       |</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EmiliaMyWife ios::sync_with_stdio(0); cin.tie(NULL);</span></span><br><span class="line"><span class="keyword">using</span> ll = <span class="keyword">int64_t</span>;</span><br><span class="line"><span class="comment">/*--------------------------------------------------------------------------------------*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123; EmiliaMyWife</span><br><span class="line">	<span class="keyword">int</span> n;</span><br><span class="line">	cin &gt;&gt; n;</span><br><span class="line">	<span class="function">vector&lt;ll&gt; <span class="title">arr</span><span class="params">(n)</span></span>;</span><br><span class="line">	</span><br><span class="line">	ll s = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">		cin &gt;&gt; arr[i], s += arr[i];</span><br><span class="line">	</span><br><span class="line">	ll res = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">		res += arr[i] * i;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">-1</span>; i &lt; <span class="built_in">max</span>(<span class="number">1</span>, n / <span class="number">2</span>); i++) &#123;</span><br><span class="line">		<span class="keyword">if</span>(~i) &#123;</span><br><span class="line">			res -= arr[i] * i;</span><br><span class="line">			res -= arr[n - i - <span class="number">1</span>] * (n - i - <span class="number">1</span>);</span><br><span class="line">			<span class="built_in">swap</span>(arr[i], arr[n - i - <span class="number">1</span>]);</span><br><span class="line">			res += arr[i] * i;</span><br><span class="line">			res += arr[n - i - <span class="number">1</span>] * (n - i - <span class="number">1</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(res % s == <span class="number">0</span>)</span><br><span class="line">			<span class="keyword">return</span> cout &lt;&lt; i + <span class="number">1</span> &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; res / s &lt;&lt; <span class="string">&#x27;\n&#x27;</span>, <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>TIOJ</tag>
      </tags>
  </entry>
  <entry>
    <title>TIOJ-1870</title>
    <url>/TIOJ-1870/</url>
    <content><![CDATA[<p>現在我要給你一個長度為$n$的數列，每一項初始值為$a_i$，$q$筆操作每筆操作有兩種。<br/><br>一，給你L, R，請算出 [L,R] 的總和。<br>二，給你L, R, X，請把 [L,R] 中的所有數字都 XOR X。</p>
<!--more--->
<p>$n\le 10^5, q\le 50000, a_i\le 10^6$</p>
<hr>
<p>如果維護一顆線段樹，區間xor沒辦法直接地得出她對答案的影響(所以無法用懶標)。<br>但如果對於每個bit都維護一個線段樹呢?每顆線段樹都會只存01，而xor操作會變成區間反轉!<br>所以維護$\log a_i$科線段樹就好了。<br>複雜度$\mathcal{O}(N\log a_i\log N+Q\log a_i\log N)$</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">--------------              |   /</span></span><br><span class="line"><span class="comment">      |                     |  /</span></span><br><span class="line"><span class="comment">      |                     | /</span></span><br><span class="line"><span class="comment">      |             *       |/          |    |         ------            *</span></span><br><span class="line"><span class="comment">      |                     |           |    |        /      \</span></span><br><span class="line"><span class="comment">      |             |       |\          |    |       |       |\          |</span></span><br><span class="line"><span class="comment">   \  |             |       | \         |    |       |       | \         |</span></span><br><span class="line"><span class="comment">    \ |             |       |  \        |    |        \     /   \        |</span></span><br><span class="line"><span class="comment">     V              |       |   \        \__/|         -----     \       |</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EmiliaMyWife ios::sync_with_stdio(0); cin.tie(NULL);</span></span><br><span class="line"><span class="keyword">using</span> ll = <span class="keyword">int64_t</span>;</span><br><span class="line"><span class="keyword">using</span> ull = <span class="keyword">uint64_t</span>;</span><br><span class="line"><span class="keyword">using</span> ld = <span class="keyword">long</span> <span class="keyword">double</span>;</span><br><span class="line"><span class="keyword">using</span> uint = <span class="keyword">uint32_t</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> EPS  = <span class="number">1e-8</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF     = <span class="number">0x3F3F3F3F</span>;</span><br><span class="line"><span class="keyword">const</span> ll LINF     = <span class="number">4611686018427387903</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MOD     = <span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="comment">/*--------------------------------------------------------------------------------------*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span> + <span class="number">25</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">segtree</span> &#123;</span></span><br><span class="line">	<span class="keyword">int</span> arr[N &lt;&lt; <span class="number">1</span>], tag[N], n;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> _n)</span> </span>&#123; n = _n; &#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">upd</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> h)</span> </span>&#123;</span><br><span class="line">		arr[p] = (<span class="number">1</span> &lt;&lt; h) - arr[p];</span><br><span class="line">		 <span class="keyword">if</span>(p &lt; n)</span><br><span class="line">			tag[p] ^= <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> h = __lg(p); ~h; h--) &#123;</span><br><span class="line">			<span class="keyword">int</span> i = p &gt;&gt; h;</span><br><span class="line">			<span class="keyword">if</span>(!tag[i &gt;&gt; <span class="number">1</span>])</span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">			<span class="built_in">upd</span>(i, h);</span><br><span class="line">			<span class="built_in">upd</span>(i ^ <span class="number">1</span>, h);</span><br><span class="line">			tag[i &gt;&gt; <span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">pull</span><span class="params">(<span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> h = <span class="number">1</span>; p &gt; <span class="number">1</span>; p &gt;&gt;= <span class="number">1</span>, h++) &#123;</span><br><span class="line">			arr[p &gt;&gt; <span class="number">1</span>] = arr[p] + arr[p ^ <span class="number">1</span>];</span><br><span class="line">			<span class="keyword">if</span>(tag[p &gt;&gt; <span class="number">1</span>])</span><br><span class="line">				arr[p &gt;&gt; <span class="number">1</span>] = (<span class="number">1</span> &lt;&lt; h) - arr[p &gt;&gt; <span class="number">1</span>];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">edt</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> tl = l, tr = r, h = <span class="number">0</span>;</span><br><span class="line">		<span class="built_in">push</span>(tl + n); <span class="built_in">push</span>(tr + n - <span class="number">1</span>);</span><br><span class="line">		<span class="keyword">for</span>(l += n, r += n; l &lt; r; l &gt;&gt;= <span class="number">1</span>, r &gt;&gt;= <span class="number">1</span>, h++) &#123;</span><br><span class="line">			<span class="keyword">if</span>(l &amp; <span class="number">1</span>)</span><br><span class="line">				<span class="built_in">upd</span>(l++, h);</span><br><span class="line">			<span class="keyword">if</span>(r &amp; <span class="number">1</span>)</span><br><span class="line">				<span class="built_in">upd</span>(--r, h);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">pull</span>(tl + n); <span class="built_in">pull</span>(tr + n - <span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">que</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">		<span class="built_in">push</span>(l + n); <span class="built_in">push</span>(r + n - <span class="number">1</span>);</span><br><span class="line">		<span class="keyword">for</span>(l += n, r += n; l &lt; r; l &gt;&gt;= <span class="number">1</span>, r &gt;&gt;= <span class="number">1</span>) &#123;</span><br><span class="line">			<span class="keyword">if</span>(l &amp; <span class="number">1</span>)</span><br><span class="line">				res += arr[l++];</span><br><span class="line">			<span class="keyword">if</span>(r &amp; <span class="number">1</span>)</span><br><span class="line">				res += arr[--r];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> res;</span><br><span class="line">	&#125;</span><br><span class="line">&#125; tree[<span class="number">20</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123; EmiliaMyWife</span><br><span class="line">	<span class="keyword">int</span> n;</span><br><span class="line">	cin &gt;&gt; n;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">20</span>; j++)</span><br><span class="line">		tree[j].<span class="built_in">init</span>(n);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>, x; i &lt; n; i++) &#123;</span><br><span class="line">		cin &gt;&gt; x;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">20</span>; j++)</span><br><span class="line">			<span class="keyword">if</span>(x &gt;&gt; j &amp; <span class="number">1</span>)</span><br><span class="line">				tree[j].<span class="built_in">edt</span>(i, i + <span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> q;</span><br><span class="line">	cin &gt;&gt; q;</span><br><span class="line">	<span class="keyword">while</span>(q--) &#123;</span><br><span class="line">		<span class="keyword">int</span> t;</span><br><span class="line">		cin &gt;&gt; t;</span><br><span class="line">		<span class="keyword">if</span>(t == <span class="number">1</span>) &#123;</span><br><span class="line">			<span class="keyword">int</span> l, r;</span><br><span class="line">			cin &gt;&gt; l &gt;&gt; r;</span><br><span class="line">			ll res = <span class="number">0</span>;</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++)</span><br><span class="line">				res += <span class="built_in">ll</span>(tree[i].<span class="built_in">que</span>(l - <span class="number">1</span>, r)) &lt;&lt; i;</span><br><span class="line">			cout &lt;&lt; res &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">int</span> l, r, x;</span><br><span class="line">			cin &gt;&gt; l &gt;&gt; r &gt;&gt; x;</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++)</span><br><span class="line">				<span class="keyword">if</span>(x &gt;&gt; i &amp; <span class="number">1</span>)</span><br><span class="line">					tree[i].<span class="built_in">edt</span>(l - <span class="number">1</span>, r);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>TIOJ</tag>
        <tag>segment tree</tag>
      </tags>
  </entry>
  <entry>
    <title>2021IOIC-Day1</title>
    <url>/2021IOIC-Day1/</url>
    <content><![CDATA[<p>這次有幸進到IOIC&gt;&lt; 遇到了好多電神。</p>
<span id="more"></span>

<h1 id="課程"><a href="#課程" class="headerlink" title="課程"></a>課程</h1><p>第一天早上是喵喵時間，基本上就是講故事還有來點心靈雞湯，雖然沒實際講知識但是我覺得我受益良多&gt;&lt;。</p>
<p>下午的圖論課講師準備太多東西了，然後又在基礎的地方講太久，導致有趣的東西都沒上到。</p>
<p>點心晚餐都很好吃&gt;&lt;。</p>
<h1 id="晚上上機"><a href="#晚上上機" class="headerlink" title="晚上上機"></a>晚上上機</h1><p>在晚上的趣味賽中隊友其中一個是fhvirus，我們說好三人三分半開題，但開一題就說跟2020NPSC決賽pG很像，他就開始偷標頭檔。</p>
<p>這時我看計分板很多人過pA，去看發現就是floyd warshall的順序寫爛了，只要把下面鬆弛的code改掉就好。</p>
<p>繼續跟題，有一題是題幹一堆廢話，範測也是，猜一下梗懷疑一下後就過了。</p>
<p>後來fhvirus一直偷就偷成功，還拿了首殺，超電。</p>
<p>這時我們在第一名，好開心。</p>
<p>不過接下來就開題不順了，有一題code看很久才理解她在幹嘛，花了一點時間討論才得出hack測資。</p>
<p>還有一題是要構造某個東西，我們的構造方法是輸出一行有100個A，下一行有50個A。結果fhvirus就直接複製貼上，然後我們的Code就長這樣:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">cout &lt;&lt; <span class="string">&quot;AAAAAAAAAAA.....AAAA\n&quot;</span>;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;AAAAAA...AAAA\n&quot;</span>;</span><br></pre></td></tr></table></figure>

<p>題解時還被拿出來講，結果不只我們一隊這樣做XD，講師：「<del>你們不會用for嗎</del>」</p>
<p>還有一題也是題敘很多廢話，隊友說會不會就是背包，我寫了然後wa，之後我就一直claim說那題不是背包，應該有其他梗。</p>
<p>賽後發現那題真的是背包，我只是dp的初始值沒設好。</p>
<p>因為有一題一直wa，比賽的第一頁又有說上傳前沒喊總召好帥就有可能會wa(#，所以fhvirus在某次上傳前喊了一聲很大聲的總召好帥，結果還是wa了QQ。</p>
<p>最後第12名收場。</p>
<p><img src="Day1-Scoreboard.png" alt="Day 1 Scoreboard"></p>
<h1 id="住宿"><a href="#住宿" class="headerlink" title="住宿"></a>住宿</h1><p>新竹仔當然要來住宿啦&gt;&lt;</p>
<p>室友是台中人，剛考完學測。感覺他是夯哥型的，問她有沒有看動畫他說沒有。(<del>我不懂為啥我那麼大膽直接問有沒有看動畫</del>)</p>
<p>後來她的確蠻早就睡了，導致我作息也被拉得有點早，不過這樣應該也好。</p>
<p>晚上因為晚點名後很無聊，我原本想說要去帶著房卡去走廊晃晃順便看有沒有其他人，然後一離開房間我就發現我<strong>忘記帶房卡了</strong>orz。</p>
<p>我也沒帶錢，但為了節省時間所以我就跟別人去7-11看看等等回房間後可以買什麼東西，同時我在dc群聊天時講到這件事，結果某個助教剛好也在dc群，結果就被抓回來了&gt;&lt;</p>
<p>被抓回來後也就不敢再出去了，所以就乖乖睡覺。</p>
]]></content>
      <tags>
        <tag>experience</tag>
        <tag>IOIC</tag>
      </tags>
  </entry>
  <entry>
    <title>2021IOIC-Day2</title>
    <url>/2021IOIC-Day2/</url>
    <content><![CDATA[<p>今天一開始就是數學，我超級害怕，</p>
<span id="more"></span>

<h1 id="課程"><a href="#課程" class="headerlink" title="課程"></a>課程</h1><h2 id="早上"><a href="#早上" class="headerlink" title="早上"></a>早上</h2><p>早上就是數學@@，我真的很害怕數學，尤其翻開講義又馬上就看到生成函數之類的東西。</p>
<p>一開始先從高中排組起手，後來講到了超酷的prufer sequence，以後生樹的測資變容易了(x</p>
<p>不過後來進了群論，一開始定義部分我把它當矩陣來想，還算可以。</p>
<p>但後來進到burnside後就開始聽不懂了，所以就只好之後再看看吧。</p>
<p>後來開始講捲積，講到了FFT，不過我先備知識不足，不會虛數，所以大概也得之後再理解了。</p>
<p>看投影片還有兩百多頁，後面還有生成函數以及莫比烏斯反演0.0，超可怕。</p>
<h2 id="下午"><a href="#下午" class="headerlink" title="下午"></a>下午</h2><p>下午是波路特石的進階資結，應該是最有收穫的一堂了。</p>
<p>不過其實基礎資結很多東西我還不會@@，比如treap、持久化線段樹、持久化treap。</p>
<p>但那些東西都還有聽過概念，所以應該可以之後自學ㄅ。</p>
<p>學到了李超線段樹還有其他線段樹，還有pattern技巧以及segment tree beats。</p>
<p>不過segment tree beats有點難以理解@@，但還是有吸收最多東西了，模板還來不及練習，之後再說吧!</p>
<p>順帶一提，波路是到目前三堂課中唯一一個有把東西講完的，超強。</p>
<p>他講完後還剩三十分鐘，甚至在說基礎班怎麼講那麼慢XDD，還說他以為是上到20分結果是50分。</p>
<p>因為很空閒，所以他就把昨天的圖論投影片拿出來講。</p>
<p>原本他要先講SCC那邊，結果圖論的講師wayne跑到門口：「先講點雙聯通分量。」波神：「你要不要進來講」wayne:「不要。」</p>
<h1 id="晚上練習"><a href="#晚上練習" class="headerlink" title="晚上練習"></a>晚上練習</h1><p>晚上是個人賽，打得超爛。</p>
<p>一開始把題目都看完，同時先跳過<strong>數學題</strong>。</p>
<p>有看到一題就覺得是縮點成樹後就能輕鬆判斷，想說那題我一定要拿，結果砸了半個多小時在上面，然後刻爛。</p>
<p>打開記分板才看到pC是個數學水題。但是WA了兩次才過，心態整個大爆炸。</p>
<p>之後一直在BCC縮點燒雞就結束了，只AC一題，名次50幾名。</p>
<p>賽後才知道有兩題用到的東西我根本就寫過，我一直執著的那題縮點全場只有1AC。</p>
<p>後來才發現他的case真的很多。</p>
<p>第56名收場，大燒雞。</p>
<p><img src="Day2-Scoreboard.png" alt="Day 2 Scoreboard"></p>
<h1 id="住宿"><a href="#住宿" class="headerlink" title="住宿"></a>住宿</h1><p>到了飯店之後，助教就說晚點名之後不能到處跑，得經過他們同意。</p>
<p>然後還說昨天有人被抓回來，整個超羞恥##</p>
]]></content>
      <tags>
        <tag>experience</tag>
        <tag>IOIC</tag>
      </tags>
  </entry>
  <entry>
    <title>2021IOIC-Day3</title>
    <url>/2021IOIC-Day3/</url>
    <content><![CDATA[<p>今天上字串和dp，字串頗難，dp感覺能學到不少東西。</p>
<span id="more"></span>

<h1 id="課程"><a href="#課程" class="headerlink" title="課程"></a>課程</h1><h2 id="早上"><a href="#早上" class="headerlink" title="早上"></a>早上</h2><p>字串演算法OAO，之前一直沒有很想學字串演算法，畢竟IOI不會遇到。</p>
<p>這次把KMP給搞懂了，學會了Z，還學會了AC自動機。</p>
<p>超級神奇，感覺真的砸了就會AC，不過模板也是之後再練習。</p>
<p>boook在開場就說他是他們隊伍(LYB)負責雜耍的。</p>
<p>可是目前還對AC自動機能幹嘛沒很有概念@@。</p>
<h2 id="下午"><a href="#下午" class="headerlink" title="下午"></a>下午</h2><p>下午是dp OAO，一開始先從費式數列之類的開始講。</p>
<p>真正開始有趣的是優化的時候，講了斜率優化、分治優化、四邊形優化和aliens trck。</p>
<p>節奏蠻棒的，基礎和進階各半。</p>
<p>雖然明明還有很多dp可以講@@，他應該是想把四種優化好好講完。</p>
<p>從以前就很想搞懂四邊形優化，這次主要知道了大致上，可是還有不少沒想通的。</p>
<p>東東說他是今年的ioi銀牌，但她忘記現在已經2021了(</p>
<h1 id="上機練習"><a href="#上機練習" class="headerlink" title="上機練習"></a>上機練習</h1><p>今天是團體賽OAO。</p>
<p>我們沒有擬定什麼策略，反正就是到處看題目。</p>
<p>看記分板似乎水題都在後面兩題。</p>
<p>dijkstra還吃了兩個wa，心態差點爛掉@@。</p>
<p>把最後兩題寫完之後就不知道幹嘛了，開始燒雞。</p>
<p>但是我隊友對一題很有fu，雖然我覺得他是假解，所以我就想讓他自己搞。</p>
<p>後來她吃了TLE，我就繼續弄這題看來可做的題目。結果fhvirus覺得他的很合理，修了一下bug居然就AC了，我超愧疚ˊˋ。</p>
<p>之後有一題set一直re，後來都還沒修過。</p>
<p>這場也是燒雞，連燒兩天心態其實有點差。</p>
<p><img src="Day3-Scoreboard.png" alt="Day 3 Scoreboard"></p>
<h1 id="住宿"><a href="#住宿" class="headerlink" title="住宿"></a>住宿</h1><p>今天去跟chyen買消夜吃，趕在晚點名前回來，我也不敢隨便違反規定(#</p>
<p>之後去到nathan的房間玩，那邊有六個人，超嗨。</p>
<p>nathanlee一直在debug。</p>
<p>現在才知道animax還是有上一些好看的(例如輝夜姬，雖然是第一季)。</p>
<p>後來弄到兩點多才睡覺，希望隔天不會睡太慘。</p>
]]></content>
      <tags>
        <tag>experience</tag>
        <tag>IOIC</tag>
      </tags>
  </entry>
  <entry>
    <title>2021IOIC-Day4</title>
    <url>/2021IOIC-Day4/</url>
    <content><![CDATA[<p>不知不覺就到了最後一天上課了(明天會是五個小時的大團體賽)，時間過真快。</p>
<p>今天上的東西都是屬於我不太熟悉的，所以感覺可以學到不少東西(<del>前提是聽得懂</del>)</p>
<span id="more"></span>

<h1 id="課程"><a href="#課程" class="headerlink" title="課程"></a>課程</h1><h2 id="早上"><a href="#早上" class="headerlink" title="早上"></a>早上</h2><p>早上上了flow，其實之前就有用過dinic來二分圖最大匹配了，可是都沒有好好搞懂它的原理過。</p>
<p>今天搭配證明後就懂了&gt;&lt;，同時也學到原來MCMF的複雜度其實很糟，跟最後的流量答案有關。</p>
<p>我還以為只是dinic的複雜度再乘上V或E而已。</p>
<p>原本我不會SPFA的，但是因為MCMF要用到，然後就不知不覺學會了www。</p>
<p>不過建模是真的很難，例題就有些沒很懂了。</p>
<p>最小割的應用也超級神奇，有些例題完全無法理解orz。</p>
<p>yp在開場就說他是他們隊伍(LYB)負責雜耍的。</p>
<h2 id="下午"><a href="#下午" class="headerlink" title="下午"></a>下午</h2><p>最後一堂課QQ，組合賽局。</p>
<p>組合賽局應該就是我最陌生的地方，以往只有寫codeforces的梗題才會用到game theory這詞。</p>
<p>一開始看到講師的投影片才195頁，相比其他講師都5 600頁少很多，尤其他又說這堂課應該是到目前最簡單的一堂。</p>
<p>在無偏賽局的前半段還好，把SG value搬出來後就有點小障礙了，後面的有偏賽局最後部分可說完全不知道她在說什麼QQ。</p>
<p>不過lawfung真的講得很好，有把定義都好好講清楚，所以我之後自己讀應該也能讀得懂(<del>希望啦</del>。</p>
<p>lawfung在開場就說他是他們隊伍(LYB)負責雜耍的。</p>
<h2 id="晚上練習"><a href="#晚上練習" class="headerlink" title="晚上練習"></a>晚上練習</h2><p>今天是個人賽。</p>
<p>開場一分鐘就有人ac了，去看才發現他是問LYB誰負責砸耍XDD。</p>
<p>沒給其他東西，我還想了大概10秒到底要輸出誰，不過原來輸出三個人的名字任意一個就能AC，然而還是有人能WA XDD。</p>
<p>後來去開計分板上也很多人AC的題目，他是一個賽局論的題目，看到有人7分鐘就ac還有ac人數很多就猜他是梗題。</p>
<p>他的輸入有兩個數字n,m(&lt;=10^9)，所以其實可以靠打表通靈。</p>
<p>但我想說我都上了一個下午的賽局論，應該可以自己想想看吧。</p>
<p>所以我就手列幾個case，然後傳上去，就wa。</p>
<p>發現新的case，再傳上去。又wa。</p>
<p>就這樣重複了四次，我果然不會猜梗。</p>
<p>所以先去寫別題，有一題就是裸裸ㄉMCMF，把講義的模板抄上去後就爽爽AC。</p>
<p>也把其他實作題都寫一寫。</p>
<p>之後發現那題梗題的ac人數真的超級多，所以我就放棄思考開始打表了。</p>
<p>然後表超級有規律，一眼就看出的那種。</p>
<p>結果我就因為這題的penalty排在超後面，好討厭梗題。</p>
<p>有一題線段樹優化建圖再Flow求二分圖最大匹配，還蠻有趣的，之後要把他理解。</p>
<p>第四天的名次其實算是最滿意的了&gt;&lt;，除了penalty真的很多。</p>
<p><img src="Day4-Scoreboard.png" alt="Day 4 Scoreboard"></p>
<h2 id="住宿"><a href="#住宿" class="headerlink" title="住宿"></a>住宿</h2><p>今天跟室友聊了一點天，之後又跑去昨晚那個房間，原本想說明天要正式賽別太晚睡拖累隊友，結果還是弄到兩點多了@@。</p>
<p>最後一個晚上了，其實這個室友還不錯，原本擔心遇到太雷的，我反而擔心在他眼中我是雷室友QQ。</p>
]]></content>
      <tags>
        <tag>experience</tag>
        <tag>IOIC</tag>
      </tags>
  </entry>
  <entry>
    <title>2021IOIC-Day5</title>
    <url>/2021IOIC-Day5/</url>
    <content><![CDATA[<p>最後一天了QQ，優質營隊就這樣結束了。</p>
<p>今天沒有上課，就比一場五小時的團體賽。</p>
<span id="more"></span>

<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>早上起床開始收拾行李，昨晚原本想好要在退房時跟室友說聲謝謝指教之類的，但我起床時就忘記這件事了@@。</p>
<p>到了德田館後我發現我很累，所以就戴著耳機玩音遊讓自己醒腦。</p>
<p>一回過神發現整間教室都不見了，原本想說那就待在這裡好了，但我突然想到連助教都不在鬧空城，這件事肯定不正常。</p>
<p>所以我跑到樓下去看，發現他們正要拍大合照，幸好我有下來看QQ，差點被遺棄。</p>
<p>一直在補blog的心得文，後來比賽就要開始了，10點到下午三點，我還是很不擅長打5小時的比賽。</p>
<p>不過因為題目還沒放好，所以比賽延後十分鐘才開始。</p>
<h1 id="比賽過程"><a href="#比賽過程" class="headerlink" title="比賽過程"></a>比賽過程</h1><p>我們其實沒有擬定什麼策略owo，所以就到處開題跟題。</p>
<p>發現有人開場不久就ac了，就開始跟吧。</p>
<p>結果是個語法水題，拿下後就繼續看其他題。</p>
<p>FHvirus看到pA後就覺得他是最小割，我覺得蠻合理的，但寫dinic好麻煩喔，且我不知道怎麼在無向圖上跑flow。但其實我的想法是用類似kruskal，然後greedy的砍邊。</p>
<p>後來他寫了dinic後測範測是爛的，我就跟他說應該是要用dsu來greedy，他就這樣寫。</p>
<p>我就繼續到處開題，發現pB是個實作題，維護set就好。但是gary(我們第三個隊友)對這題蠻有興趣的，我就讓他寫。</p>
<p>有一題又是像昨天的賽局論，還不確定是梗題還是真的要算SG value之類的，但已經有幾個ac了。</p>
<p>發現到有一題是裸裸ㄉ字串匹配，所以寫個hash她就變綠了(<del>我還是懶得寫KMP或Z</del>)</p>
<p>FHvirus的dsu code也寫好了，範測是好的所以就傳上去，然後wa了。</p>
<p>我幫他看一下發現沒什麼問題，一起想幾個反例發現想不到。</p>
<p>所以我就給他繼續debug，我來想賽局。</p>
<p>後來想超久，一直想不到，中間還出去上廁所吃點心。</p>
<p>越來越多人ac這題，超級多人。</p>
<p>最後用特徵值去推才發現他其實是梗題，跟fhvirus確認想法之後丟上去過了，不過想超久，所以penalty超高。</p>
<p>我們繼續看pA的code，還是沒有想法。</p>
<p>開始燒雞，偶爾看pA，偶爾看其他題，卻都沒什麼想法。</p>
<p>有一題期望值的交給fhvirus去推式子，他有發現是ac自動機，但她抄模板寫出來後debug才發現會有自環的問題。</p>
<p>我提議說我自己重寫pA看看，想當然還是wa。</p>
<p>此時已經三個多小時了，gary砸了兩個多小時還是沒過範測，所以我就把這題給搶過來寫。</p>
<p>後來寫了大概20分鐘，中間有換個寫法，測範測是好的就上傳。</p>
<p>結果wa掉，想了五分鐘後想到還有取整的問題，明明開場看到這題時就有想到，結果過兩個小時就忘了@@。</p>
<p>改掉後就ac了，但因為拖了很久所以penalty大爆炸。其實gary寫到後面心態就已經很差了，我們中途有叫他出去吃點心或者寫太久就放手，但她完全沒出去吃點心在砸那題。然後就被我搶走，我有點愧咎。</p>
<p>之後繼續燒雞，到了最後兩分鐘後我們就攤手等著比賽結束。同時還在看著pA。</p>
<p>他又把他的dinic拿出來看哪裡錯，我發現到他有存後就也跟著看。</p>
<p>發現到他的某個函式亂改@@，他以為無向圖中這樣改會等價，但我覺得並沒有。然而因為沒時間了來不及重打main code(他只有存dinic的部分)，所以我們也沒改。</p>
<p>不過三點了並沒有結束，我們才想到有延後十分鐘。</p>
<p>因為時間很充裕，所以我們就決定賭一把，fhvirus把dinic模板改回講義上的後就開始飛快的打main code，這邊我們團隊分工真的很棒，我負責告訴她輸入格式以及要開哪些陣列還有要寫什麼，他就負責coding。</p>
<p>弄好後測範測還是爛的，當前剩下五分鐘。</p>
<p>我臨時想到可以繼續使用kruskal的想法來做兩次，後來測範測是過的，傳上去後發現ac了…在比賽倒數三分鐘的時候。</p>
<p>看到ac的那刻我忍不住叫了一聲，然後我和fhvirus就超級激動XDD，這感覺超棒。</p>
<p>不過愧疚感油然而生，全都是我一開始假解亂Claim greedy作法還一直執著在上面。如果一開始就相信是最小割然後檢查code應該就能很早過這題。</p>
<hr>
<p>比較特別的是那題梗題居然全場ac，還有pA一大堆人寫出來，大家都會dinic嗎@@</p>
<p>幸好那兩題都有寫出來，不然就被打爆了(雖然還是被penalty打爆)。</p>
<p>波路特石又出了一題超噁心的資料結構題，真的超強orz。</p>
<p>之後就去吃拉麵了</p>
<h1 id="賽後"><a href="#賽後" class="headerlink" title="賽後"></a>賽後</h1><p>因為人很多所以分批，我跟著joylintp所帶領的實中團，然後前兩天晚上在房間內的六個人剛好都在這團XD。</p>
<p>去了中山站吃鳥人，吃完後去西門的animate，後來又走去北車打機。</p>
<p>在走到站前時PixelCat還不知道已經到北車了XD，他不知道西門跟北車近到是能走路就到的距離。</p>
<p>maimai splash在兩天前於台灣稼動，一直很想去打，實際去打覺得除了多很多新歌以外沒什麼差別@@。</p>
<p>我覺得第五天的結果算是讓我最滿意的了，297分鐘寫出pA讓我們名次有往上飛，不過penalty超高，但這刺激感超棒的。</p>
<p><img src="Day5-Scoreboard.png" alt="Day 5 Scoreboard"></p>
<h1 id="總結"><a href="#總結" class="headerlink" title="總結"></a>總結</h1><p>這個營隊真的帶給我很多東西，雖然上課的緊湊方式很難完全吸收，但這就是這個營隊的特色吧。塞很多東西給你，你要做的是把她聽進去後，回家配著講義消化他們。</p>
<p>所以講師們都把講義都寫得能靠自讀來學會，真的很謝謝講師們。</p>
<p>也一次被灌了很多不會的東西，接下來到初選前有得忙了。</p>
]]></content>
      <tags>
        <tag>experience</tag>
        <tag>IOIC</tag>
      </tags>
  </entry>
  <entry>
    <title>TIOJ-2134</title>
    <url>/TIOJ-2134/</url>
    <content><![CDATA[<p>從前從前，有 $N$個英雄和 $M$隻怪物住在一個島上，怪物們最近變得很兇殘，所以英雄們決定要消滅怪物，第$i$個英雄只能消滅 $M_i$這個集合裡的其中一隻怪物。周逸身為英雄團的軍師，研發出了一種藥水，可以加強英雄的能力，一罐藥水可以使一個英雄多消滅一隻怪物。由於藥水有些副作用，一個英雄最多只能服用一瓶藥水，現在有$K$瓶藥水，請幫助周逸算出要最好的策略下，英雄團最多可以消滅多少隻怪物。</p>
<span id="more"></span>
<p>$N, M, K\le 500, |M_i|\le M$</p>
<hr>
<p>這題是最大流應用。<br>該怎麼建模呢?<br>根據題目條件一個一個看:</p>
<ul>
<li>每個英雄只能擊到一個怪物: 從源點連容量為1的邊到每個英雄，每個英雄再連容量為1的邊到每個他可以消滅的怪物上。</li>
<li>每個英雄只能用最多一瓶藥水，藥水可以讓英雄多消滅一個: 從源點連流量為$K$的邊到藥水上，藥水再連容量為1的邊到每個英雄。</li>
<li>問最多能消滅幾隻怪物: 每個怪物連一條流量為1的邊到匯點。</li>
</ul>
<p>這樣最大流就會是可以消滅的怪物數量了。<br>用dinic的複雜度為$\mathcal{O}(V^2E)=\mathcal{O}((N+M)^2NM)$</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">--------------              |   /</span></span><br><span class="line"><span class="comment">      |                     |  /</span></span><br><span class="line"><span class="comment">      |                     | /</span></span><br><span class="line"><span class="comment">      |             *       |/          |    |         ------            *</span></span><br><span class="line"><span class="comment">      |                     |           |    |        /      \</span></span><br><span class="line"><span class="comment">      |             |       |\          |    |       |       |\          |</span></span><br><span class="line"><span class="comment">   \  |             |       | \         |    |       |       | \         |</span></span><br><span class="line"><span class="comment">    \ |             |       |  \        |    |        \     /   \        |</span></span><br><span class="line"><span class="comment">     V              |       |   \        \__/|         -----     \       |</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EmiliaMyWife ios::sync_with_stdio(0); cin.tie(NULL);</span></span><br><span class="line"><span class="keyword">using</span> ll = <span class="keyword">int64_t</span>;</span><br><span class="line"><span class="keyword">using</span> ull = <span class="keyword">uint64_t</span>;</span><br><span class="line"><span class="keyword">using</span> ld = <span class="keyword">long</span> <span class="keyword">double</span>;</span><br><span class="line"><span class="keyword">using</span> uint = <span class="keyword">uint32_t</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> EPS  = <span class="number">1e-8</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF     = <span class="number">0x3F3F3F3F</span>;</span><br><span class="line"><span class="keyword">const</span> ll LINF     = <span class="number">4611686018427387903</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MOD     = <span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="comment">/*--------------------------------------------------------------------------------------*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1007</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">DinicAlgorithm</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">edg</span> &#123;</span></span><br><span class="line">		<span class="keyword">int</span> v, cap, to;</span><br><span class="line">	&#125;;</span><br><span class="line">	vector&lt;edg&gt; edge[N];</span><br><span class="line">	<span class="keyword">int</span> dis[N], n, s, t, iter[N];</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> _n, <span class="keyword">int</span> _s, <span class="keyword">int</span> <span class="keyword">_t</span>)</span> </span>&#123;</span><br><span class="line">		n = _n; s = _s; t = <span class="keyword">_t</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">add_edge</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> f)</span> </span>&#123;</span><br><span class="line">		edge[u].<span class="built_in">push_back</span>(&#123;v, f, edge[v].<span class="built_in">size</span>()&#125;);</span><br><span class="line">		edge[v].<span class="built_in">push_back</span>(&#123;u, <span class="number">0</span>, edge[u].<span class="built_in">size</span>() - <span class="number">1</span>&#125;);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">bfs</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="built_in">memset</span>(dis, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> dis);</span><br><span class="line">		dis[s] = <span class="number">0</span>;</span><br><span class="line">		queue&lt;<span class="keyword">int</span>&gt; que;</span><br><span class="line">		que.<span class="built_in">push</span>(s);</span><br><span class="line">		<span class="keyword">while</span>(!que.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">			<span class="keyword">int</span> u = que.<span class="built_in">front</span>();</span><br><span class="line">			que.<span class="built_in">pop</span>();</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">const</span> <span class="keyword">auto</span> &amp;[v, c, r] : edge[u]) &#123;</span><br><span class="line">				<span class="keyword">if</span>(c &gt; <span class="number">0</span> &amp;&amp; dis[v] &gt; dis[u] + <span class="number">1</span>) &#123;</span><br><span class="line">					dis[v] = dis[u] + <span class="number">1</span>;</span><br><span class="line">					que.<span class="built_in">push</span>(v);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> f)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">if</span>(u == t)</span><br><span class="line">			<span class="keyword">return</span> f;</span><br><span class="line">		<span class="keyword">for</span>(; iter[u] &lt; edge[u].<span class="built_in">size</span>(); iter[u]++) &#123;</span><br><span class="line">			<span class="keyword">auto</span> &amp;[v, cap, rev] = edge[u][iter[u]];</span><br><span class="line">			<span class="keyword">if</span>(!cap || dis[v] != dis[u] + <span class="number">1</span>)</span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">			<span class="keyword">int</span> w = <span class="built_in">dfs</span>(v, <span class="built_in">min</span>(f, cap));</span><br><span class="line">			<span class="keyword">if</span>(w &gt; <span class="number">0</span>) &#123;</span><br><span class="line">				f -= w;</span><br><span class="line">				res += w;</span><br><span class="line">				cap -= w;</span><br><span class="line">				edge[v][rev].cap += w;</span><br><span class="line">				<span class="keyword">if</span>(!f)</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> res;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">flow</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">			<span class="built_in">bfs</span>();</span><br><span class="line">			<span class="keyword">if</span>(dis[t] == INF)</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			<span class="built_in">memset</span>(iter, <span class="number">0</span>, <span class="keyword">sizeof</span> iter);</span><br><span class="line">			res += <span class="built_in">dfs</span>(s, INF);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> res;</span><br><span class="line">	&#125;</span><br><span class="line">&#125; dinic;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123; EmiliaMyWife</span><br><span class="line">	<span class="keyword">int</span> n, m, k;</span><br><span class="line">	cin &gt;&gt; n &gt;&gt; m &gt;&gt; k;</span><br><span class="line">	dinic.<span class="built_in">init</span>(n + m + <span class="number">3</span>, n + m + <span class="number">1</span>, n + m + <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>, a, b; i &lt; n; i++) &#123;</span><br><span class="line">		cin &gt;&gt; a;</span><br><span class="line">		dinic.<span class="built_in">add_edge</span>(n + m + <span class="number">1</span>, i, <span class="number">1</span>);</span><br><span class="line">		<span class="keyword">while</span>(a--) &#123;</span><br><span class="line">			cin &gt;&gt; b;</span><br><span class="line">			dinic.<span class="built_in">add_edge</span>(i, n + b - <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		dinic.<span class="built_in">add_edge</span>(n + m, i, <span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++)</span><br><span class="line">		dinic.<span class="built_in">add_edge</span>(n + i, n + m + <span class="number">2</span>, <span class="number">1</span>);</span><br><span class="line">	dinic.<span class="built_in">add_edge</span>(n + m + <span class="number">1</span>, n + m, k);</span><br><span class="line">	cout &lt;&lt; dinic.<span class="built_in">flow</span>() &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>TIOJ</tag>
        <tag>Flow</tag>
      </tags>
  </entry>
  <entry>
    <title>TIOJ-2012</title>
    <url>/TIOJ-2012/</url>
    <content><![CDATA[<p>在偏遠的競程地區中，有一個神秘人物叫做bb。沒有人知道「bb」這個名子的由來是甚麼，或者它代表甚麼意思，只知道它也許來自於某個古老的傳說。<br>出身於獨特背景的bb，受到上一代宗師的教導，他的實力是許多人難以想像的。據某些消息來源表示，bb可能是唯一一個在成為國手時還不會解二元一次聯立方程式的人物。然而，經過了短短的幾個月，現在輪到bb要考驗大家會不會解$N$元一次方程組了！<br>所謂的$N$元一次方程組，長得像這樣：<br>$$<br>\begin{align}<br>A_{1, 1}x_1 +&amp; A_{1, 2}x_2 +&amp; \cdots &amp;&amp;+ A_{1, N}x_N &amp;= B_1 \newline<br>A_{2, 1}x_1 +&amp; A_{2, 2}x_2 +&amp; \cdots &amp;&amp;+ A_{2, N}x_N &amp;= B_2 \newline<br>&amp; \vdots &amp; \ddots &amp; &amp;&amp; \vdots  \newline<br>A_{N, 1}x_1 +&amp; A_{N, 2}x_2 +&amp; \cdots &amp;&amp;+ A_{N, N}x_N &amp;= B_N \newline<br>\end{align}<br>$$<br>其中$A_{i, j}$和$B_i$都是常數。已知它恰有一組解，你能不能求出正確的$x_i$使上面每一條式子都成立呢？</p>
<span id="more"></span>
<p>$N\le 600, |A_{i, j}|, |B_i|\le 10^5$</p>
<hr>
<p>裸的<a href="https://en.wikipedia.org/wiki/Gaussian_elimination">高斯消去</a>。<br>但直接寫後丟上去會吃wa，原因是精度爆掉。我嘗試過long double和__float128都會爆。<br>後來去問人得到一些建議:</p>
<ul>
<li>為了讓除法能讓值變小，每次消去使用的值絕對值越大越好(Line 49)</li>
<li>把輸入給random shuffle。</li>
</ul>
<p>然後就能ac了(? 甚至不用long double<br>複雜度還是一樣高斯消去的$\mathcal{O}(N^3)$，值得注意的是swap(std::vector, std::vector)是$\mathcal{O}(1)$的。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">--------------              |   /</span></span><br><span class="line"><span class="comment">      |                     |  /</span></span><br><span class="line"><span class="comment">      |                     | /</span></span><br><span class="line"><span class="comment">      |             *       |/          |    |         ------            *</span></span><br><span class="line"><span class="comment">      |                     |           |    |        /      \</span></span><br><span class="line"><span class="comment">      |             |       |\          |    |       |       |\          |</span></span><br><span class="line"><span class="comment">   \  |             |       | \         |    |       |       | \         |</span></span><br><span class="line"><span class="comment">    \ |             |       |  \        |    |        \     /   \        |</span></span><br><span class="line"><span class="comment">     V              |       |   \        \__/|         -----     \       |</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EmiliaMyWife ios::sync_with_stdio(0); cin.tie(NULL);</span></span><br><span class="line"><span class="keyword">using</span> ll = <span class="keyword">int64_t</span>;</span><br><span class="line"><span class="keyword">using</span> ull = <span class="keyword">uint64_t</span>;</span><br><span class="line"><span class="keyword">using</span> ld = <span class="keyword">long</span> <span class="keyword">double</span>;</span><br><span class="line"><span class="keyword">using</span> uint = <span class="keyword">uint32_t</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> EPS  = <span class="number">1e-8</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF     = <span class="number">0x3F3F3F3F</span>;</span><br><span class="line"><span class="keyword">const</span> ll LINF     = <span class="number">4611686018427387903</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MOD     = <span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="comment">/*--------------------------------------------------------------------------------------*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123; EmiliaMyWife</span><br><span class="line">	cout &lt;&lt; fixed &lt;&lt; <span class="built_in">setprecision</span>(<span class="number">15</span>);</span><br><span class="line">	<span class="keyword">int</span> t;</span><br><span class="line">	cin &gt;&gt; t;</span><br><span class="line">	<span class="function">mt19937 <span class="title">gen</span><span class="params">(time(<span class="literal">NULL</span>))</span></span>;</span><br><span class="line">	<span class="keyword">while</span>(t--) &#123;</span><br><span class="line">		<span class="keyword">int</span> n;</span><br><span class="line">		cin &gt;&gt; n;</span><br><span class="line">		vector&lt;vector&lt;<span class="keyword">double</span>&gt;&gt; <span class="built_in">arr</span>(n, vector&lt;<span class="keyword">double</span>&gt;(n + <span class="number">1</span>));</span><br><span class="line">		<span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">xdd</span><span class="params">(n)</span></span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">			xdd[i] = i;</span><br><span class="line">		<span class="built_in">shuffle</span>(xdd.<span class="built_in">begin</span>(), xdd.<span class="built_in">end</span>(), gen);</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">			<span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">tmp</span><span class="params">(n)</span></span>;</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++)</span><br><span class="line">				cin &gt;&gt; tmp[j];</span><br><span class="line">			cin &gt;&gt; arr[i][n];</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++)</span><br><span class="line">				arr[i][xdd[j]] = tmp[j];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> j = i; j &lt; n; j++)</span><br><span class="line">				<span class="keyword">if</span>(<span class="built_in">abs</span>(arr[j][i]) &gt; <span class="built_in">abs</span>(arr[i][i]))</span><br><span class="line">					<span class="built_in">swap</span>(arr[i], arr[j]);</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">				<span class="keyword">if</span>(j == i)</span><br><span class="line">					<span class="keyword">continue</span>;</span><br><span class="line">				<span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt;= n; k++)</span><br><span class="line">					<span class="keyword">if</span>(k != i)</span><br><span class="line">						arr[j][k] -= arr[i][k] * arr[j][i] / arr[i][i];</span><br><span class="line">				arr[j][i] = <span class="number">0</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">			arr[i][n] /= arr[i][i];</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">			cout &lt;&lt; arr[xdd[i]][n] &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>TIOJ</tag>
      </tags>
  </entry>
  <entry>
    <title>TIOJ-2185</title>
    <url>/TIOJ-2185/</url>
    <content><![CDATA[<p>$p_0,p_1,\cdots,p_{M-1}$是$M$個$1 \sim N$的排列，且對於 $i = 1, 2, 3, \cdots, M-1$，$p_i$是$p_{i-1}$交換第$x_i$和第$y_i$個數字得到的排列。假設依照字典序排序這$M$個排列後我們有$p_{a_1} \le p_{a_2} \le \cdots \le p_{a_M}$（若有一樣的排列，則讓下標較小的排列出現在前面），請輸出$a_1, a_2,\cdots,a_M$。</p>
<span id="more"></span>
<p>$N, M\le 10^5$</p>
<hr>
<p>如果我們對每個排列Hash，我們就能在$\mathcal{O}(logn)$的時間知道誰比較大，考慮二分搜，因為只要當前的長度滿足兩個排列(hash值)相同，那在更短的長度肯定相同。所以可以用二分搜找出第一個hash值不一樣的index，找到後只要對他砸模逆元就能得知那一項是多少，如果index為n，那代表兩個排列相同。<br/><br>至於交換操作，可以等價成兩個單點修改，然後我們只需要一個能夠二分搜的資料結構(線段樹!)。<br>可是開$M+1$顆線段樹顯然會炸，注意到我們每次只修改兩個點，所以可以使用持久化線段樹去維護他。<br/><br>時間複雜度$\mathcal{O}(nlog^2n+mlogn)$，空間複雜度$\mathcal{O}(mlogn)$。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">--------------              |   /</span></span><br><span class="line"><span class="comment">      |                     |  /</span></span><br><span class="line"><span class="comment">      |                     | /</span></span><br><span class="line"><span class="comment">      |             *       |/          |    |         ------            *</span></span><br><span class="line"><span class="comment">      |                     |           |    |        /      \</span></span><br><span class="line"><span class="comment">      |             |       |\          |    |       |       |\          |</span></span><br><span class="line"><span class="comment">   \  |             |       | \         |    |       |       | \         |</span></span><br><span class="line"><span class="comment">    \ |             |       |  \        |    |        \     /   \        |</span></span><br><span class="line"><span class="comment">     V              |       |   \        \__/|         -----     \       |</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EmiliaMyWife ios::sync_with_stdio(0); cin.tie(NULL);</span></span><br><span class="line"><span class="keyword">using</span> ll = <span class="keyword">int64_t</span>;</span><br><span class="line"><span class="keyword">using</span> ull = <span class="keyword">uint64_t</span>;</span><br><span class="line"><span class="keyword">using</span> ld = <span class="keyword">long</span> <span class="keyword">double</span>;</span><br><span class="line"><span class="keyword">using</span> uint = <span class="keyword">uint32_t</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> EPS  = <span class="number">1e-8</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF     = <span class="number">0x3F3F3F3F</span>;</span><br><span class="line"><span class="keyword">const</span> ll LINF     = <span class="number">4611686018427387903</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MOD     = <span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="comment">/*--------------------------------------------------------------------------------------*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> C = <span class="number">998244353</span>, N = <span class="number">5e6</span> + <span class="number">25</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">PersistentSegtree</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">		<span class="keyword">int</span> l, r;</span><br><span class="line">		<span class="keyword">int</span> v;</span><br><span class="line">		<span class="built_in">node</span>(): <span class="built_in">l</span>(<span class="number">-1</span>), <span class="built_in">r</span>(<span class="number">-1</span>) &#123; &#125;</span><br><span class="line">		<span class="built_in">node</span>(<span class="keyword">int</span> x): <span class="built_in">l</span>(<span class="number">-1</span>), <span class="built_in">r</span>(<span class="number">-1</span>), <span class="built_in">v</span>(x) &#123;&#125;</span><br><span class="line">	&#125; arr[N];</span><br><span class="line">	vector&lt;<span class="keyword">int</span>&gt; root;</span><br><span class="line">	<span class="keyword">int</span> n, t;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">pull</span><span class="params">(<span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">		arr[p].v = (arr[arr[p].l].v + arr[arr[p].r].v) % MOD;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, vector&lt;ll&gt; &amp;w)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> id = t++;</span><br><span class="line">		<span class="keyword">if</span>(l == r - <span class="number">1</span>) &#123;</span><br><span class="line">			arr[id] = <span class="built_in">node</span>(w[l]);</span><br><span class="line">			<span class="keyword">return</span> id;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">int</span> m = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">		arr[id].l = <span class="built_in">build</span>(l, m, w);</span><br><span class="line">		arr[id].r = <span class="built_in">build</span>(m, r, w);</span><br><span class="line">		<span class="built_in">pull</span>(id);</span><br><span class="line">		<span class="keyword">return</span> id;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> _n, vector&lt;ll&gt; &amp;w)</span> </span>&#123;</span><br><span class="line">		n = _n;</span><br><span class="line">		root.<span class="built_in">push_back</span>(<span class="built_in">build</span>(<span class="number">0</span>, n, w));</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">edt</span><span class="params">(<span class="keyword">int</span> id, <span class="keyword">int</span> old_id, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> p, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(r &lt;= p || p &lt; l)</span><br><span class="line">			<span class="keyword">return</span> id;</span><br><span class="line">		<span class="keyword">if</span>(id == old_id)</span><br><span class="line">			arr[id = t++] = <span class="built_in">node</span>(arr[old_id]);</span><br><span class="line">		<span class="keyword">if</span>(l == r - <span class="number">1</span>)</span><br><span class="line">			<span class="keyword">return</span> arr[id].v = v, id;</span><br><span class="line">		<span class="keyword">int</span> m = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">		arr[id].l = <span class="built_in">edt</span>(arr[id].l, arr[old_id].l, l, m, p, v);</span><br><span class="line">		arr[id].r = <span class="built_in">edt</span>(arr[id].r, arr[old_id].r, m, r, p, v);</span><br><span class="line">		<span class="built_in">pull</span>(id);</span><br><span class="line">		<span class="keyword">return</span> id;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">edt</span><span class="params">(<span class="keyword">int</span> t, <span class="keyword">int</span> p, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(root.<span class="built_in">size</span>() == t)</span><br><span class="line">			root.<span class="built_in">push_back</span>(<span class="built_in">edt</span>(root[t - <span class="number">1</span>], root[t - <span class="number">1</span>], <span class="number">0</span>, n, p, v));</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			<span class="built_in">edt</span>(root[t], root[t - <span class="number">1</span>], <span class="number">0</span>, n, p, v);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function">ll <span class="title">sum</span><span class="params">(<span class="keyword">int</span> id, <span class="keyword">int</span> ql, <span class="keyword">int</span> qr, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(qr &lt;= l || r &lt;= ql)</span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">if</span>(ql &lt;= l &amp;&amp; r &lt;= qr)</span><br><span class="line">			<span class="keyword">return</span> arr[id].v;</span><br><span class="line">		<span class="keyword">int</span> m = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">sum</span>(arr[id].l, ql, qr, l, m) + <span class="built_in">sum</span>(arr[id].r, ql, qr, m, r);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function">ll <span class="title">sum</span><span class="params">(<span class="keyword">int</span> t, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">sum</span>(root[t], l, r, <span class="number">0</span>, n);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">que</span><span class="params">(<span class="keyword">int</span> id1, <span class="keyword">int</span> id2, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(arr[id1].v == arr[id2].v)</span><br><span class="line">			<span class="keyword">return</span> r;</span><br><span class="line">		<span class="keyword">if</span>(l == r - <span class="number">1</span>)</span><br><span class="line">			<span class="keyword">return</span> l;</span><br><span class="line">		<span class="keyword">int</span> m = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">if</span>(arr[arr[id1].l].v != arr[arr[id2].l].v)</span><br><span class="line">			<span class="keyword">return</span> <span class="built_in">que</span>(arr[id1].l, arr[id2].l, l, m);</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">que</span>(arr[id1].r, arr[id2].r, m, r);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">que</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">que</span>(root[a], root[b], <span class="number">0</span>, n);</span><br><span class="line">	&#125;</span><br><span class="line">&#125; tree;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">mpow</span><span class="params">(ll a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">	ll res = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(a %= MOD; b; b &gt;&gt;= <span class="number">1</span>, a = a * a % MOD)</span><br><span class="line">		<span class="keyword">if</span>(b &amp; <span class="number">1</span>)</span><br><span class="line">			res= res * a % MOD;</span><br><span class="line">	<span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123; EmiliaMyWife</span><br><span class="line">	<span class="keyword">int</span> n, q;</span><br><span class="line">	cin &gt;&gt; n &gt;&gt; q;</span><br><span class="line">	q--;</span><br><span class="line">	<span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">arr</span><span class="params">(n)</span></span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">		cin &gt;&gt; arr[i];</span><br><span class="line">	</span><br><span class="line">	<span class="function">vector&lt;ll&gt; <span class="title">owo</span><span class="params">(n)</span>, <span class="title">gg</span><span class="params">(n)</span></span>;</span><br><span class="line">	owo[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++)</span><br><span class="line">		owo[i] = owo[i - <span class="number">1</span>] * C % MOD;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">		gg[i] = arr[i] * owo[i] % MOD;</span><br><span class="line">	</span><br><span class="line">	tree.<span class="built_in">init</span>(n, gg);</span><br><span class="line">	</span><br><span class="line">	gg[n - <span class="number">1</span>] = <span class="built_in">mpow</span>(owo[n - <span class="number">1</span>], MOD - <span class="number">2</span>);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = n - <span class="number">2</span>; ~i; i--)</span><br><span class="line">		gg[i] = gg[i + <span class="number">1</span>] * C % MOD;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>, x, y; i &lt;= q; i++) &#123;</span><br><span class="line">		cin &gt;&gt; x &gt;&gt; y; x--; y--;</span><br><span class="line">		<span class="built_in">swap</span>(arr[x], arr[y]);</span><br><span class="line">		tree.<span class="built_in">edt</span>(i, x, arr[x] * owo[x] % MOD);</span><br><span class="line">		tree.<span class="built_in">edt</span>(i, y, arr[y] * owo[y] % MOD);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">ans</span><span class="params">(q + <span class="number">1</span>)</span></span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= q; i++)</span><br><span class="line">		ans[i] = i;</span><br><span class="line">	<span class="built_in">sort</span>(ans.<span class="built_in">begin</span>(), ans.<span class="built_in">end</span>(), [&amp;](<span class="keyword">int</span> a, <span class="keyword">int</span> b) &#123;</span><br><span class="line">		<span class="keyword">int</span> w = tree.<span class="built_in">que</span>(a, b);</span><br><span class="line">		<span class="comment">//cout &lt;&lt; &quot;comparing &quot; &lt;&lt; a &lt;&lt; &#x27; &#x27;&lt;&lt; b &lt;&lt; &#x27; &#x27; &lt;&lt; w &lt;&lt; &#x27;\n&#x27;;</span></span><br><span class="line">		<span class="keyword">if</span>(w == n)</span><br><span class="line">			<span class="keyword">return</span> a &lt; b;</span><br><span class="line">		<span class="keyword">return</span> tree.<span class="built_in">sum</span>(a, w, w + <span class="number">1</span>) * gg[w] % MOD &lt; tree.<span class="built_in">sum</span>(b, w, w + <span class="number">1</span>) * gg[w] % MOD;</span><br><span class="line">	&#125;);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> a : ans)</span><br><span class="line">		cout &lt;&lt; a &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">	cout &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>TIOJ</tag>
        <tag>data structure</tag>
      </tags>
  </entry>
  <entry>
    <title>TIOJ-1669</title>
    <url>/TIOJ-1669/</url>
    <content><![CDATA[<p>給一個$n\times m$的二維矩陣，包含-1 0 +1，和一個$k$。<br/><br>求一個最小的子矩陣滿足裡面的和至少為$k$。</p>
<span id="more"></span>
<p>$1\le n, m\le 500, 0\le k\le 2.5\times 10^5$</p>
<hr>
<p>一個老套的子矩陣問題，首先枚舉一個維度的左右界，然後就能把那個左右界內的和都壓到剩下那維上，於是變成了一維的問題。<br>接著問題就變成給一個序列，問最小的subarray長度滿足和至少為$k$，如果序列都是正數就能用雙指針了，然而這題有負數。<br/><br>怎麼辦呢? 先給他們做前綴和，然後枚舉右界$r$，之後就是找一個最大的 $l$ 滿足$sum_r-sum_l\ge k$，注意到如果有$l_1 &lt; l_2$且$sum_{l_1}\ge sum_{l_2}$那$l_2$肯定優於$l_1$(因為可以用更小的區間長度湊出更大的區間和)。<br/><br>這樣單調性就出來了! 維護一個單調遞增的stack，然後把上面式子整理一下得$sum_r-k\ge sum_l$，也就是要找出最不超過$sum_r-k$中最大的那個$sum_l$，就只要二分搜就好。<br/><br>因為我是枚舉$n$那一維，所以我的複雜度是$\mathcal{O}(n^2mlogm)$。<br/><br>關於實作的部分，因為根本不用存前綴和，所以我只用一個變數cur當前綴和用。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">--------------              |   /</span></span><br><span class="line"><span class="comment">      |                     |  /</span></span><br><span class="line"><span class="comment">      |                     | /</span></span><br><span class="line"><span class="comment">      |             *       |/          |    |         ------            *</span></span><br><span class="line"><span class="comment">      |                     |           |    |        /      \</span></span><br><span class="line"><span class="comment">      |             |       |\          |    |       |       |\          |</span></span><br><span class="line"><span class="comment">   \  |             |       | \         |    |       |       | \         |</span></span><br><span class="line"><span class="comment">    \ |             |       |  \        |    |        \     /   \        |</span></span><br><span class="line"><span class="comment">     V              |       |   \        \__/|         -----     \       |</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EmiliaMyWife ios::sync_with_stdio(0); cin.tie(NULL);</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF     = <span class="number">0x3F3F3F3F</span>;</span><br><span class="line"><span class="comment">/*--------------------------------------------------------------------------------------*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">char</span> <span class="title">owo</span><span class="params">(<span class="keyword">char</span> c)</span> </span>&#123; <span class="keyword">return</span> c == <span class="string">&#x27;+&#x27;</span> ? <span class="number">1</span> : (c == <span class="string">&#x27;.&#x27;</span> ? <span class="number">0</span> : <span class="number">-1</span>); &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">500</span>;</span><br><span class="line">string arr[N];</span><br><span class="line"><span class="keyword">int</span> sum[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123; EmiliaMyWife</span><br><span class="line">	<span class="keyword">int</span> n, m, nd;</span><br><span class="line">	cin &gt;&gt; n &gt;&gt; m &gt;&gt; nd;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">		cin &gt;&gt; arr[i];</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> ans = INF;</span><br><span class="line"></span><br><span class="line">	vector&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; line;</span><br><span class="line">	line.<span class="built_in">reserve</span>(m);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">		<span class="built_in">memset</span>(sum, <span class="number">0</span>, <span class="keyword">sizeof</span> sum);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j = i; j &lt; n; j++) &#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; m; k++)</span><br><span class="line">				sum[k] += <span class="built_in">owo</span>(arr[j][k]);</span><br><span class="line">			</span><br><span class="line">			<span class="keyword">int</span> cur = <span class="number">0</span>;</span><br><span class="line">			line.<span class="built_in">clear</span>();</span><br><span class="line">			line.<span class="built_in">push_back</span>(&#123;<span class="number">0</span>, <span class="number">-1</span>&#125;);</span><br><span class="line">			</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; m; k++) &#123;</span><br><span class="line">				cur += sum[k];</span><br><span class="line">				</span><br><span class="line">				<span class="keyword">auto</span> it = <span class="built_in">upper_bound</span>(line.<span class="built_in">begin</span>(), line.<span class="built_in">end</span>(), <span class="built_in">make_pair</span>(cur - nd, INF));</span><br><span class="line">				<span class="keyword">if</span>(it != line.<span class="built_in">begin</span>())</span><br><span class="line">					ans = <span class="built_in">min</span>(ans, (k - <span class="built_in">prev</span>(it)-&gt;second) * (j - i + <span class="number">1</span>));</span><br><span class="line">				</span><br><span class="line">				<span class="keyword">while</span>(!line.<span class="built_in">empty</span>() &amp;&amp; line.<span class="built_in">back</span>().first &gt;= cur)</span><br><span class="line">					line.<span class="built_in">pop_back</span>();</span><br><span class="line">				line.<span class="built_in">push_back</span>(&#123;cur, k&#125;);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>(ans == INF)</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;-1\n&quot;</span>;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		cout &lt;&lt; ans &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>TIOJ</tag>
        <tag>Binary Search</tag>
      </tags>
  </entry>
  <entry>
    <title>TIOJ-1425</title>
    <url>/TIOJ-1425/</url>
    <content><![CDATA[<p>有個吐鈔機，他產生(吐)鈔票的機制非常特別。他有無限多個閘口排成一列，從左到右分別是2號,3號,5號,…,如此下去地依照質數由小到大的順序編號。而他需要接收一坨原料才能產生鈔票，且產生這個鈔票的結果受這個吐鈔機的「裁剪係數」x(一個正整數)影響。<br>具體而言，如果你將大小為n的原料丟進一裁剪係數x的吐鈔機，那麼這個吐鈔機會盡量將這坨原料盡可能切成多塊大小恰為x的原料。假設原料被切割成了s塊，那麼對於第i號閘口，如果i整除s，這個閘口就會隨機產生一個0到F之間的整數(16進制)；如果i不整除s的話，這個閘口只會產生一個數字0。而最終產生的鈔票金額，就是把閘口產生的數字反過來寫。<span id="more"></span><br>比如說將大小為19的原料丟進截剪係數為3的吐鈔機時，吐鈔機會先將原料切成6份。而因為2和3整除6，且其它質數都不整除6，所以只有第2號跟第3號閘口有機會產生不是0的數字。假設第2號閘口產生的數字是1，第3號閘口產生的數字是2，那麼最終產生的鈔票金額就是…0000021，也就是21。<br>作為吐鈔機的主人，你想要知道在給定的原料大小下，這個吐鈔機帶給你的驚喜度最高有多高(你並不在意他產生出來的鈔票金額高低)，而一個吐鈔機能帶給你的驚喜感就是他可能產生的鈔票金額種數再加上他的裁剪係數。當然，你不希望這個吐鈔機帶給你的只有超高的驚喜度以及一堆0元鈔票，所以你規定裁剪係數不能超過n。給定一個n，在要求每次一定都只能放大小為n的原料進入吐鈔機的前提下，請問透過調配吐鈔機的裁剪係數而能達到的驚喜感最大值為何？</p>
<p>$N\le 10^7, Q\le 10^4$</p>
<hr>
<p>理解題意後就會發現若原料被切成$x$份，則會有$f(x)$個位置可能會產生16個數字的其中一種，那就會有$16^{f(x)}$種組合。(其中$f(x)$是$x$的質因數數量)。<br/><br>也就是說，他是在問:<br>$$\max_{x=1}^n16^{f(\lfloor\frac{n}{x}\rfloor)}+x$$<br>看到向下取整不難想到可以用數論分塊在根號的時間枚舉完可能的x。(數論分塊會幫我們找出一段區間$[l, r]$使得$\lfloor\frac{n}{l}\rfloor=\lfloor\frac{n}{r}\rfloor$，然後就只要去看$16^{f(\lfloor\frac{n}{r}\rfloor)}+r)$是多少就好)<br/><br>那要怎麼計算$f(x)$? 可以用線性篩配上dp。<br/><br>因為線性篩中每個數字只會被篩一次，如果$x$是質數顯然$f(x)=1$，否則在用這個數字篩掉其他數字時直接把當前的 f 餵給他，假設那個數字跟$x$的最小質因數不一樣，那就把那個數字的$f$再加上1。<br/><br>順便把16的次方給預處理好，注意到$10^7$以內的$f$最大只到7，所以只要用個小小的陣列就塞得下了。<br/><br>至此，我們就能用$\mathcal{O}(1)$的時間檢查，總時間複雜度$\mathcal{O}(Q\sqrt N+N)$。(話說我寫完之後才發現我沒有用while(cin &gt;&gt; n &gt;&gt; q)，但題目明明說有多筆測資?)</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">--------------              |   /</span></span><br><span class="line"><span class="comment">      |                     |  /</span></span><br><span class="line"><span class="comment">      |                     | /</span></span><br><span class="line"><span class="comment">      |             *       |/          |    |         ------            *</span></span><br><span class="line"><span class="comment">      |                     |           |    |        /      \</span></span><br><span class="line"><span class="comment">      |             |       |\          |    |       |       |\          |</span></span><br><span class="line"><span class="comment">   \  |             |       | \         |    |       |       | \         |</span></span><br><span class="line"><span class="comment">    \ |             |       |  \        |    |        \     /   \        |</span></span><br><span class="line"><span class="comment">     V              |       |   \        \__/|         -----     \       |</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EmiliaMyWife ios::sync_with_stdio(0); cin.tie(NULL);</span></span><br><span class="line"><span class="keyword">using</span> ll = <span class="keyword">int64_t</span>;</span><br><span class="line"><span class="keyword">using</span> ull = <span class="keyword">uint64_t</span>;</span><br><span class="line"><span class="keyword">using</span> ld = <span class="keyword">long</span> <span class="keyword">double</span>;</span><br><span class="line"><span class="keyword">using</span> uint = <span class="keyword">uint32_t</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> EPS  = <span class="number">1e-8</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF     = <span class="number">0x3F3F3F3F</span>;</span><br><span class="line"><span class="keyword">const</span> ll LINF     = <span class="number">4611686018427387903</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MOD     = <span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="comment">/*--------------------------------------------------------------------------------------*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e7</span> + <span class="number">25</span>;</span><br><span class="line"><span class="keyword">char</span> cnt[N];</span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; prime;</span><br><span class="line"><span class="keyword">int</span> fac[<span class="number">8</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123; EmiliaMyWife</span><br><span class="line">	prime.<span class="built_in">reserve</span>(<span class="number">664699</span>);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; N; i++) &#123;</span><br><span class="line">		<span class="keyword">if</span>(!cnt[i])</span><br><span class="line">			prime.<span class="built_in">push_back</span>(i), cnt[i]++;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> a : prime) &#123;</span><br><span class="line">			<span class="keyword">if</span>(<span class="number">1LL</span> * a * i &gt;= N)</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			cnt[a * i] = cnt[i];</span><br><span class="line">			<span class="keyword">if</span>(i % a == <span class="number">0</span>)</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			cnt[a * i]++;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	fac[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; <span class="number">8</span>; i++)</span><br><span class="line">		fac[i] = fac[i - <span class="number">1</span>] * <span class="number">16</span>;</span><br><span class="line">	<span class="keyword">int</span> mn, q;</span><br><span class="line">	cin &gt;&gt; mn &gt;&gt; q;</span><br><span class="line">	<span class="keyword">while</span>(q--) &#123;</span><br><span class="line">		<span class="keyword">int</span> n;</span><br><span class="line">		cin &gt;&gt; n;</span><br><span class="line">		<span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>, j; i &lt;= n; i = j + <span class="number">1</span>) &#123;</span><br><span class="line">			<span class="keyword">int</span> x = n / i;</span><br><span class="line">			j = n / x;</span><br><span class="line">			ans = <span class="built_in">max</span>(ans, fac[cnt[x]] + j);</span><br><span class="line">		&#125;</span><br><span class="line">		cout &lt;&lt; ans &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>TIOJ</tag>
        <tag>math</tag>
      </tags>
  </entry>
  <entry>
    <title>2021台灣資訊奧林匹亞研習營初選</title>
    <url>/2021%E5%8F%B0%E7%81%A3%E8%B3%87%E8%A8%8A%E5%A5%A7%E6%9E%97%E5%8C%B9%E4%BA%9E%E7%A0%94%E7%BF%92%E7%87%9F%E5%88%9D%E9%81%B8/</url>
    <content><![CDATA[<p>差點成為最後一次的成果驗收(?<br>話說也是這個blog滿一年欸，第一篇就是去年初選。</p>
<span id="more"></span>
<h1 id="賽前"><a href="#賽前" class="headerlink" title="賽前"></a>賽前</h1><p>前一天去打機打了一整天，其實對心態幫助頗大(?<br>到了晚上也沒那麼緊張。<br>不過隔天進到了電腦教室還是有緊張感，不過已經還好了。可是在賽前大約15分鐘的時候發生了一件事。<br>電腦教室很熱，我穿著三件衣服所以想脫，然後我就很順手的把衣服給拖掉，在脫下來的時候我聽到了啪一聲，我的鏡框壞了。<br>我整個緊張感都上來了，一直想辦法把它弄好，但是他似乎沒救了。到比賽開始5分鐘前我覺得就不喬了(不然越喬越荒)，相信著這影響不了什麼。<br>所以我就帶著常常掉下來所以得一直重戴又歪一邊的眼鏡，還有因為這件事變得超級緊張的心情開始了<br><img src="https://i.imgur.com/M5GKmnM.jpg" alt="壞掉的眼鏡"></p>
<h2 id="策略"><a href="#策略" class="headerlink" title="策略"></a>策略</h2><p>我前幾天規劃出來的策略是</p>
<ol>
<li>開場花不到20分鐘把每題題目子題看完，同時每題花不超過兩分鐘想直覺的解。</li>
<li>把那些直覺的子題根據確定性與實作難度一個一個拿掉(大約在1:00 ~ 1:30內做完)。</li>
<li>剩下的題目每題想20分鐘，同時開始刻需要資結的題目。</li>
</ol>
<p>每一個小時都要出去吃東西。<br>寫出題目或寫不出題目都要喝水上廁所。</p>
<h1 id="第一小時"><a href="#第一小時" class="headerlink" title="第一小時"></a>第一小時</h1><p>在20分鐘內把題目都看完了<br>每題的想法:<br>pA水題，pB小測資dp，pC可能是怪dp，pD的O(nq)感覺很可做，pE似乎就是炮打皮皮。<br>同時模板也打完了，花五分鐘把pA給翻綠。<br>然後開始刻pB的dp，大概花20分鐘後還是過不了範測，把dp的過程print出來後越想越怪，去重看題目才發現看錯了，我以為每個地方的時間函數都是用當前時間t，結果是分開計算。</p>
<h1 id="第二小時"><a href="#第二小時" class="headerlink" title="第二小時"></a>第二小時</h1><p>我很快地想到這題跟TIOJ上有一題一樣，而那題關鍵的想法就是枚舉最多取到第幾個(因為回頭肯定不optimal)，然後就用pq拿了30分。<br>花了五分鐘想想看滿分解，然而沒想法要怎麼優化pq的行為。<br>把pC重讀了一次，大致列出了轉移式，推一推發現這好像就是二維偏序了，可是要輸出解很麻煩，總之先拿暴力55分之後再補上資結。<br>寫一寫發現又跟範測兜不上了，所以又去重看了一次題目，發現他的輸入格式比我想得還毒瘤。<br>花一點時間把輸入處理成二維偏序，然後就上傳看看，WA，此時已經過了一小時半。<br>我的心態其實已經有點小炸，在比賽過了一半的時間中我卻只拿到130分。<br>後來發現了一些處理輸入時沒弄好的bug後，還是0分。<br>出去喝水吃東西上個廁所，回來改點穩一點的寫法，0分。<br>一直到1:45左右，我的心態已經炸到谷底。<br>此時我想起zck說過發現自己在原地打轉時就要想辦法跳出，我也才發現我居然到現在都還沒出去吃東西。所以我就出去吃個東西，去廁所安定一下心情。<br>回來後想到了不知道誰說過不能有0分的題目，所以我就先去拿拿看DE，pD的O(nq)又是有點小煩躁的實作，不過幸好把題目的條件都打進去後就拿到了16分。</p>
<h1 id="第三小時"><a href="#第三小時" class="headerlink" title="第三小時"></a>第三小時</h1><p>已經到了最後一個小時了，500分中拿不到150分，可說是最慘的結果。<br>原本會是這樣想的，但是重新拿到分數後對心態回復蠻多了(上一次拿到分數是一小時前的pB，整場有一小時完全沒分數)。<br>所以就去寫pE，確定是炮打皮皮後就刻了匈牙利，稍微想了一下該怎麼構策略發現沒想法於是決定就拿24分就好。<br>寫六分鐘丟上去後吃WA，發現沒輸出策略。<br>再丟上去還是WA。心態又開始有點不穩了，不過我還是靜下心來好好的看code。<br>匈牙利已經簡單到不太可能刻爛了，所以應該是其他地方有錯，但這題應該就是炮打皮皮沒錯。<br>過了大概10分鐘，我就想到了輸出的問題。<br>在2:27把行尾空格全部去掉後丟上去，24分到手。<br>我當時整個超氣，輸出嚴格比對到底是怎樣，搞人嗎??我直接被吃掉10幾分鐘。<br>但此時我想到pC會不會也是這樣的問題，原本我的pC的輸出長這樣:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// id是輸出第一項 nxt代表他的下一項 id為0代表到了結尾 arr[id].i代表第i項的編號</span></span><br><span class="line"><span class="keyword">while</span>(id) &#123;</span><br><span class="line">    cout &lt;&lt; arr[id].i &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    id = nxt[id];</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br></pre></td></tr></table></figure>
<p>我就改成這樣</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">cout &lt;&lt; arr[id].i;</span><br><span class="line">id = nxt[id];</span><br><span class="line"><span class="keyword">while</span>(id) &#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; arr[id].i;</span><br><span class="line">    id = nxt[id];</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br></pre></td></tr></table></figure>
<p>然後就把暴力的55分拿到了。火氣整個上來了。<br>被卡了一個小時居然是這樣的原因。<br>此時離比賽結束剩下30分鐘，因為在兩分鐘內pC的55分和pE的24分實在有點多(跟我可悲的分數比起來)，所以讓我心態回復很多，我決定好好地把比賽拚完。<br>看了BCDE，還是決定把pC套個BIT拿滿，畢竟當初寫部分分時就已經用著可以很方便改成資結的寫法。<br>寫完BIT之後一直吃WA，但我不想放棄，我不想放棄這45分。<br>一樣把各種東西跟當初的暴力解法比對之後還是找不到bug，所以我就把operator overload的部分改成cmp函式。範測過了<br>在2:46的時候丟上去，100分。<br>此時的我雖然開心，但是卻又不安，因為在策略中，我在比賽結束前10分鐘才做到第二點「把開場讀完題的子題一一收掉」，在第三點中我給每題20分鐘時間想，但是已經沒時間了。<br>最後十分鐘就盯著pB嘗試通靈，但是還是沒想法。</p>
<h1 id="賽後"><a href="#賽後" class="headerlink" title="賽後"></a>賽後</h1><p>其實我結束當下整個不安感就上來了，我花了三個小時僅僅只是把基本的分數都拿到，我預估線大約落在280-300up，高中的競賽之路就到這裡結束。<br>不敢看計分板，戴上耳機後就離開，不過我發現到我沒有眼鏡不太應該在大街上自己走，所以就打開手機然後發現nathan要過來，我才知道大家集體燒雞@@。<br>總之，看來高中競賽之路還沒結束(?<br>可是今天的問題都蠻嚴重的，就是我只是剛剛好把基本分給拿完，我的實力還是跟其他人差了一大截，尤其我想題都會想不太到，今天都是看過的題目(pB 二維偏序 炮打皮皮)，遇到沒看過的很容易燒雞。</p>
]]></content>
      <tags>
        <tag>Competitive Programming</tag>
        <tag>TOI</tag>
        <tag>experience</tag>
      </tags>
  </entry>
  <entry>
    <title>110學年度北二區資訊學科能力競賽</title>
    <url>/110%E5%AD%B8%E5%B9%B4%E5%BA%A6%E5%8C%97%E4%BA%8C%E5%8D%80%E8%B3%87%E8%A8%8A%E5%AD%B8%E7%A7%91%E8%83%BD%E5%8A%9B%E7%AB%B6%E8%B3%BD/</url>
    <content><![CDATA[<p>高中最後一次的區賽。</p>
<span id="more"></span>
<p>一直以為都第三年參加了應該可以穩定平常心，結果卻莫名緊張，甚至差點把我送下去@@</p>
<h1 id="比賽過程"><a href="#比賽過程" class="headerlink" title="比賽過程"></a>比賽過程</h1><p>分上下午場。<br>依照總分排名，同分按最後得分時間比序。</p>
<h2 id="上午場"><a href="#上午場" class="headerlink" title="上午場"></a>上午場</h2><p>上午場是五題，三小時。<br>開始前在電腦前面甚至在發抖，完全不知道在幹麻。<br>開場一樣先把 defualt code 打好，然後就開始看題目，發現題目居然有子題了，還真棒。<br>其實我是先看完全部題目再開始寫的，不過寫的順序也是 ABCDE，所以就直接一題一題打出來吧。</p>
<h3 id="pA"><a href="#pA" class="headerlink" title="pA"></a>pA</h3><blockquote>
<p>給兩個平行座標軸的矩形和一個點，問該點在多少矩形以內。</p>
</blockquote>
<p>語法題@@<br>把判斷 function 寫好後測一測範測是好的就丟了上去。<br><em><strong>0/100 WA</strong></em><br>？？ 難道測資又爛了嗎<br>雖然想要直接跳題但是我決定給自己十分鐘檢查看看，檢查不出來就先當測資爛掉了。<br>檢查大概八分鐘終於發現題目給的對角座標可能是左下-右上的，改一下判斷式就拿滿了。<br><em><strong>100/100</strong></em><br>後來去看 pB。</p>
<h3 id="pB"><a href="#pB" class="headerlink" title="pB"></a>pB</h3><blockquote>
<p>給一堆值域 int 範圍內的分數，模擬從左邊往右逐漸加起來的過程。<br>原題目還有保證加起來後約分還會是 int 範圍內，只是我沒看到。</p>
</blockquote>
<p>因為沒看到這條件，所以我以為這題滿分可能需要大數運算。<br>所以我直接先把前兩題子題（只有兩個分數相加）撈完，不過想說唬爛看看所以我刻意把 code 寫成應付滿分解的樣子，只是直接拿 long long 硬算。<br><em><strong>53/100 RE</strong></em><br>我看到是 RE 後就直接以為是 overflow，然後就跳題了。</p>
<h3 id="pC"><a href="#pC" class="headerlink" title="pC"></a>pC</h3><blockquote>
<p>給 8MB 的記憶體和 $5\times 10^6$ 個整數，每個數字範圍在 $[1, 500]$，輸出這些整數的中位數。</p>
</blockquote>
<p>看到這題我第一個想法是二分搜中位數，想了一想發現：「不對啊，我二分搜也需要把所有整數存起來，怎麼夠用」，再看一次題目發現值域超小，垃圾題目= =;<br><em><strong>100/100</strong></em></p>
<h3 id="pD"><a href="#pD" class="headerlink" title="pD"></a>pD</h3><blockquote>
<p>給一張帶權無向圖和起點終點，每條邊可能是兩種種類其中一種，問從起點到終點在最多只改變一次走的邊的種類的情況下的最短路徑</p>
</blockquote>
<p>一臉 dijkstra，只是我好久沒寫了，最近都只遇到 BFS 的題目。<br>幸好 dijkstra 幾乎就只是 BFS 的 queue 改成 priority_queue，寫一寫看一看就 AC 了。<br><em><strong>100/100</strong></em></p>
<h3 id="pE"><a href="#pE" class="headerlink" title="pE"></a>pE</h3><blockquote>
<p>給數列 $h$ 跟和數列 $d$ 和 $c$，可以選任意的 $(i, j)$ 滿足 $h_k\lt min(h_i, h_j)\forall i\lt k\lt j$，定義 $(i, j)$ 的價值為 $min(h_i, h_j)\times \sum_{n=i}^{j-1} d_n$，問所有價值不低於 $c$ 的選法中最小價值是多少。</p>
</blockquote>
<p>既然兩點中間都要小於兩點，那看起來就很單調 stack。<br>剛好在 $j$ 不變的情況下 $(i, j)$ 的價值會隨著 $i$ 有單調性，所以就寫個二分搜配上前綴和。<br/><br><em><strong>0/100</strong></em><br><del>測資又爛ㄉ一ㄠ…</del>，沒，先丟個爆搜確認看看解是不是都會在 stack 裡面。<br><em><strong>0/100</strong></em><br>居然連這樣爆搜都沒過？<br>想了快五分鐘才想到 stack 中的左界只能取到大於當前 $h_i$ 的第一個，再往前還是不能取。<br/><br>先二分搜二分搜的左界，然後二分搜，就 AC 了<br><em><strong>100/100</strong></em></p>
<p>到這裡大約比賽過了一小時，而現在才是惡夢的開始。<br>我看到 pB 的 verdict 好像是 violeting memory limit（其實我不太清楚，連要好好看 verdict 都不懂@@），但我卻沒有去考慮陣列亂戳的情況。<br>反而是覺得這題需要大數，而我吃了 overflow 才會 RE。<br>想說反正剩將近兩小時，我就開始寫大數了，但我只寫過大數加法而已。</p>
<p>花了一個半小時把加減乘除和 gcd 都刻出來了，都是邊寫邊測試的所以看起來沒什麼問題，只是乘除是 $O(nm)$，畢竟我不會 FFT。<br/><br>中途有想過把 long long 改成 __int128，只是還是沒過。<br>總之大數看起來很不錯，丟上去看看。<br><em><strong>53/100 TLE</strong></em><br>居然沒寫爛，我還蠻欣慰的，可是 TLE 我真的無解。<br>然後就只能到處看大數哪裡能優化然後傻傻的以為大家都不會拿到這筆。</p>
<h2 id="中午"><a href="#中午" class="headerlink" title="中午"></a>中午</h2><p>一結束後我到處問，發現全世界都有把 pB 拿滿，全世界都有破台。<br>就算不是誇飾，至少也聽到了 8 個破台，已經到了全國賽的名額。<br>所以上午場結束，我的名次在全國賽線外，又只是因為我智障到大家都水掉的水題我沒拿到。<br>導致我中午連吃飯都沒什麼心情，只是戴上耳機想遠離世間一切塵囂。<br>腦中浮現了各種可怕的想法，比如現在直接蹺掉下午賽程，回班上去上下午的課程之類的。<br>但幸好看菈米直播看到後來心情有好一點了，把午餐吃完後想辦法穩住自己心態。<br>雖然心態還是很炸。</p>
<h2 id="下午場"><a href="#下午場" class="headerlink" title="下午場"></a>下午場</h2><p>下午題號接著上午是 pFGH，兩個小時。</p>
<p>下午我在電腦前變得更抖，因為我一定要把差距補回來，上午損失太重。<br>加上心態也不是很穩了。<br>開場發現電腦沒有還原，上午的 code 還留著。<br>所以就直接看題目，做題順序一樣是照順序。</p>
<h3 id="pF"><a href="#pF" class="headerlink" title="pF"></a>pF</h3><blockquote>
<p>　給班上每位同學的成績，對於每位同學輸出他在班上的排名</p>
</blockquote>
<p>怎麼又是語法題@@ 到底多怕大家零分<br>因為分數是 0 到 100，所以就開個陣列紀錄每個分數有哪些人。<br><em><strong>88/100 WA（只拿到大家分數皆不相同的子題）</strong></em><br>小丑竟是我自己，原來我不會語法。<br>因為 $n$ 很小，所以 $O(n^2)$ 爆搜對於每個人，有多少人分數高於他。<br/><br><em><strong>88/100 WA</strong></em><br>仔細看了一下我的 code 和重讀好幾次題目，但發現不了問題，所以只好跳題。<br>同時想著可能是測資爛了，搞不好等等就 rejduge。</p>
<h3 id="pG"><a href="#pG" class="headerlink" title="pG"></a>pG</h3><blockquote>
<p>有一個 $n\times m$ 的棋盤（其中 $n\times m\le 10^6$），有一些隔子是有障礙物的，問有多少種放法可以把兩個棋子放在沒有障礙物的相異格子上，且兩個棋子必須要在同列或同行或同斜排</p>
</blockquote>
<p>就開個陣列算一下每行每列每斜排，只是我偷懶所以直接用 map。<br><em><strong>19/100 TLE</strong></em><br>哈哈，被制裁了。改成普通陣列。<br><em><strong>100/100</strong></em><br>到目前開場過了半個小時左右，節奏還可以，雖然 pF 蠻傷腦筋的。</p>
<h3 id="pH"><a href="#pH" class="headerlink" title="pH"></a>pH</h3><blockquote>
<p>給 $n$ 和 $s$，輸出任意一種把整數 $1,2,\cdots ,n$ 分到 $s$ 個容器內的方法，必須滿足每個容器內的數字總和皆相等。</p>
</blockquote>
<p>直覺告訴我這題就是這場的決勝點了。<br>想了大概十分鐘突然想起 tie breaker 是看時間，所以先把 $s=2$ 的背包拿下。<br><em><strong>32/100</strong></em><br>這時我面臨了重要抉擇，要回去 debug pF 還是繼續全力想 pH 滿分解。<br>我決定全力想 pH，原因是 pH 的滿分可以讓我拿 68 分，就算沒拿到 pF 而損失 12 分，加上上午場損失的 47 分也還是不及 68 分這麼多，所以拿到的話就能確保我能贏過沒拿到的人。<br>相比之下， pF 的 12 分實際效益真的不大，尤其是我覺得他之後會 rejudge = =;</p>
<p>然後又想了二十分鐘左右，只是完全沒有任何觀察/想法。<br>也有可能是太焦慮的關係，我沒辦法好好思考。<br>所以我決定開始唬爛。<br>這是蠻冒險的抉擇，因為通常我開始唬爛後就不會去想滿分解了，應該要在最後沒辦法時才唬爛，而現在才過不到一小時。<br>可是我很迫切的想要拿到這分數，不然我真的很有機會進不了全國。</p>
<p>因為整數是連續的從 $1$ 到 $n$，所以看起來就會有很多解是符合的，也看起來亂構蠻容易構出解的，所以我就先維護還沒用過的數字有哪些，每次把那些數字從大到小拿去做背包，把背包構出來的解給加進答案，然後再繼續構新的背包。<br>從大到小是因為從小到大的話背包會包含太多小數字，這樣到後面大數字感覺就比較容易燒雞。（事實上我後面有傳傳看小到大的解，確實沒有分數）<br>傳上去之後等待 judge 的期間就繼續想更多唬爛解，想辦法砸越多越好。<br>結果他就 AC 了。<br><em><strong>100/100</strong></em><br>我在電腦前面傻掉，這好像是我第一次正式比賽嘗試唬爛然後成功的，以往都是我自己以為是正解到後來才發現是假解。</p>
<p>後來我就一直等著 pF 什麼時候會 rejudge，結果在 rejudge 公告前先來的是改題目的公告。<br>他們官解明明寫錯，結果他們不是修正官解，而是把題目改成官解的寫法。<br>我看到當下快中風，因為感覺這場就會用到 tie breaker，這樣亂改題目變成比誰先看到公告然後誰先把新的解打出來。<br>尤其我實在太氣所以不小心傳了兩筆 WA。<br><em><strong>0/100 WA</strong></em><br><em><strong>0/100 WA</strong></em><br><em><strong>100/100</strong></em><br>把 pF 給拿滿之後我就開始祈禱下午場不要那麼多人破台<br>同時祈禱 pF 的 tie breaker 不要讓我出事，同時<del>一直罵師大</del>。</p>
<h1 id="賽後"><a href="#賽後" class="headerlink" title="賽後"></a>賽後</h1><p>最後還真的不少上午破台的人下午沒拿滿 pH，所以我從全國賽線外飛到第四名 XD。<br>算是運氣好吧，要是我 pH 沒有唬爛成功真的就超危險，嘗試唬爛 pH 真的是今天唯一做對的決策。<br>上午場的敗筆真的就是 pB 沒看清楚題目/沒看 verdict/沒去想自己寫爛，整個把最壞決策都示範了一遍。<br>總之拿到比去年好一名的成績也讓我滿足了&gt;&lt;</p>
<p><img src="owo.jpg" alt="第四名owo"></p>
]]></content>
      <tags>
        <tag>Competitive Programming</tag>
        <tag>experience</tag>
      </tags>
  </entry>
  <entry>
    <title>2021NPSC</title>
    <url>/2021NPSC/</url>
    <content><![CDATA[<p>今年 NPSC 變成線上的了orz<br>原本想說不是實體賽就有點懶得發文，只是想到還有一些值得紀錄的事情該記錄下來。</p>
<span id="more"></span>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>因為去年帶的那個學弟今年不想打了，所以就從高一那邊抓一個看起來有料的進隊伍，想說從新血開始培養，不然竹中競程真的可能會下去= =;<br>我上個月把板中講義丟給他，比賽前三天我還得教他時間複雜度，坦白說我有點生氣，不過這不是這篇文的重點，只是因為他沒有準備所以我也沒辦法丟給他什麼題目。</p>
<h1 id="第一小時"><a href="#第一小時" class="headerlink" title="第一小時"></a>第一小時</h1><p>我們分配好切三半，我負責最後三題。<br>幸好 pH 跟 pI 題目都很易懂，所以我很快就讀完了，只是沒想法而已。</p>
<p>在看完 pG 後我覺得這題應該會是很可作的題目，就把其中一個隊友叫來一起想。起初想到的是先從最小的砍和最大的砍，但都有想到 hack 測資。突然想到會不會是直接砍最小的 $\frac{n}{2}$ 個數字就好，想一想發現超合理，看了一下記分板發現已經有兩三隊 AC 了，所以直接開寫。<br/><br>pG AC 0/11<br>蠻幸運很快就開到這題，要是想快一點搞不好有機會首殺(?)，梗題就別要求這麼多好了。</p>
<p>燒雞開始。<br>發現到 pC 也已經有人 AC 了，就去看題目。隊友提出一個感覺很合理的從前面到後面 greedy，結果範測就 WA 掉了。<br>我開始胡思亂想，既然寫那麼快應該也是有很簡單的結論才對。如果把第一個位置按的次數叫做 $a$，第二個位置按的次數叫做 $b$，第三個叫做 $c$。那在 $N=3$ 的情況下我們可以列出這個線性方程組。<br>$$\begin{align*}<br>a+b &amp;\equiv s_1\mod 2 \\<br>a+b+c &amp;\equiv s_2\mod 2 \\<br>b+c &amp;\equiv s_3\mod 2<br>\end{align*}$$<br>把他高斯消一消發現 $a, b, c$ 有唯一解，所以 $N\ge 3$ 的話必有解？<br/><br>pC WA *1<br>把 $N=4$ 給消一消還是有解。<br/><br>但是 $N=5$ 時突然就有了一個條件：$s_1+s_2+s_4+s_5\equiv 0\mod 2$。<br/></p>
<h1 id="第二小時"><a href="#第二小時" class="headerlink" title="第二小時"></a>第二小時</h1><p>然後 $N=7, 9$ 都還是有解。可是感覺不會只有 $N=5$ 無解吧，後來隊友叫我把 $N\le 11$ 的爆搜看看，發現在 $N=2,5,8,11$ 才有可能無解。<br/><br>把 $N=8$ 的拿去高斯消，發現條件是 $s_1+s_2+s_4+s_5+s_7+s_8\equiv 0\mod 2$。<br/><br>至此結論已經出來了，但我根本不知道為啥前面幾隊可以寫這麼快。<br>pC AC 1/69</p>
<p>心態基本上已經爆炸了，此時的名次在超級無敵後面。<br>看到 pB, pF, pI 都已經有人開過了，聽完 pF 想說拓樸記數不是 NP 嗎？<br>所以就去開感覺比較可作的 pB 了。<br>這題就很正常，想法慢慢堆積到產生一個解。只是我太笨在想的過程中想太久，有些 claim 還被隊友 hack 掉。</p>
<h1 id="第三小時"><a href="#第三小時" class="headerlink" title="第三小時"></a>第三小時</h1><p>然後實作時才發現自己還有一堆 case 沒思考好，又花了一堆時間邊寫邊想，到很後面才終於過範測。幸好一發 AC。<br>pB AC 0/160</p>
<p>因為我們 pC 做太久，所以兩題線時我們在很後面，不過三題以上的不多，所以做出 pB 後我們就飛到比較上面了。<br>後來看到記分板上 pF 做出人數明顯多於 pI，所以就去想 pF 了。<br>因為我很確定一般圖算拓樸沒有好方法，所以肯定是那個 $\lt 1%$ 輸出 $0$ 在搞事。<br/><br>高一那個學弟：「不能直接跑去計算有幾條嗎？」<br>我：「這樣複雜度肯定炸。」</p>
<h1 id="第四小時"><a href="#第四小時" class="headerlink" title="第四小時"></a>第四小時</h1><p>後來就是到處亂想，想辦法找到某個限制使得不滿足那個限制的話輸出 $0$，否則有了那個限制就會很好做。<br/><br>但是找不到，後來突然想到高一學弟的那句話後發現：「喔靠北，直接 dfs 跑出 100 條就能 return 了啊」<br>被學弟徹底打爆了。<br>後來還有一些細節，比如在想拔掉一個點後 dfs 回來之後要怎麼把點加回去，用 set 帶一個 log 感覺就很爛。<br>後來是用 deque 把點直接 push_back，同時紀錄這層第一個走到的是誰來判斷有沒有全部走完。<br>pF TLE *1<br>喔，無解好像會炸掉，來判一下<br>pF AC 1/237</p>
<p>後來手上看起來比較可作的題目是 pD, pH, pI。<br>pD 我真的沒什麼想法。<br>pH 我在聽完題目時有想到 $dp_{i, j} := $ 有幾種 $s$ 的最後一個字元是從 $B$ 的第 $i$ 個字元來，且 $A$ 的前 $j$ 個字元是 $s$ 的子序列。可是在轉移時必須把 $B$ 之後的字元都遍歷過，然後感覺遇到重複字元的情況下很容易算到重複，尤其記分板沒人做這題，感覺處理重複的部份很難，所以先去做有人做的 pI 感覺就比較好。<br/><br>賽後才知道這方向是對的，只要取最近一個字元就不會有重複，只看記分板就把這題丟掉是個超爛的抉擇。</p>
<p>尤其 pI 我也只想到二維表格 $B_{i, j}$ 代表區間 $[i,j]$ 有幾種相異數字，詢問 $[L,R]$ 相當於詢問 $B$ 從 $[L,L]$ 到 $[R,R]$ 的區間和。<br/><br>這部份我只會用二維線段樹做。</p>
<h1 id="第五小時"><a href="#第五小時" class="headerlink" title="第五小時"></a>第五小時</h1><p>我想不到除了二維線段樹的作法，但這個作法複雜度很炸。<br>該怎麼辦？<br>繼續想 pH？直接開寫？<br>看了記分板後我還是決定唬爛看看寫這個。<br>結果寫了快一個小時連範測都沒過。</p>
<h1 id="總結"><a href="#總結" class="headerlink" title="總結"></a>總結</h1><p>4/517, rk10<br>這場 pB 真的就直接顯現了我在寫維護一堆東西的題目時常常都會整個亂掉或沒想好細節。<br>說是實作爛嗎？我也不確定算不算，因為我出的 bug 都是我想錯或者我沒想好，單純打錯字之類的都沒有。以前一直以為自己很擅長寫偏實作的題目，但那只是在 CF 偏實作而已，最近多 Vir 了幾場 OI 才發現 CF 的偏實作也只是小菜一碟，真的實作題我也是會一直沒想清楚然後寫很久。<br>想題目也想太慢，但這部份我不知道怎麼辦，只能說我太弱了。<br>最後的決策真的讓人很中風，因為自己已經有點落後了所以就會很想把前面隊伍開過的題目給開掉，結果就因此把可能做出來的題目給丟掉了。<br>高中最後一年 NPSC 就到這邊了，雖然很不負責的來說三年來每年名次都有進步，可是真的覺得自己應該還可以作到更好，比完之後心情也不是很好，與其說難過，比較像是滿滿的後悔，後悔自己賽前在混，後悔自己賽中想題目都在亂繞，後悔自己賽中決策。</p>
]]></content>
      <tags>
        <tag>Competitive Programming</tag>
        <tag>experience</tag>
      </tags>
  </entry>
  <entry>
    <title>BOI 2014 Portals</title>
    <url>/BOI-2014-Portals/</url>
    <content><![CDATA[<p>覺得這題還不錯，所以來寫題解。<br>以下內容都是出自寫這題時的想法，實作也是，所以不一定是最簡潔的作法(?)。</p>
<span id="more"></span>
<h1 id="題目"><a href="#題目" class="headerlink" title="題目"></a>題目</h1><blockquote>
<p>題目敘述部份取自 <a href="https://hydro.ac/d/luogu/p/P6742">luogu OJ</a>，英文題敘可到 <a href="https://cses.fi/118/list/">cses</a>。</p>
</blockquote>
<p>給定一個 $R\times C$ 的迷宮，每個格子都有一種方塊，迷宮四周也有 <code>#</code> 圍著：</p>
<ul>
<li><code>#</code> 墻，不可以走，不可以穿過</li>
<li><code>.</code> 路，可以走</li>
<li><code>S</code> 出生點，玩家從這里開始走，只有一個</li>
<li><code>C</code> 終點，玩家要到達這里，只有一個</li>
</ul>
<p>並且在任何時候，它都可以向上、左、下、右四個方向中的一個發射傳送門。當一個傳送門被發射，它會一直向發射的方向飛行，直到碰觸到墻壁。這時，傳送門會被放置在這堵墻上。<br>你可以走到相鄰一格，花費 $1$ 的時間，當迷宮有兩個傳送門時，也可以穿梭傳送門，需要 $1$ 的時間。<br/><br>當迷宮內兩個傳送門時，你可以遠端的毀掉其中一個傳送門，此時你就可以再發射新的傳送門，毀掉一個傳送門不花費時間，發射傳送門也是。<br>求從出生點到終點最少需要多少時間。</p>
<hr>
<h1 id="Subtask-1-2-31-points-R-C-le-50"><a href="#Subtask-1-2-31-points-R-C-le-50" class="headerlink" title="Subtask 1, 2 (31 points): $R, C\le 50$"></a>Subtask 1, 2 (31 points): $R, C\le 50$</h1><p>首先發現到：</p>
<blockquote>
<p>當你穿梭過一個傳送門時，你可以直接毀掉那兩個傳送門。</p>
</blockquote>
<p>假設你從傳送門 $A$ 到傳送門 $B$，你不可能再利用 $A$ 的傳送門，否則你一開始就不用傳送到 $B$。<br/><br>當你之後還要利用 $B$ 的傳送門，可以當成再發射一個傳送門到 $B$ 的位置，因為發射傳送門不花費時間，所以這樣是等價的。<br/></p>
<p>接下來再觀察一下，可以發現：</p>
<blockquote>
<p>當你發射了第二個傳送門，你就要直接走到傳送門前傳送過去。</p>
</blockquote>
<p>因為你不可能發射了第二個傳送門後到處亂晃再去搭傳送門(?)，而且：</p>
<blockquote>
<p>你可以總是利用第二個傳送門到第一個傳送門。</p>
</blockquote>
<p>因為如果你要搭第一個傳送門，那你肯定是去發射第二之後再回來搭第一個，這可以等價成先去射第二個再回來射第一個門。再來：</p>
<blockquote>
<p>發射第二個傳送門後走過去，等價成先走過去然後發射第二個傳送門</p>
</blockquote>
<p>所以你的策略一定是先發射第一個傳送門，晃一晃晃到了牆邊後原地發射第二個門，接著直接傳送過去第一個門。</p>
<p>因此你只要去紀錄第一個門的位置。<br>所以可以用以下狀態跑 <code>BFS</code> 最短路：<br>$$dis[x][y][a][b]\ := \text{ 人在 } (x, y)\text{ ，且第一個傳送門在 } (a, b)\text {的最短距離} $$</p>
<p>當 $(a, b) = (0, 0)$ 的時候代表場上沒有傳送門。<br/><br>而你下一步可以走到上下左右，或者是往上下左右發射傳送門，或者當你在牆邊的時候可以傳送到第一個傳送門所在的位置並且毀掉那兩個傳送門。</p>
<p>但是要怎麼知道上下左右的第一個牆邊在哪裡？<br>可以預處理 <code>dw</code>, <code>up</code>, <code>le</code>, <code>ri</code> 代表下、上、左、右的第一個牆邊在哪裡。<br>轉移式為（這裡只列出 <code>up</code>，其餘可參考 code）。<br>$$ up[i][j] = \begin{cases} i &amp; \text{if } arr[i - 1][j]\text{ is wall} \\ up[i-1][j] &amp; \text{else} \end{cases}$$</p>
<p>預處理完你就能 $\mathcal{O}(1)$ 知道你下一步的位置了。<br/></p>
<p>因為發射傳送門不用花費時間，所以這其實就是權重 0 跟 1 的最短路問題。<br>通用解法就是 <code>0/1 BFS</code>，作法是設個 <code>deque</code>，在走權重為 0 的邊時 <code>push_front</code>，否則 <code>push_back</code>，每次從 <code>front</code> 拿當前要走的點。<br>總時間複雜度 $\mathcal{O}((RC)^2)$。<br/></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 31/100</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EmiliaMyWife ios::sync_with_stdio(0); cin.tie(0);</span></span><br><span class="line"><span class="keyword">using</span> ll = <span class="keyword">int64_t</span>;</span><br><span class="line"><span class="keyword">using</span> ull = <span class="keyword">uint64_t</span>;</span><br><span class="line"><span class="keyword">using</span> uint = <span class="keyword">uint32_t</span>;</span><br><span class="line"><span class="keyword">using</span> ld = <span class="keyword">long</span> <span class="keyword">double</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MOD = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> EPS = <span class="number">1e-8</span>;</span><br><span class="line"><span class="keyword">const</span> ll LINF = <span class="built_in">ll</span>(<span class="number">2e18</span>) + <span class="built_in">ll</span>(<span class="number">1e15</span>);</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">auto</span> LamyIsCute = []() &#123;</span><br><span class="line">	EmiliaMyWife</span><br><span class="line">	<span class="keyword">return</span> <span class="number">48763</span>;</span><br><span class="line">&#125;();</span><br><span class="line"> </span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">51</span>;</span><br><span class="line"><span class="keyword">int</span> dis[N][N][N][N], up[N][N], dw[N][N], le[N][N], ri[N][N];</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> dx[] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>&#125;, dy[] = &#123;<span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>, <span class="number">0</span>&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n, m;</span><br><span class="line">	cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">	<span class="function">vector&lt;string&gt; <span class="title">arr</span><span class="params">(n + <span class="number">2</span>)</span></span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">		cin &gt;&gt; arr[i];</span><br><span class="line">		arr[i] = <span class="string">&#x27;#&#x27;</span> + arr[i];</span><br><span class="line">		arr[i].<span class="built_in">push_back</span>(<span class="string">&#x27;#&#x27;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	arr[<span class="number">0</span>] = arr[n + <span class="number">1</span>] = <span class="built_in">string</span>(m + <span class="number">2</span>, <span class="string">&#x27;#&#x27;</span>);</span><br><span class="line"> </span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; j++) &#123;</span><br><span class="line">			<span class="keyword">if</span>(arr[i][j] != <span class="string">&#x27;#&#x27;</span>) &#123;</span><br><span class="line">				<span class="keyword">if</span>(arr[i][j - <span class="number">1</span>] == <span class="string">&#x27;#&#x27;</span>)</span><br><span class="line">					le[i][j] = j;</span><br><span class="line">				<span class="keyword">else</span></span><br><span class="line">					le[i][j] = le[i][j - <span class="number">1</span>];</span><br><span class="line">				<span class="keyword">if</span>(arr[i - <span class="number">1</span>][j] == <span class="string">&#x27;#&#x27;</span>)</span><br><span class="line">					up[i][j] = i;</span><br><span class="line">				<span class="keyword">else</span></span><br><span class="line">					up[i][j] = up[i - <span class="number">1</span>][j];</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = n; i; i--) &#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j = m; j; j--) &#123;</span><br><span class="line">			<span class="keyword">if</span>(arr[i][j] != <span class="string">&#x27;#&#x27;</span>) &#123;</span><br><span class="line">				<span class="keyword">if</span>(arr[i][j + <span class="number">1</span>] == <span class="string">&#x27;#&#x27;</span>)</span><br><span class="line">					ri[i][j] = j;</span><br><span class="line">				<span class="keyword">else</span></span><br><span class="line">					ri[i][j] = ri[i][j + <span class="number">1</span>];</span><br><span class="line">				<span class="keyword">if</span>(arr[i + <span class="number">1</span>][j] == <span class="string">&#x27;#&#x27;</span>)</span><br><span class="line">					dw[i][j] = i;</span><br><span class="line">				<span class="keyword">else</span></span><br><span class="line">					dw[i][j] = dw[i + <span class="number">1</span>][j];</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	<span class="built_in">memset</span>(dis, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> dis);</span><br><span class="line"> </span><br><span class="line">	deque&lt;tuple&lt;<span class="keyword">int</span>, <span class="keyword">int</span>, <span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; bfs;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; j++) &#123;</span><br><span class="line">			<span class="keyword">if</span>(arr[i][j] == <span class="string">&#x27;S&#x27;</span>) &#123;</span><br><span class="line">				bfs.<span class="built_in">push_back</span>(&#123;i, j, <span class="number">0</span>, <span class="number">0</span>&#125;);</span><br><span class="line">				dis[i][j][<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span>(!bfs.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">		<span class="keyword">auto</span> [x, y, a, b] = bfs.<span class="built_in">front</span>();</span><br><span class="line">		bfs.<span class="built_in">pop_front</span>();</span><br><span class="line"> </span><br><span class="line">		<span class="keyword">if</span>(dis[x][y][x][le[x][y]] &gt; dis[x][y][a][b]) &#123;</span><br><span class="line">			dis[x][y][x][le[x][y]] = dis[x][y][a][b];</span><br><span class="line">			bfs.<span class="built_in">push_front</span>(&#123;x, y, x, le[x][y]&#125;);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(dis[x][y][x][ri[x][y]] &gt; dis[x][y][a][b]) &#123;</span><br><span class="line">			dis[x][y][x][ri[x][y]] = dis[x][y][a][b];</span><br><span class="line">			bfs.<span class="built_in">push_front</span>(&#123;x, y, x, ri[x][y]&#125;);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(dis[x][y][up[x][y]][y] &gt; dis[x][y][a][b]) &#123;</span><br><span class="line">			dis[x][y][up[x][y]][y] = dis[x][y][a][b];</span><br><span class="line">			bfs.<span class="built_in">push_front</span>(&#123;x, y, up[x][y], y&#125;);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(dis[x][y][dw[x][y]][y] &gt; dis[x][y][a][b]) &#123;</span><br><span class="line">			dis[x][y][dw[x][y]][y] = dis[x][y][a][b];</span><br><span class="line">			bfs.<span class="built_in">push_front</span>(&#123;x, y, dw[x][y], y&#125;);</span><br><span class="line">		&#125;</span><br><span class="line"> </span><br><span class="line">		<span class="keyword">bool</span> ok = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">			<span class="keyword">int</span> tx = x + dx[i], ty = y + dy[i];</span><br><span class="line">			<span class="keyword">if</span>(arr[tx][ty] == <span class="string">&#x27;#&#x27;</span>)</span><br><span class="line">				ok = <span class="literal">true</span>;</span><br><span class="line">			<span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="keyword">if</span>(dis[tx][ty][a][b] &gt; dis[x][y][a][b] + <span class="number">1</span>) &#123;</span><br><span class="line">					dis[tx][ty][a][b] = dis[x][y][a][b] + <span class="number">1</span>;</span><br><span class="line">					bfs.<span class="built_in">push_back</span>(&#123;tx, ty, a, b&#125;);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"> </span><br><span class="line">		<span class="keyword">if</span>(ok &amp;&amp; arr[a][b] != <span class="string">&#x27;#&#x27;</span> &amp;&amp; dis[a][b][<span class="number">0</span>][<span class="number">0</span>] &gt; dis[x][y][a][b] + <span class="number">1</span>) &#123;</span><br><span class="line">			dis[a][b][<span class="number">0</span>][<span class="number">0</span>] = dis[x][y][a][b] + <span class="number">1</span>;</span><br><span class="line">			bfs.<span class="built_in">push_back</span>(&#123;a, b, <span class="number">0</span>, <span class="number">0</span>&#125;);</span><br><span class="line">		&#125;</span><br><span class="line"> </span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> ans = INF;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; j++) &#123;</span><br><span class="line">			<span class="keyword">if</span>(arr[i][j] == <span class="string">&#x27;C&#x27;</span>) &#123;</span><br><span class="line">				<span class="keyword">for</span>(<span class="keyword">int</span> a = <span class="number">1</span>; a &lt;= n; a++)</span><br><span class="line">					<span class="keyword">for</span>(<span class="keyword">int</span> b = <span class="number">1</span>; b &lt;= m; b++)</span><br><span class="line">						ans = <span class="built_in">min</span>(ans, dis[i][j][a][b]);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; ans &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Subtask-3-20-points-R-C-le-200-，每個-周圍都有至少一個-。"><a href="#Subtask-3-20-points-R-C-le-200-，每個-周圍都有至少一個-。" class="headerlink" title="Subtask 3 (20 points): $R, C\le 200$，每個 . 周圍都有至少一個 #。"></a>Subtask 3 (20 points): $R, C\le 200$，每個 <code>.</code> 周圍都有至少一個 <code>#</code>。</h1><p>在這個子題中保證了你隨時能夠發射第二個傳送門並傳送到第一個傳送門（因為你隨時都在牆邊），並且注意到：</p>
<blockquote>
<p>在發射第一個傳送門之後應該要立刻原地發射第二個傳送門傳送過去。</p>
</blockquote>
<p>因為你亂晃亂晃然後才發射第二個走過去肯定不會比較好(?)<br>所以甚至不用紀錄第一個傳送門了，直接用 <code>dis[x][y]</code> 代表到那個位置的最短路，同時你可以做的事情有：</p>
<ol>
<li>走到上下左右</li>
<li>往上下左右發射一個傳送門，同時原地弄個傳送門傳送過去</li>
</ol>
<p>有了在上個子題的預處理，這些事情都能繼續 $\mathcal{O}(1)$ 做到。<br/><br>時間複雜度 $\mathcal{O}(RC)$。<br/><br>跟上個子題的作法聯集起來你就有了 51 分。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 51/100</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EmiliaMyWife ios::sync_with_stdio(0); cin.tie(0);</span></span><br><span class="line"><span class="keyword">using</span> ll = <span class="keyword">int64_t</span>;</span><br><span class="line"><span class="keyword">using</span> ull = <span class="keyword">uint64_t</span>;</span><br><span class="line"><span class="keyword">using</span> uint = <span class="keyword">uint32_t</span>;</span><br><span class="line"><span class="keyword">using</span> ld = <span class="keyword">long</span> <span class="keyword">double</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MOD = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> EPS = <span class="number">1e-8</span>;</span><br><span class="line"><span class="keyword">const</span> ll LINF = <span class="built_in">ll</span>(<span class="number">2e18</span>) + <span class="built_in">ll</span>(<span class="number">1e15</span>);</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">auto</span> LamyIsCute = []() &#123;</span><br><span class="line">	EmiliaMyWife</span><br><span class="line">	<span class="keyword">return</span> <span class="number">48763</span>;</span><br><span class="line">&#125;();</span><br><span class="line"> </span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">51</span>, N2 = <span class="number">501</span>;</span><br><span class="line"><span class="keyword">int</span> dis[N][N][N][N], up[N2][N2], dw[N2][N2], le[N2][N2], ri[N2][N2];</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> dx[] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>&#125;, dy[] = &#123;<span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>, <span class="number">0</span>&#125;;</span><br><span class="line">vector&lt;string&gt; arr;</span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">ans</span>(n + <span class="number">1</span>, vector&lt;<span class="keyword">int</span>&gt;(m + <span class="number">1</span>, INF));</span><br><span class="line">	queue&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; bfs;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) </span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; j++)</span><br><span class="line">			<span class="keyword">if</span>(arr[i][j] == <span class="string">&#x27;S&#x27;</span>)</span><br><span class="line">				ans[i][j] = <span class="number">0</span>, bfs.<span class="built_in">push</span>(&#123;i, j&#125;);</span><br><span class="line">	<span class="keyword">while</span>(!bfs.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">		<span class="keyword">auto</span> [x, y] = bfs.<span class="built_in">front</span>();</span><br><span class="line">		bfs.<span class="built_in">pop</span>();</span><br><span class="line"> </span><br><span class="line">		<span class="keyword">auto</span> w = ans[x][y] + <span class="number">1</span>;</span><br><span class="line"> </span><br><span class="line">		<span class="keyword">if</span>(ans[x][le[x][y]] &gt; w) &#123;</span><br><span class="line">			ans[x][le[x][y]] = w;</span><br><span class="line">			bfs.<span class="built_in">push</span>(&#123;x, le[x][y]&#125;);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(ans[x][ri[x][y]] &gt; w) &#123;</span><br><span class="line">			ans[x][ri[x][y]] = w;</span><br><span class="line">			bfs.<span class="built_in">push</span>(&#123;x, ri[x][y]&#125;);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(ans[up[x][y]][y] &gt; w) &#123;</span><br><span class="line">			ans[up[x][y]][y] = w;</span><br><span class="line">			bfs.<span class="built_in">push</span>(&#123;up[x][y], y&#125;);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(ans[dw[x][y]][y] &gt; w) &#123;</span><br><span class="line">			ans[dw[x][y]][y] = w;</span><br><span class="line">			bfs.<span class="built_in">push</span>(&#123;dw[x][y], y&#125;);</span><br><span class="line">		&#125;</span><br><span class="line"> </span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">			<span class="keyword">int</span> tx = x + dx[i], ty = y + dy[i];</span><br><span class="line">			<span class="keyword">if</span>(arr[tx][ty] == <span class="string">&#x27;#&#x27;</span>)</span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">			<span class="keyword">if</span>(ans[tx][ty] &gt; ans[x][y] + <span class="number">1</span>) &#123;</span><br><span class="line">				ans[tx][ty] = ans[x][y] + <span class="number">1</span>;</span><br><span class="line">				bfs.<span class="built_in">push</span>(&#123;tx, ty&#125;);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; j++)</span><br><span class="line">			<span class="keyword">if</span>(arr[i][j] == <span class="string">&#x27;C&#x27;</span>)</span><br><span class="line">				cout &lt;&lt; ans[i][j] &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">	arr.<span class="built_in">resize</span>(n + <span class="number">2</span>);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">		cin &gt;&gt; arr[i];</span><br><span class="line">		arr[i] = <span class="string">&#x27;#&#x27;</span> + arr[i];</span><br><span class="line">		arr[i].<span class="built_in">push_back</span>(<span class="string">&#x27;#&#x27;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	arr[<span class="number">0</span>] = arr[n + <span class="number">1</span>] = <span class="built_in">string</span>(m + <span class="number">2</span>, <span class="string">&#x27;#&#x27;</span>);</span><br><span class="line"> </span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; j++) &#123;</span><br><span class="line">			<span class="keyword">if</span>(arr[i][j] != <span class="string">&#x27;#&#x27;</span>) &#123;</span><br><span class="line">				<span class="keyword">if</span>(arr[i][j - <span class="number">1</span>] == <span class="string">&#x27;#&#x27;</span>)</span><br><span class="line">					le[i][j] = j;</span><br><span class="line">				<span class="keyword">else</span></span><br><span class="line">					le[i][j] = le[i][j - <span class="number">1</span>];</span><br><span class="line">				<span class="keyword">if</span>(arr[i - <span class="number">1</span>][j] == <span class="string">&#x27;#&#x27;</span>)</span><br><span class="line">					up[i][j] = i;</span><br><span class="line">				<span class="keyword">else</span></span><br><span class="line">					up[i][j] = up[i - <span class="number">1</span>][j];</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = n; i; i--) &#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j = m; j; j--) &#123;</span><br><span class="line">			<span class="keyword">if</span>(arr[i][j] != <span class="string">&#x27;#&#x27;</span>) &#123;</span><br><span class="line">				<span class="keyword">if</span>(arr[i][j + <span class="number">1</span>] == <span class="string">&#x27;#&#x27;</span>)</span><br><span class="line">					ri[i][j] = j;</span><br><span class="line">				<span class="keyword">else</span></span><br><span class="line">					ri[i][j] = ri[i][j + <span class="number">1</span>];</span><br><span class="line">				<span class="keyword">if</span>(arr[i + <span class="number">1</span>][j] == <span class="string">&#x27;#&#x27;</span>)</span><br><span class="line">					dw[i][j] = i;</span><br><span class="line">				<span class="keyword">else</span></span><br><span class="line">					dw[i][j] = dw[i + <span class="number">1</span>][j];</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(n &gt; <span class="number">50</span> || m &gt; <span class="number">50</span>) &#123;</span><br><span class="line">		<span class="built_in">solve</span>();</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	<span class="built_in">memset</span>(dis, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> dis);</span><br><span class="line"> </span><br><span class="line">	deque&lt;tuple&lt;<span class="keyword">int</span>, <span class="keyword">int</span>, <span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; bfs;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; j++) &#123;</span><br><span class="line">			<span class="keyword">if</span>(arr[i][j] == <span class="string">&#x27;S&#x27;</span>) &#123;</span><br><span class="line">				bfs.<span class="built_in">push_back</span>(&#123;i, j, <span class="number">0</span>, <span class="number">0</span>&#125;);</span><br><span class="line">				dis[i][j][<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span>(!bfs.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">		<span class="keyword">auto</span> [x, y, a, b] = bfs.<span class="built_in">front</span>();</span><br><span class="line">		bfs.<span class="built_in">pop_front</span>();</span><br><span class="line">		<span class="keyword">if</span>(arr[x][y] == <span class="string">&#x27;C&#x27;</span>)</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line"> </span><br><span class="line">		<span class="keyword">if</span>(dis[x][y][x][le[x][y]] &gt; dis[x][y][a][b]) &#123;</span><br><span class="line">			dis[x][y][x][le[x][y]] = dis[x][y][a][b];</span><br><span class="line">			bfs.<span class="built_in">push_front</span>(&#123;x, y, x, le[x][y]&#125;);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(dis[x][y][x][ri[x][y]] &gt; dis[x][y][a][b]) &#123;</span><br><span class="line">			dis[x][y][x][ri[x][y]] = dis[x][y][a][b];</span><br><span class="line">			bfs.<span class="built_in">push_front</span>(&#123;x, y, x, ri[x][y]&#125;);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(dis[x][y][up[x][y]][y] &gt; dis[x][y][a][b]) &#123;</span><br><span class="line">			dis[x][y][up[x][y]][y] = dis[x][y][a][b];</span><br><span class="line">			bfs.<span class="built_in">push_front</span>(&#123;x, y, up[x][y], y&#125;);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(dis[x][y][dw[x][y]][y] &gt; dis[x][y][a][b]) &#123;</span><br><span class="line">			dis[x][y][dw[x][y]][y] = dis[x][y][a][b];</span><br><span class="line">			bfs.<span class="built_in">push_front</span>(&#123;x, y, dw[x][y], y&#125;);</span><br><span class="line">		&#125;</span><br><span class="line"> </span><br><span class="line">		<span class="keyword">bool</span> ok = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">			<span class="keyword">int</span> tx = x + dx[i], ty = y + dy[i];</span><br><span class="line">			<span class="keyword">if</span>(arr[tx][ty] == <span class="string">&#x27;#&#x27;</span>)</span><br><span class="line">				ok = <span class="literal">true</span>;</span><br><span class="line">			<span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="keyword">if</span>(dis[tx][ty][a][b] &gt; dis[x][y][a][b] + <span class="number">1</span>) &#123;</span><br><span class="line">					dis[tx][ty][a][b] = dis[x][y][a][b] + <span class="number">1</span>;</span><br><span class="line">					bfs.<span class="built_in">push_back</span>(&#123;tx, ty, a, b&#125;);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"> </span><br><span class="line">		<span class="keyword">if</span>(ok &amp;&amp; arr[a][b] != <span class="string">&#x27;#&#x27;</span> &amp;&amp; dis[a][b][<span class="number">0</span>][<span class="number">0</span>] &gt; dis[x][y][a][b] + <span class="number">1</span>) &#123;</span><br><span class="line">			dis[a][b][<span class="number">0</span>][<span class="number">0</span>] = dis[x][y][a][b] + <span class="number">1</span>;</span><br><span class="line">			bfs.<span class="built_in">push_back</span>(&#123;a, b, <span class="number">0</span>, <span class="number">0</span>&#125;);</span><br><span class="line">		&#125;</span><br><span class="line"> </span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> ans = INF;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; j++) &#123;</span><br><span class="line">			<span class="keyword">if</span>(arr[i][j] == <span class="string">&#x27;C&#x27;</span>) &#123;</span><br><span class="line">				<span class="keyword">for</span>(<span class="keyword">int</span> a = <span class="number">0</span>; a &lt;= n; a++)</span><br><span class="line">					<span class="keyword">for</span>(<span class="keyword">int</span> b = <span class="number">0</span>; b &lt;= m; b++)</span><br><span class="line">						ans = <span class="built_in">min</span>(ans, dis[i][j][a][b]);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; ans &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Subtask-4-5-49-Points-R-C-le-1000"><a href="#Subtask-4-5-49-Points-R-C-le-1000" class="headerlink" title="Subtask 4, 5 (49 Points): $R, C\le 1000$"></a>Subtask 4, 5 (49 Points): $R, C\le 1000$</h1><p>上個子題的作法在這子題會 WA 掉，為什麼？<br>因為上個子題中我們可以直接在射了第一個傳送門之後，原地發射第二個並且傳送過去。<br>然而這個子題並沒有保證所有點都是牆邊。<br>不過上個子題有個觀察：</p>
<blockquote>
<p>在發射第一個傳送門之後應該要立刻原地發射第二個傳送門傳送過去。 </p>
</blockquote>
<p>上個子題可以原地發射第二個，那在這個子題呢？</p>
<blockquote>
<p>在發射第一個傳送門之後應該盡可能快的走到牆邊，並且發射第二個傳送門傳送過去。 </p>
</blockquote>
<p>上個子題的觀察其實就是這個的特例，因為我們總是在牆邊所以不用想辦法進可能快的走到牆邊。</p>
<p>重新令 <code>dis[x][y]</code> 代表到那點的最短距離，現在我們能做的事情變成：</p>
<ol>
<li>花費 $1$ 的時間走到上下左右</li>
<li>花費 $1$ 的時間射一個傳送門到上下左右第一個牆邊，並且花費 $mn[x][y]$ 的時間走到牆邊射第二個傳送門傳送過去。</li>
</ol>
<p>現在的問題就是如何計算 <code>mn</code>？<br>其實 <code>mn[x][y]</code> 就是離 $(x, y)$ 最近的牆邊有多遠！<br/><br>所以這就是多點源 <code>BFS</code>，起點是所有牆邊。<br>這樣就能花 $\mathcal{O}(RC)$ 預處理 <code>mn</code>。<br/></p>
<p>我們要做的事情變成帶權的最短路了，所以就要使用 <code>Dijkstra</code> 演算法。<br>於是整體複雜度是 $\mathcal{O}(RClog(RC))$，並且滿分入手&gt;&lt;。<br/></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 100/100</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EmiliaMyWife ios::sync_with_stdio(0); cin.tie(0);</span></span><br><span class="line"><span class="keyword">using</span> ll = <span class="keyword">int64_t</span>;</span><br><span class="line"><span class="keyword">using</span> ull = <span class="keyword">uint64_t</span>;</span><br><span class="line"><span class="keyword">using</span> uint = <span class="keyword">uint32_t</span>;</span><br><span class="line"><span class="keyword">using</span> ld = <span class="keyword">long</span> <span class="keyword">double</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MOD = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> EPS = <span class="number">1e-8</span>;</span><br><span class="line"><span class="keyword">const</span> ll LINF = <span class="built_in">ll</span>(<span class="number">2e18</span>) + <span class="built_in">ll</span>(<span class="number">1e15</span>);</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">auto</span> LamyIsCute = []() &#123;</span><br><span class="line">	EmiliaMyWife</span><br><span class="line">	<span class="keyword">return</span> <span class="number">48763</span>;</span><br><span class="line">&#125;();</span><br><span class="line"> </span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1001</span>;</span><br><span class="line"><span class="keyword">int</span> dis[N][N], up[N][N], dw[N][N], le[N][N], ri[N][N], mn[N][N];</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> dx[] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>&#125;, dy[] = &#123;<span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>, <span class="number">0</span>&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n, m;</span><br><span class="line">	cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">	<span class="function">vector&lt;string&gt; <span class="title">arr</span><span class="params">(n + <span class="number">2</span>)</span></span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">		cin &gt;&gt; arr[i];</span><br><span class="line">		arr[i] = <span class="string">&#x27;#&#x27;</span> + arr[i];</span><br><span class="line">		arr[i].<span class="built_in">push_back</span>(<span class="string">&#x27;#&#x27;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	arr[<span class="number">0</span>] = arr[n + <span class="number">1</span>] = <span class="built_in">string</span>(m + <span class="number">2</span>, <span class="string">&#x27;#&#x27;</span>);</span><br><span class="line"> </span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; j++) &#123;</span><br><span class="line">			<span class="keyword">if</span>(arr[i][j] != <span class="string">&#x27;#&#x27;</span>) &#123;</span><br><span class="line">				<span class="keyword">if</span>(arr[i][j - <span class="number">1</span>] == <span class="string">&#x27;#&#x27;</span>)</span><br><span class="line">					le[i][j] = j;</span><br><span class="line">				<span class="keyword">else</span></span><br><span class="line">					le[i][j] = le[i][j - <span class="number">1</span>];</span><br><span class="line">				<span class="keyword">if</span>(arr[i - <span class="number">1</span>][j] == <span class="string">&#x27;#&#x27;</span>)</span><br><span class="line">					up[i][j] = i;</span><br><span class="line">				<span class="keyword">else</span></span><br><span class="line">					up[i][j] = up[i - <span class="number">1</span>][j];</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = n; i; i--) &#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j = m; j; j--) &#123;</span><br><span class="line">			<span class="keyword">if</span>(arr[i][j] != <span class="string">&#x27;#&#x27;</span>) &#123;</span><br><span class="line">				<span class="keyword">if</span>(arr[i][j + <span class="number">1</span>] == <span class="string">&#x27;#&#x27;</span>)</span><br><span class="line">					ri[i][j] = j;</span><br><span class="line">				<span class="keyword">else</span></span><br><span class="line">					ri[i][j] = ri[i][j + <span class="number">1</span>];</span><br><span class="line">				<span class="keyword">if</span>(arr[i + <span class="number">1</span>][j] == <span class="string">&#x27;#&#x27;</span>)</span><br><span class="line">					dw[i][j] = i;</span><br><span class="line">				<span class="keyword">else</span></span><br><span class="line">					dw[i][j] = dw[i + <span class="number">1</span>][j];</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">memset</span>(mn, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> mn);</span><br><span class="line">		queue&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; bfs;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; j++)</span><br><span class="line">				<span class="keyword">if</span>(le[i][j] == j || ri[i][j] == j || up[i][j] == i || dw[i][j] == i)</span><br><span class="line">					mn[i][j] = <span class="number">0</span>, bfs.<span class="built_in">push</span>(&#123;i, j&#125;);</span><br><span class="line">		<span class="keyword">while</span>(!bfs.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">			<span class="keyword">auto</span> [a, b] = bfs.<span class="built_in">front</span>();</span><br><span class="line">			bfs.<span class="built_in">pop</span>();</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">				<span class="keyword">int</span> x = a + dx[i], y = b + dy[i];</span><br><span class="line">				<span class="keyword">if</span>(arr[x][y] != <span class="string">&#x27;#&#x27;</span> &amp;&amp; mn[x][y] &gt; mn[a][b] + <span class="number">1</span>) &#123;</span><br><span class="line">					mn[x][y] = mn[a][b] + <span class="number">1</span>;</span><br><span class="line">					bfs.<span class="built_in">push</span>(&#123;x, y&#125;);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	<span class="built_in">memset</span>(dis, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> dis);</span><br><span class="line"> </span><br><span class="line">	priority_queue&lt;tuple&lt;<span class="keyword">int</span>, <span class="keyword">int</span>, <span class="keyword">int</span>&gt;, vector&lt;tuple&lt;<span class="keyword">int</span>, <span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt;, greater&lt;tuple&lt;<span class="keyword">int</span>, <span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt;&gt; bfs;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; j++) &#123;</span><br><span class="line">			<span class="keyword">if</span>(arr[i][j] == <span class="string">&#x27;S&#x27;</span>) &#123;</span><br><span class="line">				bfs.<span class="built_in">push</span>(&#123;<span class="number">0</span>, i, j&#125;);</span><br><span class="line">				dis[i][j] = <span class="number">0</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span>(!bfs.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">		<span class="keyword">auto</span> [d, x, y] = bfs.<span class="built_in">top</span>();</span><br><span class="line">		bfs.<span class="built_in">pop</span>();</span><br><span class="line">		<span class="keyword">if</span>(dis[x][y] &gt; d)</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		<span class="keyword">if</span>(arr[x][y] == <span class="string">&#x27;C&#x27;</span>) &#123;</span><br><span class="line">			cout &lt;&lt; d &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line"> </span><br><span class="line">		<span class="keyword">int</span> g = dis[x][y] + mn[x][y] + <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">if</span>(dis[x][le[x][y]] &gt; g) &#123;</span><br><span class="line">			dis[x][le[x][y]] = g;</span><br><span class="line">			bfs.<span class="built_in">push</span>(&#123;g, x, le[x][y]&#125;);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(dis[x][ri[x][y]] &gt; g) &#123;</span><br><span class="line">			dis[x][ri[x][y]] = g;</span><br><span class="line">			bfs.<span class="built_in">push</span>(&#123;g, x, ri[x][y]&#125;);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(dis[up[x][y]][y] &gt; g) &#123;</span><br><span class="line">			dis[up[x][y]][y] = g;</span><br><span class="line">			bfs.<span class="built_in">push</span>(&#123;g, up[x][y], y&#125;);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(dis[dw[x][y]][y] &gt; g) &#123;</span><br><span class="line">			dis[dw[x][y]][y] = g;</span><br><span class="line">			bfs.<span class="built_in">push</span>(&#123;g, dw[x][y], y&#125;);</span><br><span class="line">		&#125;</span><br><span class="line"> </span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">			<span class="keyword">int</span> tx = x + dx[i], ty = y + dy[i];</span><br><span class="line">			<span class="keyword">if</span>(arr[tx][ty] != <span class="string">&#x27;#&#x27;</span>) &#123;</span><br><span class="line">				<span class="keyword">if</span>(dis[tx][ty] &gt; dis[x][y] + <span class="number">1</span>) &#123;</span><br><span class="line">					dis[tx][ty] = dis[x][y] + <span class="number">1</span>;</span><br><span class="line">					bfs.<span class="built_in">push</span>(&#123;dis[tx][ty], tx, ty&#125;);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="結語"><a href="#結語" class="headerlink" title="結語"></a>結語</h1><p>這題是我在 Virtual 時解出來的題目，但是我花了兩個小時才寫出來ww<br>其中花最久的時間就是想到只需要紀錄第一個傳送的位置，以及最後把子題 3 的觀察轉化成滿分解能夠使用的觀察。<br>這題充滿著各種經典的技巧與演算法，<code>多點源 BFS</code>、<code>Dijkstra</code>、計算上下左右時的 <code>DP</code>、<code>0/1 BFS</code>，以及滿滿的觀察！！<br>實作的部份看似很多，但其實沒有到很煩躁，畢竟要做的事情就是很清楚。</p>
]]></content>
      <tags>
        <tag>greedy</tag>
        <tag>dijkstra</tag>
        <tag>Competitve Programming</tag>
        <tag>BOI</tag>
      </tags>
  </entry>
  <entry>
    <title>2021-NHSPC</title>
    <url>/2021-NHSPC/</url>
    <content><![CDATA[<p>最後一次的全國賽。<br>去年四等一連三等獎都沒有真的讓我很挫折，我很害怕今年又發生相同的事，所以最大目標就是拿到三等獎以上。</p>
<span id="more"></span>
<h1 id="賽前"><a href="#賽前" class="headerlink" title="賽前"></a>賽前</h1><p>今年從師大改到了清大舉辦，可是多了一堆超怪的規定，比如說不能帶自己文具只能使用他們給原子筆跟紙，所以當你想用尺劃線或者想用立可帶把你寫錯的東西修改一下都沒辦法。<br>而且不能吃自己的食物，所以賽前買的一堆巧克力通通都沒辦法吃，如果是去年全國賽或者是像選訓內，外面有一堆東西可以吃就算了，清大這邊給的食物就只有豆乾跟麵包之類的，五個小時的比賽連個能夠快速補充血糖的東西都沒有= =;</p>
<h1 id="第一小時"><a href="#第一小時" class="headerlink" title="第一小時"></a>第一小時</h1><p>開場先遵循策略，把 vimrc 跟 defaut code 打完，然後就把題目全部看過一次。<br>題本超級無敵厚，有 9 題，而且每一題都佔好幾頁。<br>光讀完全部題目就花了 40 分鐘，而且後來才發現到這麼多題目的比賽不該一次把題目看完，因為看到後面發現時間過去很多就會變得很煩躁，導致後面的水題也沒有馬上發現。</p>
<p>總之看完後就直接先把 pA 翻綠。<br><em><strong>pA AC 0:45:46</strong></em></p>
<p>然後看了 pB，發現可以直接點到點距離配上點到直線的距離公式。點到直線的距離公式只要先法向量把方程式弄出來就好了，可是問題來了，點到直線的距離公式到底長怎樣…<br>記憶中他的長相就是 $\frac{|\cdots|}{\sqrt{\text{某些東西的平方和}}}$，因為手上的參數就只有 $ax+by+c=0$ 的 $a,b,c$ 已經點 $(x,y)$ 的 $x,y$，所以開始到處亂推，最後推出一個稍微手算一些測資都正確的算式就拿來用了。<br/></p>
<h1 id="第二小時"><a href="#第二小時" class="headerlink" title="第二小時"></a>第二小時</h1><p>然後發現範測還是錯，才發現要判斷垂點不在線段上，印象中肯定是簡單計幾，可是我還是想了好久才想到可以兩次內積= =;<br><em><strong>pB AC 1:12:20</strong></em></p>
<p>接下來就照著看 pC，但是想了大概半個小時還是沒什麼想法，後來覺得這題應該蠻難的所以就跳過了。<br>看了 pD 覺得應該可以二分搜，可是二分搜完變成一堆有向圖的連通塊還是不會構造，後來突然想到會不會只要有拓樸就能構造，有了這個假設就想到直接照著拓樸序就可以了。</p>
<h1 id="第三小時"><a href="#第三小時" class="headerlink" title="第三小時"></a>第三小時</h1><p>實作出了不少 bug，但還不算太糟。<br><em><strong>pD 14/100 TLE 2:01:29</strong></em><br>檢查了自己的 code 覺得沒什麼錯誤，所以覺得是被卡常了，改成不要每次蓋新圖，直接在同張圖上遍歷再慢慢檢查邊權。<br><em><strong>pD 6/100 TLE 2:07:45</strong></em><br>因為連 8 分子題都沒拿到了，所以就確定是卡常。<br>那就把邊權給 sort 然後就能適時的 break。<br><em><strong>pD 14/100 TLE 2:12:40</strong></em><br>常數應該比一開始每次二分搜都建圖建圖還小，可是還是沒過。<br>這個時候在想要不要先丟掉這題了，畢竟也在這題花了快半個小時，只是這題 86 分實在是太肥了，讓我很不想放掉他。<br>再想一下想到把邊權離散化再二分搜，這樣二分搜的複雜度可以從 $\mathcal{O}(\log C)$ 變成 $\mathcal{O}(\log N)$。</br><br><em><strong>pD AC 2:23:19</strong></em><br>到這邊心態已經有點小炸了，因為比賽快過半分數只有這樣，不過我先相信今年題目很難來穩住心態。</p>
<p>上個廁所回來後，因為 E,F 的題目真的好難理解，所以先再仔細的看過 G。<br>結果發現他是樹壓平裸題@@，為什麼我第一輪沒發現這件事。<br><em><strong>pG AC 2:47:11</strong></em><br>然後很好笑的一件事發生了，我在測範測的時候發現我怎麼輸入一筆詢問他就輸出了，後來我才發現我的 defaut code 沒有把 IO 優化叫出來@@<br>會不會 pD 是因為 IO 被卡常？但我已經懶得回頭測了</p>
<p>之後決定先往後面看，H 先寫個爆搜解來用。<br><em><strong>pH 15/100 2:53:09</strong></em><br>之後花一段時間想了一個構造法，然後寫完後拿來跟爆搜解對對看<br><em><strong>pH 40/100 2:58:35</strong></em></p>
<h1 id="第四小時"><a href="#第四小時" class="headerlink" title="第四小時"></a>第四小時</h1><p>嘗試唬爛一下第三子題<br><em><strong>pH 40/100 3:00:58</strong></em><br>又 claim 說肯定是拔前後綴會最優，不過寫起來頗囉唆的。<br><em><strong>pH 40/100 3:21:51</strong></em><br>大概看過一下 code 沒有 bug，因為不確定是少考慮 case 還是 claim 根本是錯的，剩下一個半小時我沒有時間繼續浪費在這裡了。</p>
<p>看了 pI 才發現感覺水水的，我第一輪到底在幹麻= =;<br>然後我到現在才意識到題目不是按照難度排，好好笑。<br>先寫個線性解確定推的式子是對的。<br><em><strong>pI 64/100 3:42:46</strong></em><br>然後就把式子整理一下弄成一個四階方陣。<br><em><strong>pI AC 3:58:31</strong></em></p>
<h1 id="第五小時"><a href="#第五小時" class="headerlink" title="第五小時"></a>第五小時</h1><p>最後一個小時，手上題目剩 C,E,F,H，因為 C, H 已經花過不少時間想過了，所以就從 E,F 下手。<br>我自己覺得我應該要再拿一題 AC 才會安全，所以我先從 E 開始想，結果除了第一子題以外都沒什麼想法，只好先把第一子題拿掉。<br><em><strong>pE 19/100 4:21:30</strong></em><br>然後又花了一點時間給自己想，只是還是沒結果。<br>時間快沒了只好跳去 F。</p>
<p>F 也是滿腦子都是背包zzz，但還是花了很多時間想，最後真的沒時間了只好把預算很少的子題拿掉。<br>寫完後測範測一直怪怪的，才發現自己看錯題目= =;<br>所以又花時間改了一些地方，改完後剩最後一分鐘看範測都過了就上傳。<br><em><strong>pF 0/100 4:59:23</strong></em></p>
<p><img src="scoring.png"></p>
<h1 id="賽後"><a href="#賽後" class="headerlink" title="賽後"></a>賽後</h1><p>我其實蠻緊張的，因為我覺得 pF 還蠻可作的，所以我拿 0 分超級不應該。然後別人問我分數我也不知道，因為我最後時間都在搞 pF 根本沒去算每題得分。</p>
<p>拿到手機看了記分板發現三等當下還蠻開心的，畢竟達成了賽前目標。<br>但是只有那當下。<br>「三等終於拿到了，明年就能劍指二等」…正要這麼想著的時候，才發現自己已經是最後一年了。<br>從高一開始就想著三年內要拿過一次二等以上，而機會已經沒了。<br>接下來看著盯著記分板，什麼話都說不出來，就呆站在放置行李那邊，其他人都走了而工作人員來叫我的時候我才回神過來把行李收一收去台達館等頒獎。</p>
<h1 id="之後"><a href="#之後" class="headerlink" title="之後"></a>之後</h1><p>仔細回想著賽中，但也想不到什麼重大失誤可以讓我後悔，就只有沒做出大家都做出來的 pF 很虧而已。<br>可是做不出題目能後悔什麼？就只有自己太爛。</p>
<p>四模拿了 23/400 分後，我整個陷入最低潮。當時根本不想打開 vim，因為一打開就會想到四模的燒雞慘況。就這樣到了 APIO 前都沒什麼打 code，所以 APIO 也很理所當然的打很差。<br>用著學校課業的藉口讓自己躲避競程，就這樣到了暑假卻也還沒振作。</p>
<p>一直到開學之後才終於回想起自己還有最後一年，可是此時回過神來發現已經一堆人都用著火箭般的速度超越我，而我才剛要重新起跑。<br>雖然之後盡可能的照著自己步調練習，盡可能的不去看其他人。<br>可是每次看到別人的表現就會讓自己更害怕，壓力也就越來越大。<br>得到這樣的成績我也只有自責的權利，很想要怨天尤人但自己也知道不能。<br>昨天回到家就坐在電腦前滑著社群，曾經幾度感覺差點哭出來。<br>從沒想過失去了「下次再加油」的權利會是這麼痛苦。</p>
]]></content>
      <tags>
        <tag>Competitive Programming</tag>
        <tag>experience</tag>
      </tags>
  </entry>
  <entry>
    <title>ARC85-NRE</title>
    <url>/ARC85-NRE/</url>
    <content><![CDATA[<p>你有一個序列長度為 $n$ 的序列 $a$，一開始 $a_i=0\ \forall 1\le i\le n$，然後輸入會給你一個長度為 $n$ 的序列 $b$，並且 $b_i \in \{0, 1\}$。<br/><br>然後輸入會給你可以使用的 $Q$ 筆操作 $l_i,\ r_i$，代表把 $a_l,a_{l+1},a_{l+2},\cdots,a_{r-1},a_r$ 都設成 1。<br/><br>你可以挑一些操作出來把他給用在序列上，可以全用也可以不用任何操作。<br>問你操作完的最小 hamming distance 是多少。<br>其中 hamming distnace 為滿足 $a_i\neq b_i$ 的 $i$ 的數量。<br/></p>
<span id="more"></span>
<p>$N, Q\le 2\times 10^5$</p>
<hr>
<p>這題真的是個酷酷題目。<br>首先我們考慮 dp，如果 $dp_i$ 為考慮前 $i$ 個答案之類的，在遇到線段相交的情形很容易爛掉。<br/><br>所以一個維度的 dp 似乎沒辦法解決問題，只好多用一維紀錄當前這格是否為 $1$。<br/><br>可是如果 $dp_{i,j}$ 的 $j$ 只有紀錄「是不是」的狀態也很難做（你會不知道你的操作右界是作到多少）。<br/><br>所以改成令 $dp_{i,j}$ 為考慮前 $i$ 格以及所有左界不超過 $i$ 的操作的答案，且最後一個操作的右界是 $j$（如果還沒實行過操作則 $j=0$），換句話說：區間 $[i,j]$ 都是 $1$（如果 $j\lt i$ 代表第 $i$ 格是 $0$）。<br/><br>那這樣就很好做了呀！<br>當我們的 $i$ 進到了某個操作的左界，且目前的 $j$ 不超過那個操作的右界，那實施了這個操作的話就會造成 $j$ 被更新。<br/><br>然後就能順便根據 $b$ 的值來決定當前哪些的狀態答案會增加。更正式的來說令 $cost_{i, j}$ 代表當前的狀態要不要增加答案，則：<br/><br>$$cost_{i, j}=\begin{cases} 1 &amp; \text{if}\ ( b_i=0\ \&amp;\&amp;\ i\le j)\ ||\ (b_i=1\ \&amp;\&amp;\ j\lt i) \\ 0 &amp; \text{otherwise} \end{cases}$$<br>接著是 dp 轉移式：<br>$$dp_{i, j} = cost_{i, j} + \begin{cases} \min_{0\le k\le i} dp_{i-1,k} &amp; \text{if}\ \exists c \text{ such that } (l_c=i\ \&amp;\&amp;\ r_c=j) \\ dp({i-1,j}) &amp; \text{otherwise} \end{cases}$$<br>如果你像我一樣看到數學式會怕的話可以看 code：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> dp[N][N], b[N]; <span class="comment">// dp[i][j] = INF forall i,j</span></span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; que[N]; <span class="comment">// right bounds of queries that left bounds is i</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">	cin &gt;&gt; b[i];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; q; i++) &#123;</span><br><span class="line">	<span class="keyword">int</span> l, r;</span><br><span class="line">	cin &gt;&gt; l, r;</span><br><span class="line">	que[l].<span class="built_in">push_back</span>(r);</span><br><span class="line">&#125;</span><br><span class="line">dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= n; j++)</span><br><span class="line">		dp[i][j] = dp[i - <span class="number">1</span>][j];</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> r : que[i]) &#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt;= i; k++)</span><br><span class="line">			dp[i][r] = <span class="built_in">min</span>(dp[i][r], dp[i - <span class="number">1</span>][k]);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>(b[i] == <span class="number">1</span>) &#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; j++)</span><br><span class="line">			dp[i][j]++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j = i; j &lt;= n; j++)</span><br><span class="line">			dp[i][j]++;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但我們沒解決根本上的問題：狀態數就已經是 $\mathcal{O}(N^2)$ 了。<br/><br>這就是這題的特點，雖然沒辦法再減少狀態數了，可是轉移式十分規律。<br>每到一個新的 $i$，除了那些詢問的右界以外，剩下都只是單純的區間加值。而詢問的右界也不難，只是前綴查詢最小值再單點修改而已。<br/><br>這些都是可以用線段樹作到的。區間加值的操作只會做 $\mathcal{O}(N)$ 次，而前綴查詢最小值以及單點修改只會做 $\mathcal{O}(Q)$ 次。總共複雜度會是 $\mathcal{O}(NlogN + QlogN)$。<br/><br>雖然狀態數是 $\mathcal{O}(N^2)$，但由於轉移很規律，所以透過資料結構我們只在以上的複雜度就能把全部的狀態算完了！<br/></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">--------------              |   /</span></span><br><span class="line"><span class="comment">      |                     |  /</span></span><br><span class="line"><span class="comment">      |                     | /</span></span><br><span class="line"><span class="comment">      |             *       |/          |    |         ------            *</span></span><br><span class="line"><span class="comment">      |                     |           |    |        /      \</span></span><br><span class="line"><span class="comment">      |             |       |\          |    |       |       |\          |</span></span><br><span class="line"><span class="comment">   \  |             |       | \         |    |       |       | \         |</span></span><br><span class="line"><span class="comment">    \ |             |       |  \        |    |        \     /   \        |</span></span><br><span class="line"><span class="comment">     V              |       |   \        \__/|         -----     \       |</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> debug(x) cerr &lt;&lt; <span class="meta-string">&quot;\e[1;31m&quot;</span> &lt;&lt; #x &lt;&lt; <span class="meta-string">&quot; = &quot;</span> &lt;&lt; (x) &lt;&lt; <span class="meta-string">&quot;\e[0m\n&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> print(x) emilia_mata_tenshi(#x, begin(x), end(x))</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="keyword">void</span> <span class="title">emilia_mata_tenshi</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *s, T l, T r)</span> </span>&#123;</span><br><span class="line">	cerr &lt;&lt; <span class="string">&quot;\e[1;33m&quot;</span> &lt;&lt; s &lt;&lt; <span class="string">&quot; = [&quot;</span>;</span><br><span class="line">	<span class="keyword">while</span>(l != r) &#123;</span><br><span class="line">		cerr &lt;&lt; *l;</span><br><span class="line">		cerr &lt;&lt; (++l == r ? <span class="string">&#x27;]&#x27;</span> : <span class="string">&#x27;,&#x27;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	cerr &lt;&lt; <span class="string">&quot;\e[0m\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EmiliaMyWife ios::sync_with_stdio(0); cin.tie(NULL);</span></span><br><span class="line"><span class="keyword">using</span> ll = <span class="keyword">int64_t</span>;</span><br><span class="line"><span class="keyword">using</span> ull = <span class="keyword">uint64_t</span>;</span><br><span class="line"><span class="keyword">using</span> ld = <span class="keyword">long</span> <span class="keyword">double</span>;</span><br><span class="line"><span class="keyword">using</span> uint = <span class="keyword">uint32_t</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> EPS  = <span class="number">1e-7</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF     = <span class="number">0x3F3F3F3F</span>;</span><br><span class="line"><span class="keyword">const</span> ll LINF     = <span class="number">4611686018427387903</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MOD     = <span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> Lamy_is_cute = []() &#123;</span><br><span class="line">	EmiliaMyWife</span><br><span class="line">	<span class="keyword">return</span> <span class="number">48763</span>;</span><br><span class="line">&#125;();</span><br><span class="line"><span class="comment">/*--------------------------------------------------------------------------------------*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2e5</span> + <span class="number">25</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">segtree</span> &#123;</span></span><br><span class="line">	<span class="keyword">int</span> arr[N &lt;&lt; <span class="number">1</span>], tag[N], n;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> _n)</span> </span>&#123;</span><br><span class="line">		n = _n;</span><br><span class="line">		<span class="built_in">memset</span>(arr, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> arr);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">upd</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">		arr[p] += v;</span><br><span class="line">		<span class="keyword">if</span>(p &lt; n)</span><br><span class="line">			tag[p] += v;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> h = __lg(p); ~h; h--) &#123;</span><br><span class="line">			<span class="keyword">int</span> i = p &gt;&gt; h;</span><br><span class="line">			<span class="built_in">upd</span>(i, tag[i &gt;&gt; <span class="number">1</span>]);</span><br><span class="line">			<span class="built_in">upd</span>(i ^ <span class="number">1</span>, tag[i &gt;&gt; <span class="number">1</span>]);</span><br><span class="line">			tag[i &gt;&gt; <span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">pull</span><span class="params">(<span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">for</span>(; p &gt; <span class="number">1</span>; p &gt;&gt;= <span class="number">1</span>)</span><br><span class="line">			arr[p &gt;&gt; <span class="number">1</span>] = <span class="built_in">min</span>(arr[p], arr[p ^ <span class="number">1</span>]) + tag[p &gt;&gt; <span class="number">1</span>];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">edt</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">		p += n;</span><br><span class="line">		<span class="built_in">push</span>(p);</span><br><span class="line">		arr[p] = <span class="built_in">min</span>(arr[p], v);</span><br><span class="line">		<span class="built_in">pull</span>(p);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> tl = l + n, tr = r + n - <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">for</span>(l += n, r += n; l &lt; r; l &gt;&gt;= <span class="number">1</span>, r &gt;&gt;= <span class="number">1</span>) &#123;</span><br><span class="line">			<span class="keyword">if</span>(l &amp; <span class="number">1</span>)</span><br><span class="line">				<span class="built_in">upd</span>(l++, v);</span><br><span class="line">			<span class="keyword">if</span>(r &amp; <span class="number">1</span>)</span><br><span class="line">				<span class="built_in">upd</span>(--r, v);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">pull</span>(tl); <span class="built_in">pull</span>(tr);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">que</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> res = INF;</span><br><span class="line">		<span class="built_in">push</span>(l + n); <span class="built_in">push</span>(r + n - <span class="number">1</span>);</span><br><span class="line">		<span class="keyword">for</span>(l += n, r += n; l &lt; r; l &gt;&gt;= <span class="number">1</span>, r &gt;&gt;= <span class="number">1</span>) &#123;</span><br><span class="line">			<span class="keyword">if</span>(l &amp; <span class="number">1</span>)</span><br><span class="line">				res = <span class="built_in">min</span>(res, arr[l++]);</span><br><span class="line">			<span class="keyword">if</span>(r &amp; <span class="number">1</span>)</span><br><span class="line">				res = <span class="built_in">min</span>(res, arr[--r]);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> res;</span><br><span class="line">	&#125;</span><br><span class="line">&#125; tree;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n;</span><br><span class="line">	cin &gt;&gt; n;</span><br><span class="line">	<span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">arr</span><span class="params">(n + <span class="number">1</span>)</span></span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">		cin &gt;&gt; arr[i];</span><br><span class="line">	tree.<span class="built_in">init</span>(n + <span class="number">1</span>);</span><br><span class="line">	tree.<span class="built_in">edt</span>(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">	vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">que</span>(n + <span class="number">1</span>);</span><br><span class="line">	<span class="keyword">int</span> q;</span><br><span class="line">	cin &gt;&gt; q;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; q; i++) &#123;</span><br><span class="line">		<span class="keyword">int</span> l, r;</span><br><span class="line">		cin &gt;&gt; l &gt;&gt; r;</span><br><span class="line">		que[l].<span class="built_in">push_back</span>(r);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> r : que[i]) &#123;</span><br><span class="line">			tree.<span class="built_in">edt</span>(r, tree.<span class="built_in">que</span>(<span class="number">0</span>, r + <span class="number">1</span>));</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(arr[i])</span><br><span class="line">			tree.<span class="built_in">add</span>(<span class="number">0</span>, i, <span class="number">1</span>);</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			tree.<span class="built_in">add</span>(i, n + <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; tree.<span class="built_in">que</span>(<span class="number">0</span>, n + <span class="number">1</span>) &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>Competitive Programming</tag>
        <tag>dp</tag>
        <tag>Data structure</tag>
        <tag>AtCoder</tag>
        <tag>ARC</tag>
      </tags>
  </entry>
  <entry>
    <title>CEOI 2019 Magic Tree</title>
    <url>/CEOI-2019-Magic-Tree/</url>
    <content><![CDATA[<p>我的作法感覺跟官解差很多，但我覺得蠻精妙的，所以紀錄一下。</p>
<span id="more"></span>
<p>題目有點長所以不貼了。</p>
<hr>
<h1 id="觀察-amp-預處理"><a href="#觀察-amp-預處理" class="headerlink" title="觀察&amp;預處理"></a>觀察&amp;預處理</h1><blockquote>
<p>觀察一<br>只有那些有果實的點往上的邊有可能需要被砍，因為不管怎樣的砍法都能規約到只砍那些邊。</p>
</blockquote>
<p>甚至可以建一張新圖，新圖只包含有果實的點，每個點的父親為他在原圖上有果實的那些祖先中最淺的點。<br>注意到新圖的答案跟原圖一樣，因為觀察一的結論。<br>然後新圖的點數就只會有 $M$ 個。</p>
<p>接下來把所有點照以熟成時間早到晚，如果熟成時間相同則在樹上的深度深到淺，這樣的順序排好，接下來就不用考慮熟成時間是多少了。</p>
<blockquote>
<p>觀察二<br>必定存在最佳解，滿足砍的順序會按照這個順序（子序列）。<br>可能會因為前面的點已經砍過了導致砍不了後面的點，但是在砍前面的點時則不會被後面的點影響</p>
</blockquote>
<p>所以我們接下來就用這個順序來算答案。整個過程就會是多考慮當前點-&gt;去改變要不要砍前面的點-&gt;重新計算答案。<br>每次重新計算完的答案就是「考慮前面這些點的最佳解」，所以全部考慮完後的答案就會是最後的答案。</p>
<h1 id="考慮基本情況"><a href="#考慮基本情況" class="headerlink" title="考慮基本情況"></a>考慮基本情況</h1><p>假設目前我們考慮的點是 $u$，如果 $u$ 的底下已經有被考慮過的點了，那我們可以先拔那些點再拔 $u$，所以不會怎樣。<br/><br>但如果 $u$ 的祖先有被考慮過的點（假設他叫 $v$）了，那拔掉 $v$ 後就不能拔 $u$ 了。<br/></p>
<p>接下來讓我們引入一種神奇的思維，令 $a_u$ 為拔掉第 $u$ 個點上面那條邊後的答案，我們的答案會是所有 $a_u$ 的總和。<br/><br>一開始 $a_u=w_u$，也就是拔掉後我們就能獲得 $w_u$ 的價值。可是 $u$ 跟 $v$ 不能一起拔，所以這時後有兩種情況。<br/></p>
<ol>
<li>$w_v\le w_u$：拔 $u$ 會比較好，所以把 $a_v$ 給設成 $0$。</li>
<li>$w_v\gt w_u$：拔 $v$ 會比較好，但是拔了 $v$ 就不能拔 $u$，所以讓 $a_v=w_v-w_u$，這樣全部加起來就會是 $w_v$。</li>
</ol>
<p>我們把第二點這樣減值的情況稱作懲罰，具體來說，$u$ 會給 $v$ 一個 $w_u$ 的懲罰，代表拔了 $v$ 的話會損失多少價值。<br/><br>注意到懲罰會是單調遞增的（因為你底下的點只會越來越多），所以當懲罰超過了 $w_v$ 時就代表拔 $v$ 點不會比較好，也就是根本不用考慮 $v$ 點了。<br/></p>
<h1 id="一般化作法"><a href="#一般化作法" class="headerlink" title="一般化作法"></a>一般化作法</h1><p>每個 $u$ 點維護一個 $pen_u$，代表將那個點身上的懲罰，也就是拔了那個點的話會損失多少價值，一開始 $pen_u=0$，而 $a_u=w_u-pen_u$。<br/><br>當我們把 $u$ 考慮進來後，令 $cur\_pen$ 為要送給祖先的懲罰，一開始 $cur\_pen=w_u$，接著去往祖先找第一個正在考慮的點 $v$，接下來考慮幾個情況：<br/></p>
<ol>
<li>不存在這樣的 $v$：那就不用加懲罰在任何點身上，所以直接結束當前操作。</li>
<li>$w_v-pen_v-cur\_pen\le 0$：代表此時拔這個點不會比較好了，所以不要考慮這個點。也就是把 $a_v$ 設成 $0$，並且把 $pen_v$ 的值都給加進 $cur\_pen$，同時在 $cur\_pen$ 中扣掉 $w_v^\textrm{註 1}$，也就是 $cur\_pen=cur\_pen+pen_v-w_v$，並且再往上找新的 $v$ 重複操作。</li>
<li>$w_v-pen_v-cur\_pen\gt 0$：代表目前的解中，拔掉 $v$ 還是比較好，所以就讓 $a_v=u_v-pen_v-cur\_pen$，並且結束當前操作。</li>
</ol>
<p>注意到我們的「懲罰」其實就是反悔操作，在當前點的價值大於身上的懲罰時，我們就拔掉這個點，否則就不拔這個點，而反悔成拔他下面那些點。</p>
<blockquote>
<p>註 1<br>為什麼在移除這個點之後要把當前的懲罰扣除自己的價值？這可以看成再反悔的表現，因為拔掉自己跟拔掉下面的點不能同時發生，目前移除當前點是因為我們覺得不拔自己、拔掉下面會比較好。但是之後有可能會有更上面的點帶著很大的價值，這樣的話有可能拔掉下面點會變差（因此就不拔了），那此時不就可以拔掉自己了？<br>注意到就算那個「更上面的點」拔了的話自己也不能拔，那上面的那個點會帶著自己的懲罰（$pen_v$ 中有著 $w_u$），這樣會抵銷。<br/><br>再注意到如果已經找不到上面的點了（情況 1），那這樣也不可能有著點會帶著自己的懲罰，所以把當前懲罰給丟掉就只是讓這點造成的貢獻都歸 0，從這個世界被遺忘(?</p>
</blockquote>
<p>以下是用 code 說明這段事：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sort</span>(owo.<span class="built_in">begin</span>(), owo.<span class="built_in">end</span>(), [&amp;](<span class="keyword">auto</span> a, <span class="keyword">auto</span> b) &#123; <span class="keyword">return</span> a.first == b.first ? dep[a.second] &gt; dep[b.second] : a.first &lt; b.first; &#125;); <span class="comment">// owo 是上面提到的順序</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">const</span> <span class="keyword">auto</span> &amp;[d, u] : owo) &#123; <span class="comment">// 熟成時間, 點編號，這裡不會用到熟成時間了</span></span><br><span class="line">	<span class="keyword">int</span> p = u;</span><br><span class="line">	ll cur_pen = arr[u]; <span class="comment">// arr[u] 為題目中的 w[u]</span></span><br><span class="line">	<span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">		p = <span class="built_in">find_first</span>(p); <span class="comment">// 往上找到第一個還沒被移除的點</span></span><br><span class="line">		<span class="keyword">if</span>(!p) <span class="comment">// 找不到沒被移除的點了</span></span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">if</span>(arr[p] - pen[p] - cur_pen &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">			<span class="built_in">rem</span>(p); <span class="comment">// 移除點 p</span></span><br><span class="line">			<span class="built_in">edt</span>(p, <span class="number">0</span>); <span class="comment">// 把 a_p 設成 0</span></span><br><span class="line">			cur_pen += pen[p] - arr[p];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			pen[p] += cur_pen;</span><br><span class="line">			<span class="built_in">edt</span>(p, arr[p] - pen[p]); <span class="comment">// 把 a_p 設成 w_p-pen_p-cur_pen</span></span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">edt</span>(u, arr[u]); <span class="comment">// 把 a_u 設成 w_u</span></span><br><span class="line">	<span class="built_in">add</span>(u); <span class="comment">// 開始考慮點 u</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; res &lt;&lt; <span class="string">&#x27;\n&#x27;</span>; <span class="comment">// res 為當前的答案</span></span><br></pre></td></tr></table></figure>

<h1 id="複雜度分析"><a href="#複雜度分析" class="headerlink" title="複雜度分析"></a>複雜度分析</h1><p>在以上程式碼，因為每個點只會被加入/移除一次，所以 <code>find_first</code> 會執行 $\mathcal{O}(M)$ 次，而 <code>rem,edt,add</code> 最多執行 $M$ 次。<br/><br>其中 <code>edt</code> 因為是維護全部的總和而已，所以可以 $\mathcal{O}(1)$。<br>如果 <code>find_first,edt,add</code> 使用暴力往上找的話複雜度會是 $\mathcal{O}(M)$，此時可以拿到 $M\le 1000$ 的子題。<br/><br>如果有在考慮的點設成 $1$，還沒考慮/已經移除的設成 $0$，那根到當前點的總和就會是路上有多少正在被考慮的點，這樣就可以二分搜第一個總和改變的祖先在哪裡，配合樹壓平作到 $\mathcal{O}(\log M)$ 查詢，<code>find_first, edt, add</code> 的複雜度就能壓成 $\mathcal{O}(\log^2 M)$。<br/><br>總複雜度 $\mathcal{O}(M\log^2 M)$。<br/></p>
<h1 id="code"><a href="#code" class="headerlink" title="code"></a>code</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 100/100</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">--------------              |   /</span></span><br><span class="line"><span class="comment">      |                     |  /</span></span><br><span class="line"><span class="comment">      |                     | /</span></span><br><span class="line"><span class="comment">      |             *       |/          |    |         ------            *</span></span><br><span class="line"><span class="comment">      |                     |           |    |        /      \</span></span><br><span class="line"><span class="comment">      |             |       |\          |    |       |       |\          |</span></span><br><span class="line"><span class="comment">   \  |             |       | \         |    |       |       | \         |</span></span><br><span class="line"><span class="comment">    \ |             |       |  \        |    |        \     /   \        |</span></span><br><span class="line"><span class="comment">     V              |       |   \        \__/|         -----     \       |</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> debug(x) cerr &lt;&lt; <span class="meta-string">&quot;\e[1;31m&quot;</span> &lt;&lt; #x &lt;&lt; <span class="meta-string">&quot; = &quot;</span> &lt;&lt; (x) &lt;&lt; <span class="meta-string">&quot;\e[0m\n&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> print(x) emilia_mata_tenshi(#x, begin(x), end(x))</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="keyword">void</span> <span class="title">emilia_mata_tenshi</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *s, T l, T r)</span> </span>&#123;</span><br><span class="line">	cerr &lt;&lt; <span class="string">&quot;\e[1;33m&quot;</span> &lt;&lt; s &lt;&lt; <span class="string">&quot; = [&quot;</span>;</span><br><span class="line">	<span class="keyword">while</span>(l != r) &#123;</span><br><span class="line">		cerr &lt;&lt; *l;</span><br><span class="line">		cerr &lt;&lt; (++l == r ? <span class="string">&#x27;]&#x27;</span> : <span class="string">&#x27;,&#x27;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	cerr &lt;&lt; <span class="string">&quot;\e[0m\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EmiliaMyWife ios::sync_with_stdio(0); cin.tie(NULL);</span></span><br><span class="line"><span class="keyword">using</span> ll = <span class="keyword">int64_t</span>;</span><br><span class="line"><span class="keyword">using</span> ull = <span class="keyword">uint64_t</span>;</span><br><span class="line"><span class="keyword">using</span> ld = <span class="keyword">long</span> <span class="keyword">double</span>;</span><br><span class="line"><span class="keyword">using</span> uint = <span class="keyword">uint32_t</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> EPS  = <span class="number">1e-7</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF     = <span class="number">0x3F3F3F3F</span>;</span><br><span class="line"><span class="keyword">const</span> ll LINF     = <span class="number">4611686018427387903</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MOD     = <span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> Lamy_is_cute = []() &#123;</span><br><span class="line">	EmiliaMyWife</span><br><span class="line">	<span class="keyword">return</span> <span class="number">48763</span>;</span><br><span class="line">&#125;();</span><br><span class="line"><span class="comment">/*--------------------------------------------------------------------------------------*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span> + <span class="number">25</span>, LGN = <span class="number">18</span>;</span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; tmp_edge[N], edge[N];</span><br><span class="line"><span class="keyword">int</span> dep[N], arr[N], anc[LGN][N], in[N], out[N], t = <span class="number">1</span>;</span><br><span class="line">ll pen[N];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">fenwicktree</span> &#123;</span></span><br><span class="line">	<span class="keyword">int</span> arr[N &lt;&lt; <span class="number">1</span>];</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">edt</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">for</span>(; p &lt; (N &lt;&lt; <span class="number">1</span>); p += p &amp; -p)</span><br><span class="line">			arr[p] += v;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">que</span><span class="params">(<span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(; p; p -= p &amp; -p)</span><br><span class="line">			res += arr[p];</span><br><span class="line">		<span class="keyword">return</span> res;</span><br><span class="line">	&#125;</span><br><span class="line">&#125; bit;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> lst)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(arr[u]) &#123;</span><br><span class="line">		edge[lst].<span class="built_in">push_back</span>(u);</span><br><span class="line">		lst = u;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> v : tmp_edge[u])</span><br><span class="line">		<span class="built_in">build</span>(v, lst);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u)</span> </span>&#123;</span><br><span class="line">	in[u] = t++;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> v : edge[u]) &#123;</span><br><span class="line">		dep[v] = dep[u] + <span class="number">1</span>;</span><br><span class="line">		anc[<span class="number">0</span>][v] = u;</span><br><span class="line">		<span class="built_in">dfs</span>(v);</span><br><span class="line">	&#125;</span><br><span class="line">	out[u] = t++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">binary_build</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; LGN; i++)</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++)</span><br><span class="line">			anc[i][j] = anc[i - <span class="number">1</span>][anc[i - <span class="number">1</span>][j]];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find_first</span><span class="params">(<span class="keyword">int</span> u)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(bit.<span class="built_in">que</span>(in[u]) == <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = LGN - <span class="number">1</span>; ~i; i--) &#123;</span><br><span class="line">		<span class="keyword">int</span> p = anc[i][u];</span><br><span class="line">		<span class="keyword">if</span>(p &amp;&amp; bit.<span class="built_in">que</span>(in[p]) == bit.<span class="built_in">que</span>(in[u]))</span><br><span class="line">			u = p;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> u;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u)</span> </span>&#123;</span><br><span class="line">	bit.<span class="built_in">edt</span>(in[u], <span class="number">1</span>);</span><br><span class="line">	bit.<span class="built_in">edt</span>(out[u], <span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rem</span><span class="params">(<span class="keyword">int</span> u)</span> </span>&#123;</span><br><span class="line">	bit.<span class="built_in">edt</span>(in[u], <span class="number">-1</span>);</span><br><span class="line">	bit.<span class="built_in">edt</span>(out[u], <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ll res = <span class="number">0</span>;</span><br><span class="line">ll cur[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">edt</span><span class="params">(<span class="keyword">int</span> p, ll v)</span> </span>&#123;</span><br><span class="line">	res -= cur[p];</span><br><span class="line">	cur[p] = v;</span><br><span class="line">	res += cur[p];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n, m, k;</span><br><span class="line">	cin &gt;&gt; n &gt;&gt; m &gt;&gt; k;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>, p; i &lt;= n; i++)</span><br><span class="line">		cin &gt;&gt; p, tmp_edge[p].<span class="built_in">push_back</span>(i);</span><br><span class="line"></span><br><span class="line">	vector&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; owo;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">		<span class="keyword">int</span> u, d, w;</span><br><span class="line">		cin &gt;&gt; u &gt;&gt; d &gt;&gt; w;</span><br><span class="line">		arr[u] = w;</span><br><span class="line">		owo.<span class="built_in">push_back</span>(&#123;d, u&#125;);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">build</span>(<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">	dep[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">	<span class="built_in">dfs</span>(<span class="number">1</span>);</span><br><span class="line">	<span class="built_in">binary_build</span>(n);</span><br><span class="line">	<span class="built_in">sort</span>(owo.<span class="built_in">begin</span>(), owo.<span class="built_in">end</span>(), [&amp;](<span class="keyword">auto</span> a, <span class="keyword">auto</span> b) &#123; <span class="keyword">return</span> a.first == b.first ? dep[a.second] &gt; dep[b.second] : a.first &lt; b.first; &#125;);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">const</span> <span class="keyword">auto</span> &amp;[d, u] : owo) &#123;</span><br><span class="line">		<span class="keyword">int</span> p = u;</span><br><span class="line">		ll cur_pen = arr[u];</span><br><span class="line">		<span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">			p = <span class="built_in">find_first</span>(p);</span><br><span class="line">			<span class="keyword">if</span>(!p)</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">if</span>(arr[p] - pen[p] - cur_pen &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">				<span class="built_in">rem</span>(p);</span><br><span class="line">				<span class="built_in">edt</span>(p, <span class="number">0</span>);</span><br><span class="line">				cur_pen += pen[p] - arr[p];</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> &#123;</span><br><span class="line">				pen[p] += cur_pen;</span><br><span class="line">				<span class="built_in">edt</span>(p, arr[p] - pen[p]);</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">edt</span>(u, arr[u]);</span><br><span class="line">		<span class="built_in">add</span>(u);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; res &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="O-M-2"><a href="#O-M-2" class="headerlink" title="O(M^2)"></a>O(M^2)</h1><p>順便貼個 $\mathcal{O}(M^2)$ 的作法。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 19/100</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">--------------              |   /</span></span><br><span class="line"><span class="comment">      |                     |  /</span></span><br><span class="line"><span class="comment">      |                     | /</span></span><br><span class="line"><span class="comment">      |             *       |/          |    |         ------            *</span></span><br><span class="line"><span class="comment">      |                     |           |    |        /      \</span></span><br><span class="line"><span class="comment">      |             |       |\          |    |       |       |\          |</span></span><br><span class="line"><span class="comment">   \  |             |       | \         |    |       |       | \         |</span></span><br><span class="line"><span class="comment">    \ |             |       |  \        |    |        \     /   \        |</span></span><br><span class="line"><span class="comment">     V              |       |   \        \__/|         -----     \       |</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> debug(x) cerr &lt;&lt; <span class="meta-string">&quot;\e[1;31m&quot;</span> &lt;&lt; #x &lt;&lt; <span class="meta-string">&quot; = &quot;</span> &lt;&lt; (x) &lt;&lt; <span class="meta-string">&quot;\e[0m\n&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> print(x) emilia_mata_tenshi(#x, begin(x), end(x))</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="keyword">void</span> <span class="title">emilia_mata_tenshi</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *s, T l, T r)</span> </span>&#123;</span><br><span class="line">	cerr &lt;&lt; <span class="string">&quot;\e[1;33m&quot;</span> &lt;&lt; s &lt;&lt; <span class="string">&quot; = [&quot;</span>;</span><br><span class="line">	<span class="keyword">while</span>(l != r) &#123;</span><br><span class="line">		cerr &lt;&lt; *l;</span><br><span class="line">		cerr &lt;&lt; (++l == r ? <span class="string">&#x27;]&#x27;</span> : <span class="string">&#x27;,&#x27;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	cerr &lt;&lt; <span class="string">&quot;\e[0m\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EmiliaMyWife ios::sync_with_stdio(0); cin.tie(NULL);</span></span><br><span class="line"><span class="keyword">using</span> ll = <span class="keyword">int64_t</span>;</span><br><span class="line"><span class="keyword">using</span> ull = <span class="keyword">uint64_t</span>;</span><br><span class="line"><span class="keyword">using</span> ld = <span class="keyword">long</span> <span class="keyword">double</span>;</span><br><span class="line"><span class="keyword">using</span> uint = <span class="keyword">uint32_t</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> EPS  = <span class="number">1e-7</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF     = <span class="number">0x3F3F3F3F</span>;</span><br><span class="line"><span class="keyword">const</span> ll LINF     = <span class="number">4611686018427387903</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MOD     = <span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> Lamy_is_cute = []() &#123;</span><br><span class="line">	EmiliaMyWife</span><br><span class="line">	<span class="keyword">return</span> <span class="number">48763</span>;</span><br><span class="line">&#125;();</span><br><span class="line"><span class="comment">/*--------------------------------------------------------------------------------------*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span> + <span class="number">25</span>, LGN = <span class="number">18</span>;</span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; tmp_edge[N], edge[N];</span><br><span class="line"><span class="keyword">int</span> dep[N], arr[N], anc[LGN][N], in[N], out[N], t;</span><br><span class="line">ll pen[N];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">segtree</span> &#123;</span></span><br><span class="line">	ll arr[N &lt;&lt; <span class="number">1</span>];</span><br><span class="line">	<span class="keyword">int</span> n;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> _n)</span> </span>&#123; n = _n; &#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">edt</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">for</span>(arr[p += n] = v; p &gt; <span class="number">1</span>; p &gt;&gt;= <span class="number">1</span>)</span><br><span class="line">			arr[p &gt;&gt; <span class="number">1</span>] = arr[p] + arr[p ^ <span class="number">1</span>];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function">ll <span class="title">que</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">		ll res = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(l += n, r += n; l &lt; r; l &gt;&gt;= <span class="number">1</span>, r &gt;&gt;= <span class="number">1</span>) &#123;</span><br><span class="line">			<span class="keyword">if</span>(l &amp; <span class="number">1</span>)</span><br><span class="line">				res += arr[l++];</span><br><span class="line">			<span class="keyword">if</span>(r &amp; <span class="number">1</span>)</span><br><span class="line">				res += arr[--r];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> res;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> lst)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(arr[u]) &#123;</span><br><span class="line">		edge[lst].<span class="built_in">push_back</span>(u);</span><br><span class="line">		lst = u;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> v : tmp_edge[u])</span><br><span class="line">		<span class="built_in">build</span>(v, lst);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u)</span> </span>&#123;</span><br><span class="line">	in[u] = t++;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> v : edge[u]) &#123;</span><br><span class="line">		dep[v] = dep[u] + <span class="number">1</span>;</span><br><span class="line">		anc[<span class="number">0</span>][v] = u;</span><br><span class="line">		<span class="built_in">dfs</span>(v);</span><br><span class="line">	&#125;</span><br><span class="line">	out[u] = t++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">binary_build</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; LGN; i++)</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++)</span><br><span class="line">			anc[i][j] = anc[i - <span class="number">1</span>][anc[i - <span class="number">1</span>][j]];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// O(N^2) now</span></span><br><span class="line"><span class="keyword">bool</span> is[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find_first</span><span class="params">(<span class="keyword">int</span> u)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">while</span>(u &amp;&amp; !is[u])</span><br><span class="line">		u = anc[<span class="number">0</span>][u];</span><br><span class="line">	<span class="keyword">return</span> u;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u)</span> </span>&#123;</span><br><span class="line">	is[u] = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rem</span><span class="params">(<span class="keyword">int</span> u)</span> </span>&#123;</span><br><span class="line">	is[u] = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ll res = <span class="number">0</span>;</span><br><span class="line">ll cur[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">edt</span><span class="params">(<span class="keyword">int</span> p, ll v)</span> </span>&#123;</span><br><span class="line">	res -= cur[p];</span><br><span class="line">	cur[p] = v;</span><br><span class="line">	res += cur[p];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n, m, k;</span><br><span class="line">	cin &gt;&gt; n &gt;&gt; m &gt;&gt; k;</span><br><span class="line">	<span class="built_in">assert</span>(m &lt;= <span class="number">1000</span>);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>, p; i &lt;= n; i++)</span><br><span class="line">		cin &gt;&gt; p, tmp_edge[p].<span class="built_in">push_back</span>(i);</span><br><span class="line"></span><br><span class="line">	vector&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; owo;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">		<span class="keyword">int</span> u, d, w;</span><br><span class="line">		cin &gt;&gt; u &gt;&gt; d &gt;&gt; w;</span><br><span class="line">		arr[u] = w;</span><br><span class="line">		owo.<span class="built_in">push_back</span>(&#123;d, u&#125;);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">build</span>(<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">	dep[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">	<span class="built_in">dfs</span>(<span class="number">1</span>);</span><br><span class="line">	<span class="built_in">binary_build</span>(n);</span><br><span class="line">	<span class="built_in">sort</span>(owo.<span class="built_in">begin</span>(), owo.<span class="built_in">end</span>(), [&amp;](<span class="keyword">auto</span> a, <span class="keyword">auto</span> b) &#123; <span class="keyword">return</span> a.first == b.first ? dep[a.second] &gt; dep[b.second] : a.first &lt; b.first; &#125;);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">const</span> <span class="keyword">auto</span> &amp;[d, u] : owo) &#123;</span><br><span class="line">		<span class="keyword">int</span> p = u;</span><br><span class="line">		ll cur_pen = arr[u];</span><br><span class="line">		<span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">			p = <span class="built_in">find_first</span>(p);</span><br><span class="line">			<span class="keyword">if</span>(!p)</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">if</span>(arr[p] - pen[p] - cur_pen &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">				<span class="built_in">rem</span>(p);</span><br><span class="line">				<span class="built_in">edt</span>(p, <span class="number">0</span>);</span><br><span class="line">				cur_pen += pen[p] - arr[p];</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> &#123;</span><br><span class="line">				pen[p] += cur_pen;</span><br><span class="line">				<span class="built_in">edt</span>(p, arr[p] - pen[p]);</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">edt</span>(u, arr[u]);</span><br><span class="line">		<span class="built_in">add</span>(u);</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; res &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>Competitive Programming</tag>
        <tag>greedy</tag>
        <tag>data structure</tag>
        <tag>CEOI</tag>
        <tag>binary lifting</tag>
      </tags>
  </entry>
  <entry>
    <title>TIOJ-1596</title>
    <url>/TIOJ-1596/</url>
    <content><![CDATA[<p>黑色騎士團終於決定了攻打大不列顛帝國的戰略。<br>在大不列顛帝國的國土當中，有著許多的城市，城市與城市之間會有道路相互連通。<br>在這些城市當中，有些特別的城市兼具有軍事堡壘的功能。<br>想要完全的佔領大不列顛帝國，必須要摧毀一些道路，讓軍事堡壘城市之間兩兩無法到達。<br>對於兩個城市，如果他們之間直接有道路連通，或著他們都同樣可以到達另一個城市，那我們說他們是可到達的。<br>摧毀道路是需要花錢的。經過了許久的研究，黑色騎士團發現對於每一條道路而言，摧毀它必然會造成某些城市之間不可到達。<br>請問如果要佔領大不列顛帝國，最少要花多少錢摧毀道路？</p>
<span id="more"></span>
<p>$n\le 10^5, c\le 2\times 10^4$</p>
<hr>
<p>首先把某個重點畫起來：「對於每一條道路而言，摧毀它必然會造成某些城市之間不可到達。」<br>這一句話就代表了這張圖是一顆樹，所以原題目中的邊數 $m$ 肯定是 $n-1$。<br/><br>所以就是給一棵帶邊權的樹，其中一些點是特殊點，問拔邊的最小花費使得特殊點不連通。</p>
<p>原本我是想要用 MST 那樣先把邊由小排到大再 greedy 不加邊，看起來很假解也很理所當然的 WA 了，可是我不知道為什麼&gt;&lt;<br>總之後來的作法就是正規的樹DP。<br>令 $dp[u][1]$ 為以 $u$ 為根的子樹的答案，且 $u$ 目前所在的連通塊中有特殊點的最小花費，$dp[u][0]$ 則是沒有特殊點。<br/><br>初始狀態就是如果 $u$ 是特殊點的話把 $dp[u][1]$ 設成 $0$ 且 $dp[u][0]$ 設成無限大，$u$ 不是特殊點的話就相反。<br/><br>在合併子孫的答案時其實就考慮八種 case：哪邊有特殊點，以及要不要拔邊。<br>但其實只有兩邊都有特殊點時才需要拔邊，所以只有五種 case，列出轉移式同時應該就能自行體會了。<br>令 $u$ 為當前子樹，$v$ 為要合併進來的子孫，$c$ 為連接 $(u, v)$ 的邊權，則：<br>$$dp[u][1] = min(dp[u][1] + dp[v][0], dp[u][1] + dp[v][1] + c, dp[u][0] + dp[v][1])$$<br>$$dp[u][0] = min(dp[u][0] + dp[v][1] + c, dp[u][0] + dp[v][0])$$<br>答案會是 $min(dp[1][1],dp[1][0])$（我令 $1$ 號點為根）。<br/><br>這樣就是妥妥的 $\mathcal{O}(N)$。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">--------------              |   /</span></span><br><span class="line"><span class="comment">      |                     |  /</span></span><br><span class="line"><span class="comment">      |                     | /</span></span><br><span class="line"><span class="comment">      |             *       |/          |    |         ------            *</span></span><br><span class="line"><span class="comment">      |                     |           |    |        /      \</span></span><br><span class="line"><span class="comment">      |             |       |\          |    |       |       |\          |</span></span><br><span class="line"><span class="comment">   \  |             |       | \         |    |       |       | \         |</span></span><br><span class="line"><span class="comment">    \ |             |       |  \        |    |        \     /   \        |</span></span><br><span class="line"><span class="comment">     V              |       |   \        \__/|         -----     \       |</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EmiliaMyWife ios::sync_with_stdio(0); cin.tie(NULL);</span></span><br><span class="line"><span class="keyword">using</span> ll = <span class="keyword">int64_t</span>;</span><br><span class="line"><span class="keyword">const</span> ll LINF     = <span class="number">4611686018427387903</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> Lamy_is_cute = []() &#123;</span><br><span class="line">	EmiliaMyWife</span><br><span class="line">	<span class="keyword">return</span> <span class="number">48763</span>;</span><br><span class="line">&#125;();</span><br><span class="line"><span class="comment">/*--------------------------------------------------------------------------------------*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span> + <span class="number">25</span>;</span><br><span class="line">ll dp[N][<span class="number">2</span>];</span><br><span class="line"><span class="keyword">bool</span> is[N];</span><br><span class="line">vector&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; edge[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">	dp[u][!is[u]] = <span class="built_in">ll</span>(<span class="number">1e15</span>);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">const</span> <span class="keyword">auto</span> &amp;[v, c] : edge[u]) &#123;</span><br><span class="line">		<span class="keyword">if</span>(v == p)</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		<span class="built_in">dfs</span>(v, u);</span><br><span class="line">		dp[u][<span class="number">1</span>] = <span class="built_in">min</span>(&#123;dp[u][<span class="number">1</span>] + dp[v][<span class="number">0</span>], dp[u][<span class="number">1</span>] + dp[v][<span class="number">1</span>] + c, dp[u][<span class="number">0</span>] + dp[v][<span class="number">1</span>]&#125;);</span><br><span class="line">		dp[u][<span class="number">0</span>] += <span class="built_in">min</span>(dp[v][<span class="number">1</span>] + c, dp[v][<span class="number">0</span>]);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n, m;</span><br><span class="line">	cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">	<span class="keyword">while</span>(m--) &#123;</span><br><span class="line">		<span class="keyword">int</span> u, v, c;</span><br><span class="line">		cin &gt;&gt; u &gt;&gt; v &gt;&gt; c;</span><br><span class="line">		edge[u].<span class="built_in">push_back</span>(&#123;v, c&#125;);</span><br><span class="line">		edge[v].<span class="built_in">push_back</span>(&#123;u, c&#125;);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> k;</span><br><span class="line">	cin &gt;&gt; k;</span><br><span class="line">	<span class="keyword">while</span>(k--) &#123;</span><br><span class="line">		<span class="keyword">int</span> x;</span><br><span class="line">		cin &gt;&gt; x;</span><br><span class="line">		is[x] = <span class="literal">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">dfs</span>(<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">	cout &lt;&lt; <span class="built_in">min</span>(dp[<span class="number">1</span>][<span class="number">1</span>], dp[<span class="number">1</span>][<span class="number">0</span>]) &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>Competitive Programming</tag>
        <tag>TIOJ</tag>
        <tag>Dynamic Programming</tag>
      </tags>
  </entry>
  <entry>
    <title>2022IOIC</title>
    <url>/2022IOIC/</url>
    <content><![CDATA[<p>因為覺得去年分五天講實在造成文章數有點過多，所以今年決定寫在一起。</p>
<span id="more"></span>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>今年 IOIC 終於到啦！雖然很遺憾的在前幾天轉成了線上。<br>所以變成主要訊息和團體賽等等都在 discord 告知，然後上課用 google meet…<br>交大的 PCCA 剛好也撞期了，可是看起來 IOIC 人多很多所以就來 IOIC 了XD</p>
<h1 id="Day-1"><a href="#Day-1" class="headerlink" title="Day 1"></a>Day 1</h1><p>因為線上所以很理所當然沒有報到，但是時程表不變，所以就變成可以晚一點起床。<br>今天的行程主要是早上的經驗分享，下午的資料結構以及晚上的團體趣味賽。</p>
<h2 id="這不是）經驗分享"><a href="#這不是）經驗分享" class="headerlink" title="(這不是）經驗分享"></a>(這不是）經驗分享</h2><p>今年是由 Darryl Ho 大大來分享OAO，主要就是提到他自己的歷程，然後他建議在 IOIC 期間可以怎麼最大化自己的學習效果。<br>然後也由總召來宣佈了一些規則已經注意事項，蠻有趣的是因為線上，所以就多了一個 Flag 活動，具體來說，在營隊的各個地方會出現一串具有 flag 格式的字串，第一個上傳這個字串到表單的人可以獲得一杯外送飲料w<br>這次營隊有 72 人，不知道有沒有機會分到一杯（<br>也講到這次有特殊的 ioicamp 賽制，也就是 IOI 先比分數，但是又用了 penalty，感覺有點像是 GCJ 可是又沒很像。</p>
<p>話說他有提供一個主觀的 CF rating 對照 TOI 程度的表，他上面寫了二階需要 2400 的實力，可是我的 rating 甚至不到 2200，我果然不該進的@@<br>他高中時的訓練強度好高orz，我覺得自己根本撐不住這麼硬的強度。</p>
<h3 id="破冰-gartic"><a href="#破冰-gartic" class="headerlink" title="破冰-gartic"></a>破冰-gartic</h3><p>為了在線上的情況下不要跟團體賽的隊友太尷尬，所以他們準備了一個 gartic 題庫然後讓大家進去玩。<br>然後的確我們也在這個時候講了蠻多話的(?)，看來應該是有破冰作用。<br>或者可能是 darren 跟 koying 本來就有點認識吧，總之到後來我們也有蠻多話題可以聊的。</p>
<p>雖然我們一開始話題根本對不上，因為 gartic 一個房間的人數限制導致我們必須奇數隊偶數隊在不同房間，然後我笨到跑錯房間，大概第一局快結束的時候我才發現。</p>
<p>gartic 有各種競程的資結算法之類的，然後都會看到一些奇怪抽象的圖畫w<br>比如時間線段樹就是畫一個線段樹然後旁邊畫時鐘。</p>
<h2 id="flag-get"><a href="#flag-get" class="headerlink" title="flag get!"></a>flag get!</h2><p>這邊有一個小插曲，在我吃完午餐的時候回到了電腦前面，想說趁還沒上課前先把講義習題寫一些。<br>所以就上了 CF 寫題目，寫完這題後我想說離上課已經快了，應該有人也在先寫講義題目，所以就戳了好友的 submission 看有沒有人在寫什麼。<br>結果只有看到講師的蛋餅有寫題目，大概是等等上課的題目吧我猜？<br>不過往下滑後我看到了他傳了 Compile Error，而且還在同一題傳四次。想說有點怪所以我就點開來看了。<br>不點還好，一點嚇到：這不是 flag 的格式嗎？<br>把他上傳之後真的拿到了飲料XD<br>真的是有夠幸運的，沒有什麼找或者搶的過程，單純就是剛好看到。</p>
<p>後來發現蛋餅是預計在基礎資結開頭的自介提供這個搶 flag 的活動，結果在上課前被我搶掉了，有點抱歉(</p>
<h2 id="資料結構"><a href="#資料結構" class="headerlink" title="資料結構"></a>資料結構</h2><p>因為是線上所以可以基礎進階的兩邊一起聽；進階主要感覺跟去年差不多，所以應該是再聽一次來讓自己更加了解；基礎則是有一些是我沒看過的。</p>
<p>進階的前面聽得很順，後面題目的部份今年多講了好幾題，然後都好難orz<br>根本沒什麼吸收，好痛苦。看到大家都在熱烈的討論作法，就我連上一題的思路都還沒好好了解:(<br>上了整節課之後，原本會的還是會，但是不會的那些卻感覺沒什麼聽懂QQ<br>大概是我太笨吧。</p>
<p>基礎的貓樹內容意外好簡略，可能是講師也沒有想太細講這個吧，畢竟看起來就不太會用到(?<br>可是我覺得有點酷，之後應該會好好了解一下這東西。</p>
<h2 id="團體趣味賽"><a href="#團體趣味賽" class="headerlink" title="團體趣味賽"></a>團體趣味賽</h2><p>題目有 23 題，超多zzz<br>覺得自己打得有點差，開題根本沒開到，整場都在跟題。<br>想題目也是，盯著他的 code 很久才發現可以直接硬做。連圖論最基本重邊能讓很多解爛掉這件事都能忘記。<br>也有很多時間都是在亂看題目然後腦袋放空，只要 random 亂生數字的題目也能想正規解想老半天。<br>幸好 koying 跟 darren 夠 carry 才讓這場名次沒太差(<br>最後是第 6 名收尾orz<br><img src="day1_scoreboard.png" alt="Day 1 scoreboard"></p>
<p>明天早上是數學，想到就痛苦跟絕望。</p>
<h1 id="Day-2"><a href="#Day-2" class="headerlink" title="Day 2"></a>Day 2</h1><p>第二天了，昨天一點多才睡導致今天有點累。<br>今天的課是數學、圖論，比賽是個人賽。</p>
<h2 id="數學"><a href="#數學" class="headerlink" title="數學"></a>數學</h2><p>數學到底為啥沒分基礎跟進階zzz<br>一開始組合跟數論都是去年的東西，然後講到捲積的時候因為我真的不會複數平面所以只能聽得半矇半懂。<br>講到生成函數的時候就…根本不知道在幹麻。<br>數學好難喔。</p>
<h2 id="飲料"><a href="#飲料" class="headerlink" title="飲料"></a>飲料</h2><p>中午的時候送來了飲料！昨天 flag 的獎勵。<br>他有說可以讓我點餐，限制是費用加上運費之後不能超過某個數字。<br>然後我就想說自己一個人喝的那就別太貪心，所以就點平常喝的 45 元多多綠茶。<br>結果送來的時候發現上面寫著 129 元，蛤？<br>才發現 foodpanda 除了運費 30 以外還有 99 元的低消，所以我就算點了兩杯也還是一樣是 129 元。<br>我都不知道這件事QQ，太少叫 foodpanda，早知道就點兩杯了。<br><img src="drink.jpg" alt="Drink"></p>
<h2 id="贊助商"><a href="#贊助商" class="headerlink" title="贊助商"></a>贊助商</h2><p>因為真的很酷所以特別講。<br>去年的贊助商來了後介紹他們的公司，說明他們在做什麼東西（是屬於講給大眾聽的那種，沒什麼技術細節），所以就很無趣。<br>結果今年的贊助商 mixerbox 居然是派前競賽選手回來演講，超酷。<br>他資歷超電，高中數學全國賽一等、大學 ICPC 有出國、去年的 GCJ 還打得比我好orz<br>然後演講居然也是分享題目而不是單純介紹產品，蠻有趣的。<br>雖然題目都好難喔，如果真的是公司的面試題的話那我覺得我畢業後就要失業了（</p>
<h2 id="圖論"><a href="#圖論" class="headerlink" title="圖論"></a>圖論</h2><p>圖論有分基礎圖論跟進階圖論，可是進階圖論的東西幾乎都是我不熟的，所以我就沒有要去基礎圖論。<br>一開始直接介紹 dominator tree，怕。<br>IONC 有講過，可是之後每次我想要去翻都沒搞懂。今天再次遇到後…<br>我還是沒搞懂。<br>那些引理不配上畫圖真的好難理解，然後他又直接飛過去。<br>只好之後再翻翻看講義了。（有朝一日）</p>
<p>後面的東西就懂一點，KM 終於嘗試理解他在幹麻，只是沒完全理解。<br>之後又進到了 matroid，選訓聽教授講這個的時候我聽到後面直接放棄做自己的事。<br>今天也是zzz 我覺得我對這種抽象的東西好沒輒，感覺是時候考慮轉文組。</p>
<h2 id="個人賽"><a href="#個人賽" class="headerlink" title="個人賽"></a>個人賽</h2><p>超級燒雞@@<br>開場後先找flag（x，只是把所有題目看過後也沒有找到。<br>然後看記分板發現 pC 很多人做，就去看了。<br>一開始覺得可能是直接兩個一起排序，可是範測就錯。然後就開始想各種分正負的 case，但是都沒結果。<br>時間過了半個小時我還 0 分，所以決定先跳題。<br>另一題很多人做的是一眼就知道 SCC 縮成 DAG 後亂做的題目，可是我眼幹沒發現題目是 DAG，所以寫了 kosaraju 還寫爛，花了一些時間 debug。<br>已經快一個小時才把這題拿到手，在上傳前記分板已經有超過 4, 50 個人有分數了，心態頗慌，甚至在想會不會被助教關切(</p>
<p>後來去先戳了另一題有人做的，先隨便亂假解一頓之後就發現是線段樹就好，然後寫完之後蠻順利沒什麼 bug 就過了。<br>只是 zkw 居然忘記要開 2 倍空間，好好笑。<br>後來真的照正負亂做才把那題 pC 寫掉。</p>
<p>賽後發現 pC 真的是兩個排序就弄好了，我到底為啥會沒過範測，超怪。<br>開場過於緊張，中間左右才開始把腦袋找回來。<br>pA 題目名稱是簡單數學，然後的確也蠻多人做出來的，可是我真的不會數學QQ<br>數學好難。<br><img src="day2_scoreboard.png" alt="Day 2 scoreboard"></p>
<p>明天又是組合賽局 想到就累。</p>
<h1 id="Day-3"><a href="#Day-3" class="headerlink" title="Day 3"></a>Day 3</h1><p>今天起床後更累了，因為昨天在想贊助商的題目想到兩點多才睡，作息越來越慘了。<br>今天的課是組合賽局跟 DP 跟團體賽。</p>
<h2 id="組合賽局"><a href="#組合賽局" class="headerlink" title="組合賽局"></a>組合賽局</h2><p>其實意外的不會太難跟，講師把 hackenbush 拿掉了，那個去年完全聽不懂的部份。<br>中間有點小落後所以用跑的追上來，後面就比較沒什麼跟不上了。<br>今年也終於聽懂了 coin game，雖然也是花很多時間想才想通。<br>今年比去年聽懂不少東西還蠻開心的&gt;&lt;</p>
<h2 id="贊助商-1"><a href="#贊助商-1" class="headerlink" title="贊助商"></a>贊助商</h2><p>今天也有贊助商演講，然後他是進來講解了在圖論上的某個演算法。<br>原來競程這些圖論的怪東西實務上是真的有機會用到的，雖然比較可惜的是他講英文我聽不太懂。</p>
<h2 id="動態規劃"><a href="#動態規劃" class="headerlink" title="動態規劃"></a>動態規劃</h2><p>基礎的動態規劃直接從轉移優化開始講，然後把什麼優化技巧通通講完了，怕。<br>但是看到進階的好像是在講題目，所以就還是來進階的了。</p>
<p>結果進階的 DP 超棒。<br>很快就能理解到這堂課是丟題目然後讓大家一起思考，後來再把解答給出來，有點開放或者互動式的感覺(?<br>蠻喜歡這種上課方式的，比起亂塞東西然後一直花力氣只為了跟上課程，這樣子有真的在動腦思考。<br>講師也有適當的指引大家，雖然我還是有很多題目沒有完全搞懂。<br>不過想題目的過程果然比較有趣，比起學東西來說。</p>
<p>原本我是進階跟基礎的 google meet 都有開，可是在進階 dp 抽人上來講題目的時候我被抽到，然後我不小心開到了基礎 dp 那邊的麥克風講話，所以基礎 dp 的講師上課直接被打斷，我好抱歉QQ</p>
<p>不過感覺 IOIC 的日程很趕，所以感覺這種課比較適合放在時間比較多的資芽(?，但其實我也不知道這種上課方式放在這邊是不是好的，可能也只是我上了這麼多步調超快的趕火車課程第一次在營隊遇到這種節奏慢很多的。</p>
<h2 id="團體賽"><a href="#團體賽" class="headerlink" title="團體賽"></a>團體賽</h2><p>頗燒雞的。<br>不知道為啥這幾天的比賽都打得不是很好zzz<br>一開始笨到把隊友的想法打掉，後面自己寫到一半才發現隊友的想法才是對的。<br>或者是隊友提出了一個作法之後我覺得他假解所以不相信他，後面自己花了更多時間想了之後才發現我想的作法跟他是一樣的。</p>
<p>把簡單題開完之後就來寫斜率優化跟 segment tree beats。<br>斜率優化這題因為限制了範圍所以李超會變兩個 log，感覺應該是要讓人寫單調隊列的線性作法。<br>然後就花了一個小時了。<br>因為我完全忘記單調隊列在遇到會過期點的時候不能直接 pop_back，要先考慮過期點的位置。<br>感覺很久以前也被坑過，可是真的是太久以前的導致忘光光。<br>甚至還是把 code 拿給隊友 debug 才被指出會有過期點的問題。<br>原來今天的基礎 DP 有教，結果我什麼都不會反而還去進階，爛死了。</p>
<p>終於把斜率優化弄完後，只剩下半個小時多。<br>有一題看幾眼就覺得是 segment tree beats，可是看到過得隊伍有將近 20 隊，懷疑了一陣子。<br>但是覺得不太可能是其他的，所以就寫下去了。<br>然後就 debug 到天荒地老，最後只是一行的變數賦值沒弄好，然後賽中賽後共花了一個多小時在這題。<br>導致今天根本沒什麼時間想其他題，時間都在模板題被浪費掉了@@</p>
<p>因為沒把 beats 寫出來，所以名次也是遠到快要離開了銀河系。<br>快要墊底的第 19 名，爛到笑。<br>對隊友很抱歉，自己拿了兩題裸題結果花了快一輩子甚至還有一題沒寫出來。讓他們抄模板感覺都還比較好。<br><img src="day3_scoreboard.png" alt="Day 3 scoreboard"></p>
<p>明天是計算幾何跟字串，基本上都不是我這次營隊想要來學習的重點，所以就大概聽一下吧(?</p>
<h1 id="Day-4"><a href="#Day-4" class="headerlink" title="Day 4"></a>Day 4</h1><p>昨天補題補到三點多，今天起床爆幹累。<br>發現昨天的 DP 是我會的題目@@，真的就是被斜率優化跟 segment tree beats 搞太久。</p>
<p>今天是字串跟計幾還有個人賽。</p>
<h2 id="字串"><a href="#字串" class="headerlink" title="字串"></a>字串</h2><p>表訂上可能是早上計幾，可是計幾講師的肝快爆了，所以就調課了。<br>因為昨天真的太晚睡導致今天太晚起床，進了 meet 已經是快九點半了，好好笑。<br>幸好前面在講已經會的 KMP 所以還好。</p>
<p>後面開始講了 Z algorithm，今天終於把這東西搞懂了 OAO，之前因為想說 KMP 和 hash 夠用所以就很懶得學這東西。<br>因為聽懂了 Z，所以後面的 manacher 也終於理解了，到目前為止我 manacher 真的都是直接死背 code，笑死。<br>後面講了 Suffix Array，我之前只有把構造 SA 的地方看完，今天也把 LCP 怎麼求給學會了。<br>吸收到東西的感覺還不錯(?，只是後面在講後綴平衡樹的時候我感覺有點中毒了，現在看到 SA 都會想要用這東西。</p>
<h2 id="計算幾何"><a href="#計算幾何" class="headerlink" title="計算幾何"></a>計算幾何</h2><p>最怕的單元，四模時搞一題計幾搞了一大票時間拿了 0 分之後就根本沒什麼去碰計幾了。<br>今年的內容蠻酷的，前面有些觀念補正(?)，後面講解了幾題酷酷題目，我真的沒什麼讀計幾，所以看到大部份題目我都不會做。<br>不過感覺自己還是沒辦法喜歡上計幾= =;，還是覺得計幾很討厭，尤其我幾何超爛，很多二維平面的幾何模型我都沒辦法在腦中想像。</p>
<h2 id="個人賽-1"><a href="#個人賽-1" class="headerlink" title="個人賽"></a>個人賽</h2><p>開場看到一個賽局，打表打出來後看了五分鐘還沒看到規律就跳題了。<br>後來就跟著記分板開題，然後吃了一堆 penalty，不知道為啥這幾天開場都沒很順。<br>把題目跟完之後，手上剩兩題相對可作的：很多人過得賽局跟一題計算幾何。<br>因為賽局我真的不會，所以只好硬著頭皮寫了計幾。<br>結果整場連範測都沒過，賽後把範測丟到 ggb 後再對照一下就找到問題了zzz，然後就一發 AC。<br>賽中沒把範測畫出來有點虧，雖然手畫的圖要是不準感覺不會有幫助。<br>因為賽局幾乎全世界都寫出來了，所以沒寫出來賽局然後計幾也沒搞出來的我當然名次就在世界的底層。</p>
<p>明天就是正式賽了，希望我不要太雷。</p>
<h1 id="Day-5"><a href="#Day-5" class="headerlink" title="Day 5"></a>Day 5</h1><p>今天就只有團體正式賽，比五個小時。</p>
<p>燒雞燒的超級慘，看著越來越多人過了賽局，我就覺得我必須要寫出來。<br>可是打表出來後看起來很有特殊的 pattern 但是我找不到確切的規律。<br>然後就花了一個小時。<br>線段樹的題目也是一開場先做，作到一半發現合併的時候要維護四個答案好麻煩就先丟掉了，後面把他撿回來做但還是覺得好麻煩就又丟掉了。<br>心態很差所以看到裸的 SA 題目就沒有想要自己刻了，直接把講義拿來抄，雖然一發 AC 了但心態沒好轉太多。<br>最後面沒題目可以寫的時候去摸了計算幾何，結果想先寫個部份分卻一直 WA。<br>五個小時一下子就沒了，整場就在燒雞中度過，連鍵盤都沒什麼摸到。<br>最後收尾甚至在真的倒數幾名，讓我覺得我這幾天到底學到了什麼，突然多出了一堆人把我打爆。</p>
<h1 id="總結"><a href="#總結" class="headerlink" title="總結"></a>總結</h1><p>這次的營隊還是很有趣的啦，找 flag 的活動也蠻有創意的。<br>課程有聽懂一些東西蠻開心的，也知道了不少新科技可以學。<br>整體來說課程部份還是很不錯的。<br>只是題目部份除了第一天以外不是很滿意（<br>可能是我太爛只好抱怨題目吧，被很多題目卡導致都沒時間去想一些酷酷的 DP 之類的題目。<br>第一天趣味賽的題目真的蠻有趣的，玩得很開心。</p>
<p>隊友都是分別是一個高一的跟高二的，也才意識到自己老了，突然多了一堆後輩把我揍爛。<br>想說我應該能夠在團體賽的過程中教點他們什麼，結果都是我自己在燒雞甚至得他們來幫我zzz<br>雖然因為線上沒什麼認識什麼人有點可惜，去年實體的時候太害羞了不敢去找不認識的人。<br>明年不知道會不會再來一次，搞不好上了大學之後沒時間或者沒餘裕這樣投住在競賽上面，但希望能夠趁著高中階段變強一點，不要像這樣一直被打爆（</p>
]]></content>
      <tags>
        <tag>Competitive Programming</tag>
        <tag>experience</tag>
        <tag>IOIC</tag>
      </tags>
  </entry>
  <entry>
    <title>vimrc</title>
    <url>/vimrc/</url>
    <content><![CDATA[<p>這裡會紀錄我目前的 vimrc 配置，並且說明他們的功用。</p>
<span id="more"></span>

<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>因為總覺得自己還有好多相關的語法沒學，所以我的 vimrc 顯得特別簡單（<br>發這篇文的目的大概就是提醒自己要去學一些 vim script 等等的語法，順便做個筆記，之後要是看不懂某些地方的時候可以回來看。<br>因為我也似懂非懂的，如果內容有誤還請告知&gt;&lt;<br>這篇文預計會是持續維護的，在我的 vimrc 有什麼更動的時候都會更新這篇文<del>（如果我還記得的話）</del>。</p>
<h1 id="什麼是-vimrc？"><a href="#什麼是-vimrc？" class="headerlink" title="什麼是 vimrc？"></a>什麼是 vimrc？</h1><p>首先要說道 vim。vim 是一個歷史悠久的文字編輯器，其好用地方在於有許多獨特的快捷鍵讓你可以不用滑鼠就作到很多工作。<br>而另一個知名的特色就是高度自訂性的設定檔，也就是 vimrc。<br>這篇只會針對 vimrc，並不會涉及 vim 的操作等等內容。</p>
<h1 id="vimrc"><a href="#vimrc" class="headerlink" title="vimrc"></a>vimrc</h1><p>廢話不多說，先上本體。</p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line"><span class="keyword">set</span> nocompatible</span><br><span class="line"></span><br><span class="line"><span class="comment">&quot; Plugins</span></span><br><span class="line"><span class="keyword">call</span> plug#begin(<span class="string">&#x27;~/.vim/plugged&#x27;</span>)</span><br><span class="line"></span><br><span class="line">Plug <span class="string">&#x27;octol/vim-cpp-enhanced-highlight&#x27;</span></span><br><span class="line"><span class="comment">&quot; Plug &#x27;yuttie/comfortable-motion.vim&#x27;</span></span><br><span class="line"><span class="comment">&quot; Plug &#x27;itchyny/lightline.vim&#x27;</span></span><br><span class="line">Plug <span class="string">&#x27;godlygeek/tabular&#x27;</span></span><br><span class="line">Plug <span class="string">&#x27;plasticboy/vim-markdown&#x27;</span></span><br><span class="line">Plug <span class="string">&#x27;lervag/vimtex&#x27;</span></span><br><span class="line">Plug <span class="string">&#x27;preservim/nerdtree&#x27;</span></span><br><span class="line">Plug <span class="string">&#x27;morhetz/gruvbox&#x27;</span></span><br><span class="line">Plug <span class="string">&#x27;tomasr/molokai&#x27;</span></span><br><span class="line">Plug <span class="string">&#x27;fmoralesc/molokayo&#x27;</span></span><br><span class="line">Plug <span class="string">&#x27;rlue/vim-barbaric&#x27;</span></span><br><span class="line">Plug <span class="string">&#x27;vim-airline/vim-airline&#x27;</span></span><br><span class="line">Plug <span class="string">&#x27;vim-airline/vim-airline-themes&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">call</span> plug#end()</span><br><span class="line"></span><br><span class="line"><span class="comment">&quot; basic configurations</span></span><br><span class="line"><span class="keyword">set</span> <span class="keyword">cb</span>^=unnamedplus,unnamed</span><br><span class="line"><span class="keyword">set</span> <span class="keyword">ts</span>=<span class="number">4</span> <span class="comment">&quot; tabstop=4</span></span><br><span class="line"><span class="keyword">set</span> <span class="keyword">sw</span>=<span class="number">4</span> <span class="comment">&quot; shiftwidth=4</span></span><br><span class="line"><span class="keyword">set</span> <span class="keyword">ls</span>=<span class="number">2</span> <span class="comment">&quot; laststatus=2</span></span><br><span class="line"><span class="keyword">set</span> cul <span class="comment">&quot; cursorline</span></span><br><span class="line"><span class="keyword">set</span> ai <span class="comment">&quot; autoindent</span></span><br><span class="line"><span class="keyword">set</span> <span class="keyword">is</span> <span class="comment">&quot; incsearch</span></span><br><span class="line"><span class="keyword">filetype</span> plugin <span class="built_in">indent</span> <span class="keyword">on</span></span><br><span class="line"><span class="keyword">set</span> hls <span class="comment">&quot; hlsearch</span></span><br><span class="line"><span class="keyword">set</span> rnu <span class="comment">&quot; relativenumber</span></span><br><span class="line"><span class="keyword">set</span> showcmd</span><br><span class="line"><span class="keyword">syntax</span> enable</span><br><span class="line"><span class="comment">&quot; colo ???</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&quot; additional configurations</span></span><br><span class="line"><span class="keyword">colo</span> molokayo</span><br><span class="line"><span class="keyword">let</span> <span class="variable">g:airline_theme</span>=<span class="string">&#x27;molokai&#x27;</span></span><br><span class="line"><span class="keyword">set</span> mouse=n</span><br><span class="line"><span class="keyword">set</span> autochdir</span><br><span class="line"><span class="keyword">set</span> ttimeoutlen=<span class="number">0</span></span><br><span class="line"><span class="comment">&quot; enable powerline symbols</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">g:airline_powerline_fonts</span> = <span class="number">1</span></span><br><span class="line"><span class="comment">&quot; do not hightlight my function</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">g:cpp_no_function_highlight</span> = <span class="number">1</span></span><br><span class="line"><span class="comment">&quot; vim markdown settings</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">g:vim_markdown_math</span> = <span class="number">1</span></span><br><span class="line"><span class="comment">&quot; enhanced highlight issue</span></span><br><span class="line"><span class="keyword">let</span> c_no_curly_error = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&quot; keymaps</span></span><br><span class="line"><span class="keyword">autocmd</span> <span class="keyword">filetype</span> cpp <span class="keyword">nnoremap</span> <span class="symbol">&lt;F9&gt;</span> :<span class="keyword">w</span> <span class="symbol">&lt;bar&gt;</span> !g++ -std=<span class="keyword">c</span>++<span class="number">17</span> % -<span class="keyword">o</span> %:r -Wall -Wextra -Wconversion -Wshadow -fsanitize=undefined -fsanitize=address <span class="symbol">&lt;CR&gt;</span></span><br><span class="line"><span class="keyword">autocmd</span> <span class="keyword">filetype</span> cpp <span class="keyword">nnoremap</span> <span class="symbol">&lt;F10&gt;</span> :!./%:r <span class="symbol">&lt;CR&gt;</span></span><br><span class="line"><span class="keyword">autocmd</span> <span class="keyword">filetype</span> cpp <span class="keyword">nnoremap</span> <span class="symbol">&lt;C-C&gt;</span> :s/^\(\s*\)/\<span class="number">1</span>\/\/<span class="symbol">&lt;CR&gt;</span> :s/^\(\s*\)\/\/\/\//\<span class="number">1</span><span class="symbol">&lt;CR&gt;</span> $</span><br><span class="line"><span class="keyword">inoremap</span> &#123; &#123;&#125;<span class="symbol">&lt;Left&gt;</span></span><br><span class="line"><span class="keyword">inoremap</span> &#123;<span class="symbol">&lt;CR&gt;</span> &#123;<span class="symbol">&lt;CR&gt;</span>&#125;<span class="symbol">&lt;Esc&gt;</span>O</span><br><span class="line"><span class="keyword">inoremap</span> &#123;&#123; &#123;</span><br><span class="line"><span class="keyword">inoremap</span> &#123;&#125; &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">&quot; latex keymaps</span></span><br><span class="line"><span class="keyword">autocmd</span> <span class="keyword">filetype</span> tex <span class="keyword">nnoremap</span> <span class="symbol">&lt;F9&gt;</span> :<span class="keyword">w</span> <span class="symbol">&lt;bar&gt;</span> :!xelatex % <span class="symbol">&lt;CR&gt;</span></span><br><span class="line"><span class="keyword">autocmd</span> <span class="keyword">filetype</span> tex <span class="keyword">nnoremap</span> <span class="symbol">&lt;F10&gt;</span> :!okular %:r.pdf <span class="symbol">&lt;CR&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&quot; Set true color</span></span><br><span class="line"><span class="keyword">let</span> &amp;t_8f=<span class="string">&quot;\&lt;Esc&gt;[38;2;%lu;%lu;%lum&quot;</span></span><br><span class="line"><span class="keyword">let</span> &amp;t_8b=<span class="string">&quot;\&lt;Esc&gt;[48;2;%lu;%lu;%lum&quot;</span></span><br><span class="line"><span class="keyword">set</span> termguicolors</span><br><span class="line"></span><br><span class="line"><span class="comment">&quot; NERDTree settings</span></span><br><span class="line"><span class="comment">&quot; F5 to toggle and put the cursor back in the othe window.</span></span><br><span class="line"><span class="keyword">nnoremap</span> <span class="symbol">&lt;F5&gt;</span> :NERDTreeToggle \| <span class="keyword">wincmd</span> <span class="keyword">p</span><span class="symbol">&lt;CR&gt;</span></span><br><span class="line"><span class="comment">&quot; Start NERDTree and put the cursor back in the other window.</span></span><br><span class="line"><span class="keyword">autocmd</span> VimEnter * NERDTree | <span class="keyword">wincmd</span> <span class="keyword">p</span></span><br><span class="line"><span class="comment">&quot; Exit Vim if NERDTree is the only window remaining in the only tab.</span></span><br><span class="line"><span class="keyword">autocmd</span> BufEnter * <span class="keyword">if</span> <span class="built_in">tabpagenr</span>(<span class="string">&#x27;$&#x27;</span>) == <span class="number">1</span> &amp;&amp; <span class="built_in">winnr</span>(<span class="string">&#x27;$&#x27;</span>) == <span class="number">1</span> &amp;&amp; <span class="built_in">exists</span>(<span class="string">&#x27;b:NERDTree&#x27;</span>) &amp;&amp; <span class="variable">b:NERDTree</span>.isTabTree() | <span class="keyword">quit</span> | <span class="keyword">endif</span></span><br><span class="line"><span class="comment">&quot; Close the tab if NERDTree is the only window remaining in it.</span></span><br><span class="line"><span class="keyword">autocmd</span> BufEnter * <span class="keyword">if</span> <span class="built_in">winnr</span>(<span class="string">&#x27;$&#x27;</span>) == <span class="number">1</span> &amp;&amp; <span class="built_in">exists</span>(<span class="string">&#x27;b:NERDTree&#x27;</span>) &amp;&amp; <span class="variable">b:NERDTree</span>.isTabTree() | <span class="keyword">quit</span> | <span class="keyword">endif</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">g:NERDTreeWinSize</span>=<span class="number">20</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&quot; Refresh defaut code</span></span><br><span class="line"><span class="keyword">autocmd</span> <span class="keyword">filetype</span> cpp command! New <span class="keyword">execute</span> <span class="string">&quot;%d|r ~/Programming/template/default.cpp|1d|41&quot;</span></span><br><span class="line"><span class="comment">&quot; Copy current file to clipboard</span></span><br><span class="line"><span class="keyword">command</span> Copy <span class="keyword">execute</span> <span class="string">&quot;w|!wl-copy &lt; %&amp;&amp;echo \&quot;Copy done successfully\&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&quot; encoding</span></span><br><span class="line"><span class="keyword">set</span> fileencodings=ucs-bom,utf-<span class="number">8</span>,cp932,gb18030,gbk,gb2312,cp936</span><br><span class="line"><span class="keyword">set</span> termencoding=utf-<span class="number">8</span></span><br><span class="line"><span class="keyword">set</span> encoding=utf-<span class="number">8</span></span><br></pre></td></tr></table></figure>

<h1 id="說明"><a href="#說明" class="headerlink" title="說明"></a>說明</h1><p>我其實是有分區的，所以就按照這樣的分區來寫。</p>
<h2 id="關閉相容"><a href="#關閉相容" class="headerlink" title="關閉相容"></a>關閉相容</h2><p><code>set nocompatible</code><br>因為 Vim 的全名是 Vi IMproved，所以 Vim 其實會跟 Vi 的操作去相容。<br>不過這也導致有些 Vim 的功能會被關掉（或發生奇怪的現象）。<br>除非是要執行古老的 Vi script 之類的，不然通常都關掉比較好。<br>基本上不加這行也可以，因為 Vim 的文件有說道當偵測到 .vimrc 的存在的時候就會自動打開。<br>除了像是使用 -u 標籤來指定 vimrc 之類的時候就不自動打開。<br>為了不必要的困擾所以我還是會留著這行。<br><em><strong>記得把這行放在 vimrc 第一行</strong></em></p>
<h2 id="Plugins"><a href="#Plugins" class="headerlink" title="Plugins"></a>Plugins</h2><p>vim 還有一個很強大的特色就是除了 vimrc 以外你還能夠引入第三方的插件來讓整個編輯器變得更好用。<br>這邊其實很大部份都是抄來的，因為我很懶得自己去找有哪些插件可以用（X<br>如果你覺得有什麼一定要裝的插件可以分享給我ww<br>因為比賽通常是不會有這些插件的，所以我會盡量避免使用一些如 auto completion 等等會方便打字的，避免比賽的時候變得不會用鍵盤。<br>然後考慮到底下的設定可能會是在設定這些插件，跟寫程式一樣通常要先宣告有這個插件才能去設定，所以就把插件擺到前面。</p>
<h3 id="vim-plug"><a href="#vim-plug" class="headerlink" title="vim-plug"></a>vim-plug</h3><p>插件可以自己亂裝，但是在插件很多的時候還是有一個 plugin manager 會比較好。<br>我這裡是選用 vim-plug，原因是當初查到的第一篇教學文就是用這個。</p>
<ul>
<li><a href="https://github.com/octol/vim-cpp-enhanced-highlight">cpp enhanced highlight</a>：為 C++ 的 STL 上色，至少讓整個 code 變得比較生動(? 雖然他蠻笨的，比如他會把一堆關鍵字上色然後有些變數命名明明是不會編譯錯誤的但他就是有特殊的顏色。</li>
<li><a href="https://github.com/yuttie/comfortable-motion.vim">comfortable motion</a>：比較舒服的滾動(? 雖然我根本沒在用他</li>
<li><a href="https://github.com/itchyny/lightline.vim">lightline</a>：很酷的狀態列，但是自從用了 airline 之後就沒用他了。</li>
<li><a href="https://github.com/godlygeek/tabular">Tabular</a>：排版用，不是寫程式時的縮排，在編輯一般的文字檔的時候比較好用。</li>
<li><a href="https://github.com/preservim/vim-markdown">vim markdown</a>：highlight markdown 的語法，並且提供一些酷酷的快捷鍵與指令。</li>
<li><a href="https://github.com/lervag/vimtex">vimtex</a>：hightlight latex 的語法，然後還有數不清的功能。</li>
<li><a href="https://github.com/preservim/nerdtree">nerdtree</a>：以樹狀形式顯示資料夾，幾乎所有 IDE 配有的功能現在在 vim 也有了！</li>
<li><a href="https://github.com/morhetz/gruvbox">gruvbox</a>：很棒的 colorschmee，可是我還是比較喜歡 molokayo。</li>
<li><a href="https://github.com/fmoralesc/molokayo">molokayo</a>：目前在用的 colorscheme，算是 molokai 的加強版。</li>
<li><a href="https://github.com/rlue/vim-barbaric">barbaric</a>：寫程式的時候都是英文的所以沒感覺，但是在寫 blog 或者 latex 等等的時候就會發現了，vim 在從 insert mode 進到 normal mode 的時候只要按 Esc 就好，可是輸入法不會變！所以在 normal mode 會被卡輸入法導致什麼都做不了，只能先切回英文輸入法，但是在進 insert mode 時又要改成中文輸入法。這個插件就是幫你在進到 normal mode 時換成英文輸入法，但是保留輸入法設定使得進到 insert mode 時會切回原本的輸入法。寫文章神器！</li>
<li><a href="https://github.com/vim-airline/vim-airline">airline</a>：超潮的狀態列，看了心情就好，寫程式有時最需要的就是良好的心情。尤其有裝 powerline 字體的話觀感又更上一層樓。</li>
<li><a href="https://github.com/vim-airline/vim-airline-themes">airline themes</a>：airline 的補充包，裡面有很多內建的主題可以設定。</li>
</ul>
<h2 id="Basic-configurations"><a href="#Basic-configurations" class="headerlink" title="Basic configurations"></a>Basic configurations</h2><p>就是基礎設定。<br>通常是沒有這些東西的話我會不想要用 vim，他們是核心。<br>而我在比賽的時候現場打的 vimrc 大概也就只是這些和底下一些 keymap。</p>
<h3 id="與系統剪貼簿同步"><a href="#與系統剪貼簿同步" class="headerlink" title="與系統剪貼簿同步"></a>與系統剪貼簿同步</h3><p><code>set cb^=unnamedplus,unnamed</code><br>在 vim 的預設中，yank、delete、paste 等操作所使用的 register 都叫 unnamed，也就是所有複製、刪除的操作都會把內容丟到那個 register，貼上也是從這個 register 的內容中拿來用。<br>然而這個 register 跟系統的剪貼簿是不一樣的，所以在 vim 複製的東西沒辦法貼到其他地方去，也沒辦法把其他地方複製下來的內容貼到 vim 上。<br>解決方法是在使用指令的時候都去指定 register，可是這樣很麻煩。<br>所以我們可以直接把系統的剪貼簿綁到 unnamed 這個 register，這樣就能把 vim 與系統的剪貼簿同步了。</p>
<p>而 unnamed 跟 unnamedplus 在 windows/macOS 是一樣的，但是在 linux 的 X11 底下會有兩個剪貼簿，所以有必要把兩個都指定起來（當然也可以不指定其中一個，更詳細的這邊就不提了）。<br>然而在 linux 的 wayland 底下有沒有這行好像都一樣會沒辦法同步，查網路的結果好像是無解，目前我都是用 terminal 內建的剪貼功能去處理這部份的。（不過比賽的環境還是大部分都 X11，所以還是有用）</p>
<h3 id="設置-tab-以及縮排寬度"><a href="#設置-tab-以及縮排寬度" class="headerlink" title="設置 tab 以及縮排寬度"></a>設置 tab 以及縮排寬度</h3><p><code>set tabstop=4</code><br><code>set shiftwidth=4</code><br>寫程式的時候往往都會用 tab 去做縮排，使用這兩個可以使得 tab 鍵與系統的 shift 功能（快捷鍵：&gt;&gt;）的寬度都是 4 格。</p>
<h3 id="狀態列表"><a href="#狀態列表" class="headerlink" title="狀態列表"></a>狀態列表</h3><p><code>set laststatus=2</code><br>讓右下角的狀態列表永遠開著，預設是只有在開多個 tab 的時候才會顯示出來當作分界線，但是我覺得這個的資訊量很大所以應該要隨時開著。</p>
<h3 id="游標所在行"><a href="#游標所在行" class="headerlink" title="游標所在行"></a>游標所在行</h3><p><code>set cursorline</code><br>把游標所在的這行給標上底線，在文字量龐大的時候常常會找不到到游標在哪裡，有了這行基本上就很容易找到了。</p>
<h3 id="自動縮排"><a href="#自動縮排" class="headerlink" title="自動縮排"></a>自動縮排</h3><p><code>filetype plugin indent on</code><br><code>set autoindent</code><br>vim 預設會給一些常見語言自己的縮排設定，所以透過上面那行直接讓他偵測目前檔案類型並套用特定縮排。<br>下面那行是單純的在建立新行的時候（Enter、<code>O</code> 鍵等等…）會沿用前一行的縮排。<br>兩者一起用似乎是上面那行的設定（如果有設定檔的話）會蓋掉下面那行，所以應該是不會出事。</p>
<h3 id="強化搜尋功能"><a href="#強化搜尋功能" class="headerlink" title="強化搜尋功能"></a>強化搜尋功能</h3><p><code>set incsearch</code><br><code>set hlsearch</code><br><code>incearch</code> 是會在搜尋時於打字過程中就幫你跳轉畫面到當下的搜尋結果，而不用等到按下 enter 鍵再跳轉。<br><code>hlsearch</code> 會把搜尋到的字串都標上 highlight（不懂為什麼預設會沒有 highlight，超反人性），如果搜尋完想要把 highlight 關掉就打 <code>:noh</code> 即可。</p>
<h3 id="相對行號"><a href="#相對行號" class="headerlink" title="相對行號"></a>相對行號</h3><p><code>set relativenumber</code><br>理論上我們會很自然的在左側顯示當前第幾行，可是 vim 有很多快捷鍵是需要去指定要作用幾行的（比如刪除等等），所以我覺得顯示相對行數會比較方便，設定之後左邊會變成從 0 開始，往上往下分別是 1 2 3…。</p>
<h3 id="顯示當前指令"><a href="#顯示當前指令" class="headerlink" title="顯示當前指令"></a>顯示當前指令</h3><p><code>set showcmd</code><br>vim 的很多快捷鍵是有多個字母的，尤其是那些可以指定次數的（比如 <code>2dd</code>、<code>3yy</code> 等等）。<br>設定了這個會在輸入快捷鍵的過程中把目前輸入的東西顯示在右下角，就可以邊打快捷鍵邊確認有沒有不小心按到什麼鍵了。</p>
<h3 id="hightlight-colorscheme"><a href="#hightlight-colorscheme" class="headerlink" title="hightlight, colorscheme"></a>hightlight, colorscheme</h3><p><code>syntax enable</code><br><code>colorscheme ???</code><br>上面就是會對每個語言的關鍵字上色，算是必備東西了吧。<br>下面則是可以自訂不同的 colorscheme，vim 裡面有內建了一些也可以自己裝。<br>因為我在下面有自己裝，所以我這邊就沒有要使用預設的 colorscheme，可是我還是佔一個行來提醒我比賽的時候要去設定 colorscheme。</p>
<h2 id="additional-configurations"><a href="#additional-configurations" class="headerlink" title="additional configurations"></a>additional configurations</h2><p>建立在 basic configurations 之上的其他設定，主要就是沒有到太重要所以不會在比賽的時候把他打出來。</p>
<h3 id="molokai"><a href="#molokai" class="headerlink" title="molokai"></a>molokai</h3><p><code>colo molokayo</code><br>優質 colorscheme。<br>因為我是用 plugin 去裝這個 colorscheme 的，所以記得這行必須放在 <code>plug molokayo</code> 的下面。</p>
<h3 id="airline-主題"><a href="#airline-主題" class="headerlink" title="airline 主題"></a>airline 主題</h3><p><code>let g:airline_theme=&#39;molokai&#39;</code><br>這個是從 ‘vim-airline-theme’ 來的，屬於這個插件其中一個內建主題。<br>既然 colorscheme 都用 molokai 了，這個的乾脆就設一樣搞不好能夠讓整體變得一致。</p>
<h3 id="設定滑鼠作用範圍"><a href="#設定滑鼠作用範圍" class="headerlink" title="設定滑鼠作用範圍"></a>設定滑鼠作用範圍</h3><p><code>set mouse=n</code><br>比如滑鼠點擊左鍵的時候要不要移動游標到點擊的位置。<br>可以用 n(Normal), i(Insert), c(Command), v(Visual), a(All)，分別對應到不同的模式。<br>預設是 a，但是我覺得在打字的時候手會不小心碰到觸控板，然後游標就亂跑，很煩。<br>所以就改成在 Normal 的時候才使用，不過其實我很少用到滑鼠來移動游標所以這行其實應該甚至可以改成 <code>set mouse=</code> 代表完全不要讓他作用。</p>
<h3 id="自動切換所在目錄"><a href="#自動切換所在目錄" class="headerlink" title="自動切換所在目錄"></a>自動切換所在目錄</h3><p><code>set autochdir</code><br>當你打了類似 <code>vim a/b.cpp</code> 時，你會發現你的目錄其實還是在 a 的父目錄（也就是執行 vim 指令的資料夾），可以用 <code>:pwd</code> 指令查看（也可以使用外部的 linux 指令 <code>:!pwd</code>）當前所在的資料夾。<br>意思就是你可能做另存新檔之類的操作的時候是會在 a 外面而不是在 a 的那個資料夾的。令一個例子可能是在編譯的時候編譯器可能會把編譯出來的執行檔丟到當前的目錄，此時就有可能會程式碼跟執行檔放的位置不一樣。<br>這樣很麻煩，所以用了這行就能讓 vim 自動把當前目錄轉到你開的那個檔案的那邊。</p>
<h3 id="關掉組合鍵的等待時間"><a href="#關掉組合鍵的等待時間" class="headerlink" title="關掉組合鍵的等待時間"></a>關掉組合鍵的等待時間</h3><p><code>set ttimeoutlen=0</code><br>在 barbaric 插件於我切換模式時幫我自動切換輸入法時，他會有些許延遲（觸發切換輸入法的那個操作）。<br>所以從 insert 切換到 normal 的時候我是有可能會被卡中文輸入法卡一小段時間的。<br>推測原因是在按下 ESC 時，因為 ESC 後面的組合鍵太多了，所以會有一段等待輸入後面的鍵的時間。<br>在 barbaric 的 README.md 中有提到這行可以把這個的等待時間關掉，也就會沒有延遲了。</p>
<h3 id="一些變數"><a href="#一些變數" class="headerlink" title="一些變數"></a>一些變數</h3><figure class="highlight vim"><table><tr><td class="code"><pre><span class="line"><span class="comment">&quot; enable powerline symbols</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">g:airline_powerline_fonts</span> = <span class="number">1</span></span><br><span class="line"><span class="comment">&quot; do not hightlight my function</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">g:cpp_no_function_highlight</span> = <span class="number">1</span></span><br><span class="line"><span class="comment">&quot; vim markdown settings</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">g:vim_markdown_math</span> = <span class="number">1</span></span><br><span class="line"><span class="comment">&quot; enhanced highlight issue</span></span><br><span class="line"><span class="keyword">let</span> c_no_curly_error = <span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>這些都是插件的一些設定<br>第一個是因為我的字體是有支援 powerline 的，所以就可以打開 airline 的這個設定來讓整個畫面變更漂亮。<br>第二個是 cpp enhanced highlight 插件會把你所有的函式都給上色，這樣超怪，因為我只希望他把 STL 有的函式上色，所以可以用這個關掉。<br>第三個是讓 vim markdwon 插件也給數學式上色，考慮到寫的題解常常會需要數學式，所以當然是打開。<br>第四個也是 cpp enhanced highlight 在 README.md 提到的括號上色的錯誤，看到蛋餅有加所以我就跟著加了(X</p>
<h2 id="keymaps"><a href="#keymaps" class="headerlink" title="keymaps"></a>keymaps</h2><p>一些自己定義的快捷鍵，除了 latex 以外大部分都會在比賽的時候也打出來。</p>
<h3 id="C"><a href="#C" class="headerlink" title="C++"></a>C++</h3><p>一些在檔名是 cpp 的時候才會作用的快捷鍵。<br><code>autocmd filetype cpp nnoremap &lt;F9&gt; :w &lt;bar&gt; !g++ -std=c++17 % -o %:r -Wall -Wextra -Wconversion -Wshadow -fsanitize=undefined -fsanitize=address &lt;CR&gt;</code><br>按下 F9 存檔並編譯，執行檔會以去掉副檔名的檔名被丟在原本的資料夾。<br><code>%</code>：當前檔案名稱，<code>%:r</code>：當前檔案名稱並去掉副檔名，<code>&lt;bar&gt;</code>：一個 <code>|</code>，有分隔的作用，可以在一行內執行多個指令，<code>&lt;CR&gt;</code>：換行。<br><code>autocmd filetype cpp nnoremap &lt;F10&gt; :!./%:r &lt;CR&gt;</code><br>按下 F10 執行編譯後的執行檔。<br><code>autocmd filetype cpp nnoremap &lt;C-C&gt; :s/^\(\s*\)/\1\/\/&lt;CR&gt; :s/^\(\s*\)\/\/\/\//\1&lt;CR&gt; $</code><br>這個是從 <a href="https://github.com/tmwilliamlin168/CP-YouTube/blob/master/.vimrc">tmw 的 vimrc</a> 來的，用途是在按下 Ctrl+C 的時候會自動在當前這行加上或取消 // 註解，蠻好用的。</p>
<h3 id="括號補全"><a href="#括號補全" class="headerlink" title="括號補全"></a>括號補全</h3><figure class="highlight vim"><table><tr><td class="code"><pre><span class="line"><span class="keyword">inoremap</span> &#123; &#123;&#125;<span class="symbol">&lt;Left&gt;</span></span><br><span class="line"><span class="keyword">inoremap</span> &#123;<span class="symbol">&lt;CR&gt;</span> &#123;<span class="symbol">&lt;CR&gt;</span>&#125;<span class="symbol">&lt;Esc&gt;</span>O</span><br><span class="line"><span class="keyword">inoremap</span> &#123;&#123; &#123;</span><br><span class="line"><span class="keyword">inoremap</span> &#123;&#125; &#123;&#125;</span><br></pre></td></tr></table></figure>
<p>打左括號會有右括號，打兩次左括號就不會補上右括號。<br>只設定 <code>&#123;</code>，其他的括號一律不補全。</p>
<h3 id="latex"><a href="#latex" class="headerlink" title="latex"></a>latex</h3><p><code>autocmd filetype tex nnoremap &lt;F9&gt; :w &lt;bar&gt; :!xelatex % &lt;CR&gt;</code><br><code>autocmd filetype tex nnoremap &lt;F10&gt; :!okular %:r.pdf &lt;CR&gt;</code><br>F9 編譯，F10 執行，跟 C++ 同理。</p>
<h2 id="設定-truecolor"><a href="#設定-truecolor" class="headerlink" title="設定 truecolor"></a>設定 truecolor</h2><p>truecolor 是 24-bit 的顏色，大概有一千六百萬種顏色，基本上是人眼可辨識的上限了。<br>以前的那些 8 種顏色、16 種顏色、256 種顏色都已經過時了。現在的主流 terminal 基本上都有支援 truecolor 了。<br>首先要先確定你的 terminal 有支援並開啟了 truecolor，可以透過 <a href="https://unix.stackexchange.com/questions/404414/print-true-color-24-bit-test-pattern">這邊提到的方法</a> 去測試。<br>然後就直接照抄下面三行：</p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> &amp;t_8f=<span class="string">&quot;\&lt;Esc&gt;[38;2;%lu;%lu;%lum&quot;</span></span><br><span class="line"><span class="keyword">let</span> &amp;t_8b=<span class="string">&quot;\&lt;Esc&gt;[48;2;%lu;%lu;%lum&quot;</span></span><br><span class="line"><span class="keyword">set</span> termguicolors</span><br></pre></td></tr></table></figure>

<h2 id="NERDTree-設定"><a href="#NERDTree-設定" class="headerlink" title="NERDTree 設定"></a>NERDTree 設定</h2><p>以下全是抄 NERDTree 的 github 的 README.md，那邊還有提到其他設定，只是我覺得不需要就沒用了。</p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line"><span class="comment">&quot; F5 to toggle and put the cursor back in the othe window.</span></span><br><span class="line"><span class="keyword">nnoremap</span> <span class="symbol">&lt;F5&gt;</span> :NERDTreeToggle \| <span class="keyword">wincmd</span> <span class="keyword">p</span><span class="symbol">&lt;CR&gt;</span></span><br><span class="line"><span class="comment">&quot; Start NERDTree and put the cursor back in the other window.</span></span><br><span class="line"><span class="keyword">autocmd</span> VimEnter * NERDTree | <span class="keyword">wincmd</span> <span class="keyword">p</span></span><br><span class="line"><span class="comment">&quot; Exit Vim if NERDTree is the only window remaining in the only tab.</span></span><br><span class="line"><span class="keyword">autocmd</span> BufEnter * <span class="keyword">if</span> <span class="built_in">tabpagenr</span>(<span class="string">&#x27;$&#x27;</span>) == <span class="number">1</span> &amp;&amp; <span class="built_in">winnr</span>(<span class="string">&#x27;$&#x27;</span>) == <span class="number">1</span> &amp;&amp; <span class="built_in">exists</span>(<span class="string">&#x27;b:NERDTree&#x27;</span>) &amp;&amp; <span class="variable">b:NERDTree</span>.isTabTree() | <span class="keyword">quit</span> | <span class="keyword">endif</span></span><br><span class="line"><span class="comment">&quot; Close the tab if NERDTree is the only window remaining in it.</span></span><br><span class="line"><span class="keyword">autocmd</span> BufEnter * <span class="keyword">if</span> <span class="built_in">winnr</span>(<span class="string">&#x27;$&#x27;</span>) == <span class="number">1</span> &amp;&amp; <span class="built_in">exists</span>(<span class="string">&#x27;b:NERDTree&#x27;</span>) &amp;&amp; <span class="variable">b:NERDTree</span>.isTabTree() | <span class="keyword">quit</span> | <span class="keyword">endif</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">g:NERDTreeWinSize</span>=<span class="number">20</span></span><br></pre></td></tr></table></figure>

<h2 id="自訂指令"><a href="#自訂指令" class="headerlink" title="自訂指令"></a>自訂指令</h2><p>就是輸入 <code>:自訂指令</code>，後會做的事情。注意到 vim 規定自訂指令必須是大寫字母為開頭。</p>
<h3 id="自動刷新模板"><a href="#自動刷新模板" class="headerlink" title="自動刷新模板"></a>自動刷新模板</h3><p><code>autocmd filetype cpp command! New execute &quot;%d|r ~/Programming/template/default.cpp|1d|41&quot;</code><br>這是打比賽會用的，在輸入 <code>:New</code> 後會把整份 code 換成比賽用的 defaut code。</p>
<h3 id="複製整個檔案"><a href="#複製整個檔案" class="headerlink" title="複製整個檔案"></a>複製整個檔案</h3><p><code>command Copy execute &quot;w|!wl-copy &lt; %&amp;&amp;echo \&quot;Copy done successfully\&quot;&quot;</code><br>原本在 X11 的情況下我可以直接設定好 clipboard 後就用 <code>:%y</code> 來複製整個檔案的內容，可是在 wayland 會失去作用。<br>後來我是安裝了 <a href="https://archlinux.org/packages/community/x86_64/wl-clipboard/">wl-clipboard</a> 套件，並且使用他的複製指令。</p>
<h2 id="編碼"><a href="#編碼" class="headerlink" title="編碼"></a>編碼</h2><figure class="highlight vim"><table><tr><td class="code"><pre><span class="line"><span class="keyword">set</span> fileencodings=ucs-bom,utf-<span class="number">8</span>,cp932,gb18030,gbk,gb2312,cp936</span><br><span class="line"><span class="keyword">set</span> termencoding=utf-<span class="number">8</span></span><br><span class="line"><span class="keyword">set</span> encoding=utf-<span class="number">8</span></span><br></pre></td></tr></table></figure>
<p>fileencodings 的順序會決定在開啟一個文件時去嘗試的編碼的順序。所以作用範圍越小的要放在越前面。<br>對我來說有被影響的就是之前在開日文的檔案時會出現亂碼，所以我把 ucs-bom 的編碼放到前面就解決了亂碼的問題。其餘都是按照網路上的排法排的。<br>termencoding 是顯示在 terminal 所用的編碼，encoding 是 vim 內部存任何字串時所用的編碼，這兩個設成 utf-8 基本上應該都不會出事。</p>
<h1 id="後記"><a href="#後記" class="headerlink" title="後記"></a>後記</h1><p>這篇文花了我超過 10 個小時orz<br>原本只是想要當個紀錄文用的，結果發現一堆設定我都講不出他在幹麻，所以就花一堆時間查資料。<br>中途又陸陸續續修改了好多地方，總覺得描述的用詞有點不太適當。<br>而且有些東西牽涉的知識太多了，比如 clipboard、縮排相關、ttimeoutlen、truecolor 以及編碼等等內容，希望之後自己變得更熟悉這些東西的時候可以回來補好這些部份。<br>如果有什麼問題或者是建議歡迎告知&gt;&lt;<br>有些東西我也不敢保證我理解的就是對的，所以要是有我在耍低能亂寫的部份也希望能夠告訴我！</p>
<h1 id="參考資料"><a href="#參考資料" class="headerlink" title="參考資料"></a>參考資料</h1><p><a href="https://stackoverflow.com/questions/5845557/in-a-vimrc-is-set-nocompatible-completely-useless">In a .vimrc, is `set nocompatible` completely useless?</a><br><a href="https://www.baeldung.com/linux/vim-registers">vim registers</a><br><a href="https://stackoverflow.com/questions/30691466/what-is-difference-between-vims-clipboard-unnamed-and-unnamedplus-settings">What is difference between Vim’s clipboard “unnamed” and “unnamedplus” settings?</a><br><a href="https://vi.stackexchange.com/questions/11696/what-does-filetype-plugin-on-really-do">What does “filetype plugin on” really do?</a><br><a href="https://omeletwithoutegg.github.io/2020/07/08/Using-Vim/">Using Vim</a><br><a href="https://www.johnhawthorn.com/2012/09/vi-escape-delays/">Eliminating delays on ESC in vim and zsh</a><br><a href="https://stackoverflow.com/questions/22142755/what-is-the-meaning-of-a-cr-at-the-end-of-some-vim-mappings">What is the meaning of a &lt;CR&gt; at the end of some vim mappings?</a><br><a href="https://gist.github.com/XVilka/8346728">True Colour (16 million colours) support in various terminal applications and terminals</a><br><a href="https://zhuanlan.zhihu.com/p/25451437">VIM学习笔记 多编码处理 (Multi-Encodings)</a></p>
]]></content>
      <tags>
        <tag>tutorial</tag>
        <tag>vim</tag>
      </tags>
  </entry>
  <entry>
    <title>TIOJ-1857</title>
    <url>/TIOJ-1857/</url>
    <content><![CDATA[<p>(以下正題開始)<br>剛剛那招「比利電波」是他的其中一招必殺技，能夠瞬間殲滅無數僵屍，但只能在僵屍數量夠多的時候使用。<br>原來這種僵屍有個習性，當他們數量夠多時會排成一種隊伍，<br>構造就像一棵 $H$ 層的滿支二元樹。<br/><br>第一層會有一隻編號 $1$ 的僵屍，每隻編號 $x$ 的僵屍身後都站著一隻編號 $2x$ 和 $2x+1$ 的僵屍，以此類推。也就是說 $1$ ～ $H$ 層總共會有 $2^H-1$ 隻僵屍。<br/><br>比利電波只要攻擊僵屍 $1$，就會從 $1$ 傳給 $2$ 和 $3$，$2$ 再傳給 $4$、$5$，$3$傳給$6$、$7$，…，直到傳完 $H$ 層。<br/><br>不幸的是，有些僵屍能夠某種程度上的抵抗「比利電波」，他們不會被打死而且也不會把電波傳到身後。幸好有些特殊的僵屍和僵屍 $1$ 有聯結，就算前面站的僵屍能抵抗電波，還是會被與 $1$ 同時被電波攻擊，並繼續向後傳下去。<br/><br>聽完了解說，你決定來計算這招總共能消滅多少僵屍，以作為日後對付僵屍的參考。　</p>
<span id="more"></span>
<p>$H\le 63, N\le 10^5$</p>
<hr>
<p>讓我們整理一下題敘，你有一顆 full binary tree，一號節點已經被染紅，每一個被染紅的節點都會把兩個孩子給染紅。並且有兩種特殊節點。</p>
<ol>
<li>無敵節點：他不會被染紅。</li>
<li>紅色節點：他已經被染紅了。</li>
</ol>
<p>最後問有幾個節點被染紅了。</p>
<p>最直接的作法當然就是直接從根開始 dfs，遇到特殊節點就改變狀態。<br>在 $H$ 到很大的時候就會顯得很慢。<br/></p>
<p>回想一下 dfs 的過程，我們處理特殊節點的順序其實是根據他們的深度由淺到深來整理。<br>所以可以直接先把所有特殊節點給按照深度排序（以這題的編號來說，直接排序就可）。<br>並且維護當前的答案，一開始答案是 $2^H-1$，因為所有節點都被一號染紅了。<br/><br>並且假設當前的節點編號是 $x$，我們可以往上找他的祖先，看離他最近的那個特殊節點的種類是不是跟他不同。（$x$ 的祖先會是 $\lfloor\frac{x}{2}\rfloor$）<br/><br>如果不同的話，那 $x$ 為根的整棵子樹的狀態（有沒有被染紅）都會改變，所以答案會增加或減少 $2^{H - dep(x)}-1$，其中 $dep(x)$ 為 $x$ 的深度（$dep(1)=0,dep(2)=dep(3)=1,dep(4)=2\cdots$），而因為這題的特性， $dep(x)=\lfloor \log(x)\rfloor$。</p>
<p>由於每個點最多會有 $H$ 個祖先，且在確認一個點是不是特殊點的時候我們會需要二分搜或平衡樹來在 $\mathcal{O}(\log N)$ 的時間查找。<br/><br>因此整個的時間複雜度就是 $\mathcal{O}(NH\log N)$，有點緊，注意常數。<br/></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">--------------              |   /</span></span><br><span class="line"><span class="comment">      |                     |  /</span></span><br><span class="line"><span class="comment">      |                     | /</span></span><br><span class="line"><span class="comment">      |             *       |/          |    |         ------            *</span></span><br><span class="line"><span class="comment">      |                     |           |    |        /      \</span></span><br><span class="line"><span class="comment">      |             |       |\          |    |       |       |\          |</span></span><br><span class="line"><span class="comment">   \  |             |       | \         |    |       |       | \         |</span></span><br><span class="line"><span class="comment">    \ |             |       |  \        |    |        \     /   \        |</span></span><br><span class="line"><span class="comment">     V              |       |   \        \__/|         -----     \       |</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EmiliaMyWife ios::sync_with_stdio(0); cin.tie(NULL);</span></span><br><span class="line"><span class="keyword">using</span> ll = <span class="keyword">int64_t</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> Lamy_is_cute = []() &#123;</span><br><span class="line">	EmiliaMyWife</span><br><span class="line">	<span class="keyword">return</span> <span class="number">48763</span>;</span><br><span class="line">&#125;();</span><br><span class="line"><span class="comment">/*--------------------------------------------------------------------------------------*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> t;</span><br><span class="line">	cin &gt;&gt; t;</span><br><span class="line">	<span class="keyword">while</span>(t--) &#123;</span><br><span class="line">		<span class="keyword">int</span> h, n;</span><br><span class="line">		cin &gt;&gt; h &gt;&gt; n;</span><br><span class="line">		ll ans = (<span class="number">1LL</span> &lt;&lt; h) - <span class="number">1</span>;</span><br><span class="line">		vector&lt;pair&lt;ll, <span class="keyword">int</span>&gt;&gt; <span class="built_in">arr</span>(n);</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">auto</span> &amp;[a, b] : arr)</span><br><span class="line">			cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line">		<span class="built_in">sort</span>(arr.<span class="built_in">begin</span>(), arr.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line">		set&lt;ll&gt; defense, attack;</span><br><span class="line">		attack.<span class="built_in">insert</span>(<span class="number">1</span>);</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">const</span> <span class="keyword">auto</span> &amp;[a, b] : arr) &#123;</span><br><span class="line">			ll x = a;</span><br><span class="line">			<span class="keyword">while</span>(!defense.<span class="built_in">count</span>(x) &amp;&amp; !attack.<span class="built_in">count</span>(x))</span><br><span class="line">				x &gt;&gt;= <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span>(defense.<span class="built_in">count</span>(x) &amp;&amp; b) &#123;</span><br><span class="line">				ans += (<span class="number">1LL</span> &lt;&lt; (h - __lg(a))) - <span class="number">1</span>;</span><br><span class="line">				attack.<span class="built_in">insert</span>(a);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span>(attack.<span class="built_in">count</span>(x) &amp;&amp; !b) &#123;</span><br><span class="line">				ans -= (<span class="number">1LL</span> &lt;&lt; (h - __lg(a))) - <span class="number">1</span>;</span><br><span class="line">				defense.<span class="built_in">insert</span>(a);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		cout &lt;&lt; ans &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>Competitive Programming</tag>
        <tag>TIOJ</tag>
      </tags>
  </entry>
  <entry>
    <title>TIOJ-1606</title>
    <url>/TIOJ-1606/</url>
    <content><![CDATA[<p>你有一個長度 $n$ 的陣列 $arr$，一開始每項都是 $0$。<br/><br>接著有 $q$ 筆操作，每筆操作可能是：<br/><br>$1\ l\ r\ a\ b$：對於所有 $l\le i\le r$，$arr_i := a\times (i - l + 1)\mod b$。<br/><br>$2\ l\ r$：詢問 $\sum_{i=l}^r arr_i$。<br/></p>
<span id="more"></span>
<p>$n\le 10^9, q\le 5\times 10^4, a\le 10^6, b\le 10^6$</p>
<hr>
<p>這題基本上動態開點會吃 TLE :(<br>所以先離散化。不難發現這個是個區間修改區間和的問題。<br>每個節點除了和以外，懶標的部份我們額外維護 $st, a, b$，代表這個節點的和是 $\sum_{i = 1}^{len} (a\times (i+st)\mod b)$，其中 $len$ 代表區間長度。這樣下推時就能很好的把這三個資訊給下推。<br/></p>
<p>因此接下來的問題就是，給定了那三個資訊，有沒有辦法在夠快的時間內知道這個節點的和是多少？<br>首先令 $S(n)=\sum_{i=0}^n (a\times i\mod b)$，那這個節點的和會是 $S(st+len)-S(st)$，接下來我們把 $S(n)$ 給展開:<br>$$\begin{align*} S(n) &amp;=\sum_{i=0}^n (a\times i\mod b) \\ &amp;=\sum_{i=0}^n (a\times i - \lfloor \frac{a\times i}{b} \rfloor \times b) \\ &amp;=\sum_{i=0}^n a\times i - \sum_{i=0}^n \lfloor \frac{a\times i}{b} \rfloor \times b \\ &amp;= a\times \frac{n(n+1)}{2} + b\times \sum_{i=0}^n \lfloor \frac{a\times i}{b} \rfloor \end{align*}$$<br>於是問題就變成了怎麼計算最後那陀除法總和。<br>注意到如果 $a,b$ 不互質，那可以同除最大公因數來約分讓他們互質，所以我們以下考慮 $a, b$ 互質的情況。<br/></p>
<p>如果 $a\geq b$，那 $\sum_{i=0}^n \lfloor \frac{ai}{b} \rfloor = \lfloor \frac ab \rfloor \times \frac{n(n+1)}{2} + \sum_{i=0}^n \lfloor \frac{(a\mod b)i}{b} \rfloor$，於是問題就變回 $a\lt b$了。<br/><br>接下來考慮 $a\lt b$ 且 $a\neq 0$，其實 $\sum_{i=0}^n \lfloor \frac{ai}{b} \rfloor$ 可以看成在一個 $(0,0),(n,0),(n,\frac{an}b)$ 的三角形內部（含邊上）有多少個不在 x 軸上的格子點？<br/><br>也就是下圖的藍色區域有多少格子點。<br><img src="graph1.jpg" alt="插圖"><br>只不過藍色區域似乎不太好算？<br>可是整個矩形內部的格子點數量很好算！就是 $n\times \lfloor \frac{an}{b}\rfloor$！<br/><br>而在對角線上的格子點數量呢？也很好算！因為 $a, b$ 互質，所以只有在 $i$ 是 $b$ 的倍數的時候 $\frac{ai}{b}$ 是整數。因此格子點數量就是 $\frac{n}{b}$。<br/><br>因此只要我們會算紅色區域的格子點數量，那藍色區域就是（整個矩形）-（紅色區域）+（對角線上的格子點）了！</p>
<p>那要怎麼算紅色區域的格子點數量呢？你試著把頭往右轉 90 度看這張圖，你會發現其實他等同於這樣：<br><img src="graph2.jpg" alt="插圖2"><br>於是紅色區域的格子點數量其實就是當 $a’=b, b’=a, n’=\lfloor \frac{an}{b} \rfloor$ 時的答案了！因為 $a’\gt b’$，所以會先回到第一個 case，並且取 mod 後再回到第二個 case，因為每次取 mod 都會造成 $a$ 或 $b$ 其中一個被砍掉至少一半，所以計算的過程會在 $\mathcal{O}(\log \max(a,b))$ 的時間內跑完！<br/></p>
<p>配上線段樹的 $\mathcal{O}(n\log n)$，整體複雜度 $\mathcal{O}(n\log n\log \max(a, b))$。<br/><br>實作的部份小心 overflow，不過因為最後輸出的答案會在 long long 範圍內，所以變數型態開 unsigned long long 就能當成在 $\mod 2^{64}$ 的情況下計算了。<br/></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">--------------              |   /</span></span><br><span class="line"><span class="comment">      |                     |  /</span></span><br><span class="line"><span class="comment">      |                     | /</span></span><br><span class="line"><span class="comment">      |             *       |/          |    |         ------            *</span></span><br><span class="line"><span class="comment">      |                     |           |    |        /      \</span></span><br><span class="line"><span class="comment">      |             |       |\          |    |       |       |\          |</span></span><br><span class="line"><span class="comment">   \  |             |       | \         |    |       |       | \         |</span></span><br><span class="line"><span class="comment">    \ |             |       |  \        |    |        \     /   \        |</span></span><br><span class="line"><span class="comment">     V              |       |   \        \__/|         -----     \       |</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EmiliaMyWife ios::sync_with_stdio(0); cin.tie(NULL);</span></span><br><span class="line"><span class="keyword">using</span> ull = <span class="keyword">uint64_t</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> EPS  = <span class="number">1e-8</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> Lamy_is_cute = []() &#123;</span><br><span class="line">	EmiliaMyWife</span><br><span class="line">	<span class="keyword">return</span> <span class="number">48763</span>;</span><br><span class="line">&#125;();</span><br><span class="line"><span class="comment">/*--------------------------------------------------------------------------------------*/</span></span><br><span class="line"></span><br><span class="line"><span class="function">ull <span class="title">calc</span><span class="params">(ull a, ull b, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">	ull k = a / b;</span><br><span class="line">	ull extra = k * (<span class="number">1</span> + n) * n / <span class="number">2</span>;</span><br><span class="line">	a %= b;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>(a == <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span> extra;</span><br><span class="line">	</span><br><span class="line">	ull total = a * n / b * n;</span><br><span class="line">	ull on_edge = n / b;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> total - <span class="built_in">calc</span>(b, a, a * n / b) + on_edge + extra;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> ull <span class="title">cal</span><span class="params">(ull a, <span class="keyword">int</span> b, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">	ull g = __gcd(a, <span class="built_in">ull</span>(b));</span><br><span class="line">	<span class="keyword">return</span> <span class="number">1LL</span> * (<span class="number">1</span> + n) * n / <span class="number">2</span> * a - <span class="built_in">calc</span>(a / g, b / g, n) * b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span> + <span class="number">25</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">segtree</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">		ull v;</span><br><span class="line">		<span class="comment">// tag</span></span><br><span class="line">		<span class="keyword">int</span> fst = <span class="number">-1</span>, a, b;</span><br><span class="line">	&#125; arr[N &lt;&lt; <span class="number">2</span>];</span><br><span class="line">	<span class="keyword">int</span> n;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> _n)</span> </span>&#123; n = _n; &#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">upd</span><span class="params">(<span class="keyword">int</span> id, <span class="keyword">int</span> fst, <span class="keyword">int</span> len, <span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">		arr[id].fst = fst;</span><br><span class="line">		arr[id].a = a;</span><br><span class="line">		arr[id].b = b;</span><br><span class="line">		arr[id].v = <span class="built_in">cal</span>(a, b, fst + len) - <span class="built_in">cal</span>(a, b, fst);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> id, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(arr[id].fst == <span class="number">-1</span>)</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		<span class="keyword">int</span> m = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">		<span class="built_in">upd</span>(id &lt;&lt; <span class="number">1</span>, arr[id].fst, v[m] - v[l], arr[id].a, arr[id].b);</span><br><span class="line">		<span class="built_in">upd</span>(id &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, arr[id].fst + v[m] - v[l], v[r] - v[m], arr[id].a, arr[id].b);</span><br><span class="line">		arr[id].fst = <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">edt</span><span class="params">(<span class="keyword">int</span> id, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> ql, <span class="keyword">int</span> qr, <span class="keyword">int</span> fst, <span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(r &lt;= ql || qr &lt;= l)</span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">if</span>(ql &lt;= l &amp;&amp; r &lt;= qr) &#123;</span><br><span class="line">			<span class="built_in">upd</span>(id, fst, v[r] - v[l], a, b);</span><br><span class="line">			<span class="keyword">return</span> v[r] - v[l];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">push</span>(id, l, r);</span><br><span class="line">		<span class="keyword">int</span> m = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">int</span> w = <span class="built_in">edt</span>(id &lt;&lt; <span class="number">1</span>, l, m, ql, qr, fst, a, b);</span><br><span class="line">		w += <span class="built_in">edt</span>(id &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, m, r, ql, qr, fst + w, a, b);</span><br><span class="line">		arr[id].v = arr[id &lt;&lt; <span class="number">1</span>].v + arr[id &lt;&lt; <span class="number">1</span> | <span class="number">1</span>].v;</span><br><span class="line">		<span class="keyword">return</span> w;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">edt</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123; <span class="built_in">edt</span>(<span class="number">1</span>, <span class="number">0</span>, n, l, r, <span class="number">0</span>, a, b); &#125;</span><br><span class="line">	<span class="function">ull <span class="title">que</span><span class="params">(<span class="keyword">int</span> id, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> ql, <span class="keyword">int</span> qr)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(r &lt;= ql || qr &lt;= l)</span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">if</span>(ql &lt;= l &amp;&amp; r &lt;= qr)</span><br><span class="line">			<span class="keyword">return</span> arr[id].v;</span><br><span class="line">		<span class="built_in">push</span>(id, l, r);</span><br><span class="line">		<span class="keyword">int</span> m = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">que</span>(id &lt;&lt; <span class="number">1</span>, l, m, ql, qr) + <span class="built_in">que</span>(id &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, m, r, ql, qr);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> ull <span class="title">que</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">que</span>(<span class="number">1</span>, <span class="number">0</span>, n, l, r); &#125;</span><br><span class="line">&#125; tree;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n, q;</span><br><span class="line">	cin &gt;&gt; n &gt;&gt; q;</span><br><span class="line">	vector&lt;tuple&lt;<span class="keyword">int</span>, <span class="keyword">int</span>, <span class="keyword">int</span>, <span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; <span class="built_in">que</span>(q);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>, t, l, r, a, b; i &lt; q; i++) &#123;</span><br><span class="line">		cin &gt;&gt; t &gt;&gt; l &gt;&gt; r;</span><br><span class="line">		<span class="keyword">if</span>(t == <span class="number">1</span>)</span><br><span class="line">			cin &gt;&gt; a &gt;&gt; b, a %= b;</span><br><span class="line">		l--;</span><br><span class="line">		que[i] = &#123;t, l, r, a, b&#125;;</span><br><span class="line">		v.<span class="built_in">push_back</span>(l);</span><br><span class="line">		v.<span class="built_in">push_back</span>(r);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">sort</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>());</span><br><span class="line">	v.<span class="built_in">erase</span>(<span class="built_in">unique</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>()), v.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line">	tree.<span class="built_in">init</span>(v.<span class="built_in">size</span>());</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">auto</span> &amp;[_, l, r, __, ___] : que) &#123;</span><br><span class="line">		l = <span class="built_in">lower_bound</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), l) - v.<span class="built_in">begin</span>();</span><br><span class="line">		r = <span class="built_in">lower_bound</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), r) - v.<span class="built_in">begin</span>();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">const</span> <span class="keyword">auto</span> &amp;[t, l, r, a, b] : que) &#123;</span><br><span class="line">		<span class="keyword">if</span>(t == <span class="number">1</span>)</span><br><span class="line">			tree.<span class="built_in">edt</span>(l, r, a, b);</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			cout &lt;&lt; tree.<span class="built_in">que</span>(l, r) &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>Competitive Programming</tag>
        <tag>TIOJ</tag>
      </tags>
  </entry>
</search>
